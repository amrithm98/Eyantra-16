
encoder.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000003d8  00800200  00003090  00003124  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003090  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006c0  008005d8  008005d8  000034fc  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  000034fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000004e9  00000000  00000000  0000351c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002053  00000000  00000000  00003a05  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003b3  00000000  00000000  00005a58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001770  00000000  00000000  00005e0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003a0  00000000  00000000  0000757c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000057a  00000000  00000000  0000791c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001127  00000000  00000000  00007e96  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  00008fbd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 ab 02 	jmp	0x556	; 0x556 <__vector_5>
      18:	0c 94 73 02 	jmp	0x4e6	; 0x4e6 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <getFinalDest+0x3c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	15 e0       	ldi	r17, 0x05	; 5
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e0 e9       	ldi	r30, 0x90	; 144
     17e:	f0 e3       	ldi	r31, 0x30	; 48
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 3d       	cpi	r26, 0xD8	; 216
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	1c e0       	ldi	r17, 0x0C	; 12
     192:	a8 ed       	ldi	r26, 0xD8	; 216
     194:	b5 e0       	ldi	r27, 0x05	; 5
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a8 39       	cpi	r26, 0x98	; 152
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 6f 0b 	call	0x16de	; 0x16de <main>
     1a4:	0c 94 46 18 	jmp	0x308c	; 0x308c <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <lcd_set_4bit>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	fc 01       	movw	r30, r24
     1b2:	31 97       	sbiw	r30, 0x01	; 1
     1b4:	f1 f7       	brne	.-4      	; 0x1b2 <lcd_set_4bit+0x6>
/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	40 e3       	ldi	r20, 0x30	; 48
     1bc:	48 b9       	out	0x08, r20	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	20 e0       	ldi	r18, 0x00	; 0
     1c2:	38 e4       	ldi	r19, 0x48	; 72
     1c4:	f9 01       	movw	r30, r18
     1c6:	31 97       	sbiw	r30, 0x01	; 1
     1c8:	f1 f7       	brne	.-4      	; 0x1c6 <lcd_set_4bit+0x1a>
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ca:	42 98       	cbi	0x08, 2	; 8
     1cc:	fc 01       	movw	r30, r24
     1ce:	31 97       	sbiw	r30, 0x01	; 1
     1d0:	f1 f7       	brne	.-4      	; 0x1ce <lcd_set_4bit+0x22>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d2:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1d4:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1d6:	48 b9       	out	0x08, r20	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1d8:	42 9a       	sbi	0x08, 2	; 8
     1da:	f9 01       	movw	r30, r18
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	f1 f7       	brne	.-4      	; 0x1dc <lcd_set_4bit+0x30>
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1e0:	42 98       	cbi	0x08, 2	; 8
     1e2:	fc 01       	movw	r30, r24
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_set_4bit+0x38>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1e8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1ea:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ec:	48 b9       	out	0x08, r20	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1ee:	42 9a       	sbi	0x08, 2	; 8
     1f0:	f9 01       	movw	r30, r18
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_set_4bit+0x46>
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1f6:	42 98       	cbi	0x08, 2	; 8
     1f8:	01 97       	sbiw	r24, 0x01	; 1
     1fa:	f1 f7       	brne	.-4      	; 0x1f8 <lcd_set_4bit+0x4c>

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1fc:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fe:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     200:	80 e2       	ldi	r24, 0x20	; 32
     202:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     204:	42 9a       	sbi	0x08, 2	; 8
     206:	c9 01       	movw	r24, r18
     208:	01 97       	sbiw	r24, 0x01	; 1
     20a:	f1 f7       	brne	.-4      	; 0x208 <lcd_set_4bit+0x5c>
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8

	
}
     20e:	08 95       	ret

00000210 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     210:	98 b1       	in	r25, 0x08	; 8
     212:	9f 70       	andi	r25, 0x0F	; 15
     214:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     216:	28 b1       	in	r18, 0x08	; 8
     218:	98 2f       	mov	r25, r24
     21a:	90 7f       	andi	r25, 0xF0	; 240
     21c:	92 2b       	or	r25, r18
     21e:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     220:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     222:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     224:	42 9a       	sbi	0x08, 2	; 8
     226:	20 e0       	ldi	r18, 0x00	; 0
     228:	38 e4       	ldi	r19, 0x48	; 72
     22a:	f9 01       	movw	r30, r18
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	f1 f7       	brne	.-4      	; 0x22c <lcd_wr_command+0x1c>
	_delay_ms(5);
	cbit(lcd_port,EN);
     230:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     238:	98 b1       	in	r25, 0x08	; 8
     23a:	82 95       	swap	r24
     23c:	80 7f       	andi	r24, 0xF0	; 240
     23e:	98 2b       	or	r25, r24
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	c9 01       	movw	r24, r18
     24a:	01 97       	sbiw	r24, 0x01	; 1
     24c:	f1 f7       	brne	.-4      	; 0x24a <lcd_wr_command+0x3a>
	_delay_ms(5);
	cbit(lcd_port,EN);
     24e:	42 98       	cbi	0x08, 2	; 8
}
     250:	08 95       	ret

00000252 <lcd_init>:
     252:	86 e6       	ldi	r24, 0x66	; 102
     254:	9e e0       	ldi	r25, 0x0E	; 14
     256:	01 97       	sbiw	r24, 0x01	; 1
     258:	f1 f7       	brne	.-4      	; 0x256 <lcd_init+0x4>
/*****Function to Initialize LCD*****/
void lcd_init()
{
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     25a:	88 e2       	ldi	r24, 0x28	; 40
     25c:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
	lcd_wr_command(0x01);
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
	lcd_wr_command(0x06);
     266:	86 e0       	ldi	r24, 0x06	; 6
     268:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
	lcd_wr_command(0x0E);
     26c:	8e e0       	ldi	r24, 0x0E	; 14
     26e:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
	lcd_wr_command(0x80);
     272:	80 e8       	ldi	r24, 0x80	; 128
     274:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
		
}
     278:	08 95       	ret

0000027a <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     27a:	98 b1       	in	r25, 0x08	; 8
     27c:	9f 70       	andi	r25, 0x0F	; 15
     27e:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     280:	28 b1       	in	r18, 0x08	; 8
     282:	98 2f       	mov	r25, r24
     284:	90 7f       	andi	r25, 0xF0	; 240
     286:	92 2b       	or	r25, r18
     288:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     28a:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     28c:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     28e:	42 9a       	sbi	0x08, 2	; 8
     290:	20 e0       	ldi	r18, 0x00	; 0
     292:	38 e4       	ldi	r19, 0x48	; 72
     294:	f9 01       	movw	r30, r18
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	f1 f7       	brne	.-4      	; 0x296 <lcd_wr_char+0x1c>
	_delay_ms(5);
	cbit(lcd_port,EN);
     29a:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     29c:	98 b1       	in	r25, 0x08	; 8
     29e:	9f 70       	andi	r25, 0x0F	; 15
     2a0:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2a2:	98 b1       	in	r25, 0x08	; 8
     2a4:	82 95       	swap	r24
     2a6:	80 7f       	andi	r24, 0xF0	; 240
     2a8:	98 2b       	or	r25, r24
     2aa:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     2ac:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2ae:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2b0:	42 9a       	sbi	0x08, 2	; 8
     2b2:	c9 01       	movw	r24, r18
     2b4:	01 97       	sbiw	r24, 0x01	; 1
     2b6:	f1 f7       	brne	.-4      	; 0x2b4 <lcd_wr_char+0x3a>
	_delay_ms(5);
	cbit(lcd_port,EN);
     2b8:	42 98       	cbi	0x08, 2	; 8
}
     2ba:	08 95       	ret

000002bc <lcd_home>:


void lcd_home()
{
	lcd_wr_command(0x80);
     2bc:	80 e8       	ldi	r24, 0x80	; 128
     2be:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
}
     2c2:	08 95       	ret

000002c4 <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	ec 01       	movw	r28, r24
     2ca:	03 c0       	rjmp	.+6      	; 0x2d2 <lcd_string+0xe>
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     2cc:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
		str++;
     2d0:	21 96       	adiw	r28, 0x01	; 1


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
     2d2:	88 81       	ld	r24, Y
     2d4:	88 23       	and	r24, r24
     2d6:	d1 f7       	brne	.-12     	; 0x2cc <lcd_string+0x8>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	08 95       	ret

000002de <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
	switch (row) {
     2de:	82 30       	cpi	r24, 0x02	; 2
     2e0:	69 f0       	breq	.+26     	; 0x2fc <lcd_cursor+0x1e>
     2e2:	83 30       	cpi	r24, 0x03	; 3
     2e4:	18 f4       	brcc	.+6      	; 0x2ec <lcd_cursor+0xe>
     2e6:	81 30       	cpi	r24, 0x01	; 1
     2e8:	a9 f4       	brne	.+42     	; 0x314 <lcd_cursor+0x36>
     2ea:	05 c0       	rjmp	.+10     	; 0x2f6 <lcd_cursor+0x18>
     2ec:	83 30       	cpi	r24, 0x03	; 3
     2ee:	49 f0       	breq	.+18     	; 0x302 <lcd_cursor+0x24>
     2f0:	84 30       	cpi	r24, 0x04	; 4
     2f2:	81 f4       	brne	.+32     	; 0x314 <lcd_cursor+0x36>
     2f4:	0b c0       	rjmp	.+22     	; 0x30c <lcd_cursor+0x2e>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     2f6:	86 2f       	mov	r24, r22
     2f8:	81 58       	subi	r24, 0x81	; 129
     2fa:	05 c0       	rjmp	.+10     	; 0x306 <lcd_cursor+0x28>
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     2fc:	86 2f       	mov	r24, r22
     2fe:	81 54       	subi	r24, 0x41	; 65
     300:	02 c0       	rjmp	.+4      	; 0x306 <lcd_cursor+0x28>
		case 3: lcd_wr_command (0x94 + column - 1); break;
     302:	86 2f       	mov	r24, r22
     304:	8d 56       	subi	r24, 0x6D	; 109
     306:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
     30a:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     30c:	86 2f       	mov	r24, r22
     30e:	8d 52       	subi	r24, 0x2D	; 45
     310:	0e 94 08 01 	call	0x210	; 0x210 <lcd_wr_command>
     314:	08 95       	ret

00000316 <lcd_print>:
	}
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     316:	0f 93       	push	r16
     318:	1f 93       	push	r17
     31a:	cf 93       	push	r28
     31c:	df 93       	push	r29
     31e:	8a 01       	movw	r16, r20
     320:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     322:	88 23       	and	r24, r24
     324:	11 f0       	breq	.+4      	; 0x32a <lcd_print+0x14>
     326:	66 23       	and	r22, r22
     328:	19 f4       	brne	.+6      	; 0x330 <lcd_print+0x1a>
	{
		lcd_home();
     32a:	0e 94 5e 01 	call	0x2bc	; 0x2bc <lcd_home>
     32e:	02 c0       	rjmp	.+4      	; 0x334 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     330:	0e 94 6f 01 	call	0x2de	; 0x2de <lcd_cursor>
	}
	if(digits==5 || flag==1)
     334:	c5 30       	cpi	r28, 0x05	; 5
     336:	d1 05       	cpc	r29, r1
     338:	71 f4       	brne	.+28     	; 0x356 <lcd_print+0x40>
	{
		million=value/10000+48;
     33a:	c8 01       	movw	r24, r16
     33c:	60 e1       	ldi	r22, 0x10	; 16
     33e:	77 e2       	ldi	r23, 0x27	; 39
     340:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     344:	cb 01       	movw	r24, r22
     346:	c0 96       	adiw	r24, 0x30	; 48
     348:	90 93 3c 06 	sts	0x063C, r25
     34c:	80 93 3b 06 	sts	0x063B, r24
		lcd_wr_char(million);
     350:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
     354:	05 c0       	rjmp	.+10     	; 0x360 <lcd_print+0x4a>
		flag=1;
	}
	if(digits==4 || flag==1)
     356:	c4 30       	cpi	r28, 0x04	; 4
     358:	d1 05       	cpc	r29, r1
     35a:	11 f0       	breq	.+4      	; 0x360 <lcd_print+0x4a>
     35c:	80 e0       	ldi	r24, 0x00	; 0
     35e:	16 c0       	rjmp	.+44     	; 0x38c <lcd_print+0x76>
	{
		temp = value/1000;
     360:	c8 01       	movw	r24, r16
     362:	68 ee       	ldi	r22, 0xE8	; 232
     364:	73 e0       	ldi	r23, 0x03	; 3
     366:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     36a:	cb 01       	movw	r24, r22
     36c:	60 93 b3 08 	sts	0x08B3, r22
     370:	90 93 b4 08 	sts	0x08B4, r25
		thousand = temp%10 + 48;
     374:	6a e0       	ldi	r22, 0x0A	; 10
     376:	70 e0       	ldi	r23, 0x00	; 0
     378:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     37c:	c0 96       	adiw	r24, 0x30	; 48
     37e:	90 93 bf 08 	sts	0x08BF, r25
     382:	80 93 be 08 	sts	0x08BE, r24
		lcd_wr_char(thousand);
     386:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
     38a:	81 e0       	ldi	r24, 0x01	; 1
		flag=1;
	}
	if(digits==3 || flag==1)
     38c:	c3 30       	cpi	r28, 0x03	; 3
     38e:	d1 05       	cpc	r29, r1
     390:	21 f0       	breq	.+8      	; 0x39a <lcd_print+0x84>
     392:	81 30       	cpi	r24, 0x01	; 1
     394:	11 f0       	breq	.+4      	; 0x39a <lcd_print+0x84>
     396:	80 e0       	ldi	r24, 0x00	; 0
     398:	16 c0       	rjmp	.+44     	; 0x3c6 <lcd_print+0xb0>
	{
		temp = value/100;
     39a:	c8 01       	movw	r24, r16
     39c:	64 e6       	ldi	r22, 0x64	; 100
     39e:	70 e0       	ldi	r23, 0x00	; 0
     3a0:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     3a4:	cb 01       	movw	r24, r22
     3a6:	60 93 b3 08 	sts	0x08B3, r22
     3aa:	90 93 b4 08 	sts	0x08B4, r25
		hundred = temp%10 + 48;
     3ae:	6a e0       	ldi	r22, 0x0A	; 10
     3b0:	70 e0       	ldi	r23, 0x00	; 0
     3b2:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     3b6:	c0 96       	adiw	r24, 0x30	; 48
     3b8:	90 93 bb 08 	sts	0x08BB, r25
     3bc:	80 93 ba 08 	sts	0x08BA, r24
		lcd_wr_char(hundred);
     3c0:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
     3c4:	81 e0       	ldi	r24, 0x01	; 1
		flag=1;
	}
	if(digits==2 || flag==1)
     3c6:	c2 30       	cpi	r28, 0x02	; 2
     3c8:	d1 05       	cpc	r29, r1
     3ca:	21 f0       	breq	.+8      	; 0x3d4 <lcd_print+0xbe>
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	11 f0       	breq	.+4      	; 0x3d4 <lcd_print+0xbe>
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	16 c0       	rjmp	.+44     	; 0x400 <lcd_print+0xea>
	{
		temp = value/10;
     3d4:	c8 01       	movw	r24, r16
     3d6:	6a e0       	ldi	r22, 0x0A	; 10
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     3de:	cb 01       	movw	r24, r22
     3e0:	60 93 b3 08 	sts	0x08B3, r22
     3e4:	90 93 b4 08 	sts	0x08B4, r25
		tens = temp%10 + 48;
     3e8:	6a e0       	ldi	r22, 0x0A	; 10
     3ea:	70 e0       	ldi	r23, 0x00	; 0
     3ec:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     3f0:	c0 96       	adiw	r24, 0x30	; 48
     3f2:	90 93 b9 08 	sts	0x08B9, r25
     3f6:	80 93 b8 08 	sts	0x08B8, r24
		lcd_wr_char(tens);
     3fa:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
     3fe:	81 e0       	ldi	r24, 0x01	; 1
		flag=1;
	}
	if(digits==1 || flag==1)
     400:	c1 30       	cpi	r28, 0x01	; 1
     402:	d1 05       	cpc	r29, r1
     404:	11 f0       	breq	.+4      	; 0x40a <lcd_print+0xf4>
     406:	81 30       	cpi	r24, 0x01	; 1
     408:	61 f4       	brne	.+24     	; 0x422 <lcd_print+0x10c>
	{
		unit = value%10 + 48;
     40a:	c8 01       	movw	r24, r16
     40c:	6a e0       	ldi	r22, 0x0A	; 10
     40e:	70 e0       	ldi	r23, 0x00	; 0
     410:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__udivmodhi4>
     414:	c0 96       	adiw	r24, 0x30	; 48
     416:	90 93 bd 08 	sts	0x08BD, r25
     41a:	80 93 bc 08 	sts	0x08BC, r24
		lcd_wr_char(unit);
     41e:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
	}
	if(digits>5)
     422:	26 97       	sbiw	r28, 0x06	; 6
     424:	1c f0       	brlt	.+6      	; 0x42c <lcd_print+0x116>
	{
		lcd_wr_char('E');
     426:	85 e4       	ldi	r24, 0x45	; 69
     428:	0e 94 3d 01 	call	0x27a	; 0x27a <lcd_wr_char>
	}
	
}
     42c:	df 91       	pop	r29
     42e:	cf 91       	pop	r28
     430:	1f 91       	pop	r17
     432:	0f 91       	pop	r16
     434:	08 95       	ret

00000436 <motion_pin_config>:
* Example Call:		motion_pin_config()
*/

void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
     436:	81 b1       	in	r24, 0x01	; 1
     438:	8f 60       	ori	r24, 0x0F	; 15
     43a:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
     43c:	82 b1       	in	r24, 0x02	; 2
     43e:	80 7f       	andi	r24, 0xF0	; 240
     440:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     442:	ea e0       	ldi	r30, 0x0A	; 10
     444:	f1 e0       	ldi	r31, 0x01	; 1
     446:	80 81       	ld	r24, Z
     448:	88 61       	ori	r24, 0x18	; 24
     44a:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     44c:	eb e0       	ldi	r30, 0x0B	; 11
     44e:	f1 e0       	ldi	r31, 0x01	; 1
     450:	80 81       	ld	r24, Z
     452:	88 61       	ori	r24, 0x18	; 24
     454:	80 83       	st	Z, r24
}
     456:	08 95       	ret

00000458 <buzzer_pin_config>:
* Example Call:		buzzer_on()
*/

void buzzer_pin_config(void)
{
	DDRC=DDRC | 0x08; 		// Port C pin 3 as output
     458:	3b 9a       	sbi	0x07, 3	; 7
	PORTC=PORTC & 0xF7;
     45a:	43 98       	cbi	0x08, 3	; 8

}
     45c:	08 95       	ret

0000045e <buzzer_on>:
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
     45e:	88 e0       	ldi	r24, 0x08	; 8
     460:	88 b9       	out	0x08, r24	; 8
}
     462:	08 95       	ret

00000464 <buzzer_off>:
* Example Call:		buzzer_off()
*/

void buzzer_off(void)
{
	PORTC= 0x00;
     464:	18 b8       	out	0x08, r1	; 8
}
     466:	08 95       	ret

00000468 <init_timer5>:
* Example Call:		init_timer5()
*/

void init_timer5(void)	//Timer For PWM
{
	TCCR5B = 0x00;	//stop
     468:	a1 e2       	ldi	r26, 0x21	; 33
     46a:	b1 e0       	ldi	r27, 0x01	; 1
     46c:	1c 92       	st	X, r1
	TCNT5H = 0xFF;	//counter higher 8 bit value to which OCRxH is compared with
     46e:	2f ef       	ldi	r18, 0xFF	; 255
     470:	20 93 25 01 	sts	0x0125, r18
	TCNT5L = 0x01;	//counter higher 8 bit value to which OCRxH is compared with
     474:	81 e0       	ldi	r24, 0x01	; 1
     476:	80 93 24 01 	sts	0x0124, r24
	OCR5AH = 0x00;	//Output compare register high for left motor
     47a:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low for left motor
     47e:	20 93 28 01 	sts	0x0128, r18
	OCR5BH = 0x00;	//Output compare register high for right motor	
     482:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register high for right motor
     486:	20 93 2a 01 	sts	0x012A, r18
	OCR5C  = 0xFF;	//Motor C1
     48a:	ec e2       	ldi	r30, 0x2C	; 44
     48c:	f1 e0       	ldi	r31, 0x01	; 1
     48e:	8f ef       	ldi	r24, 0xFF	; 255
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	91 83       	std	Z+1, r25	; 0x01
     494:	80 83       	st	Z, r24
	OCR5CH = 0x00;	//Motor C1
     496:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;
     49a:	20 83       	st	Z, r18
	TCCR5A = 0xA9;
     49c:	89 ea       	ldi	r24, 0xA9	; 169
     49e:	80 93 20 01 	sts	0x0120, r24
/* COM5A1=1,COM5A0=0,COM5B1=1,COM5B0=0,COM5C1=1,COM5C0=0
For Overriding normal port functionality to OCRnA ouputs
WGM51=0,WGM50=1 along with WGM52 in TCCRB for selecting fast PWM 8 bit mode
*/

	TCCR5B = 0x0B;	//WGM12=1,CS12=0,CS11=1,CS10=1	(Prescaler=64)
     4a2:	8b e0       	ldi	r24, 0x0B	; 11
     4a4:	8c 93       	st	X, r24

}
     4a6:	08 95       	ret

000004a8 <lcd_port_config>:
* Example Call:		lcd_port_config()
*/

void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     4a8:	87 b1       	in	r24, 0x07	; 7
     4aa:	87 6f       	ori	r24, 0xF7	; 247
     4ac:	87 b9       	out	0x07, r24	; 7
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     4ae:	88 b1       	in	r24, 0x08	; 8
     4b0:	80 78       	andi	r24, 0x80	; 128
     4b2:	88 b9       	out	0x08, r24	; 8
}
     4b4:	08 95       	ret

000004b6 <left_encoder_pin_config>:
* Example Call:		left_encoder_pin_config()
*/

void left_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     4b6:	6c 98       	cbi	0x0d, 4	; 13
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     4b8:	74 9a       	sbi	0x0e, 4	; 14
}
     4ba:	08 95       	ret

000004bc <right_encoder_pin_config>:
* Example Call:		right_encoder_pin_config()
*/

void right_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     4bc:	6d 98       	cbi	0x0d, 5	; 13
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     4be:	75 9a       	sbi	0x0e, 5	; 14
}
     4c0:	08 95       	ret

000004c2 <left_position_encoder_interrupt_init>:
* Example Call:		left_position_encoder_interrupt_init()
*/

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
 cli(); //Clears the global interrupt
     4c2:	f8 94       	cli
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     4c4:	ea e6       	ldi	r30, 0x6A	; 106
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	80 81       	ld	r24, Z
     4ca:	82 60       	ori	r24, 0x02	; 2
     4cc:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     4ce:	ec 9a       	sbi	0x1d, 4	; 29
 sei();   // Enables the global interrupt 
     4d0:	78 94       	sei
}
     4d2:	08 95       	ret

000004d4 <right_position_encoder_interrupt_init>:
* Example Call:		right_position_encoder_interrupt_init()
*/

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
 cli(); //Clears the global interrupt
     4d4:	f8 94       	cli
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     4d6:	ea e6       	ldi	r30, 0x6A	; 106
     4d8:	f0 e0       	ldi	r31, 0x00	; 0
     4da:	80 81       	ld	r24, Z
     4dc:	88 60       	ori	r24, 0x08	; 8
     4de:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     4e0:	ed 9a       	sbi	0x1d, 5	; 29
 sei();   // Enables the global interrupt 
     4e2:	78 94       	sei
}
     4e4:	08 95       	ret

000004e6 <__vector_6>:
* Logic :			ISR for right position encoder. Here counting the number of times the circle cuts the encoder
* Example Call:		called by the microcontroller when the interrupt receives a signal
*/

ISR(INT5_vect)  
{
     4e6:	1f 92       	push	r1
     4e8:	0f 92       	push	r0
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	0f 92       	push	r0
     4ee:	11 24       	eor	r1, r1
     4f0:	8f 93       	push	r24
     4f2:	9f 93       	push	r25
     4f4:	af 93       	push	r26
     4f6:	bf 93       	push	r27
 distanceShaft++;
     4f8:	80 91 e3 05 	lds	r24, 0x05E3
     4fc:	90 91 e4 05 	lds	r25, 0x05E4
     500:	a0 91 e5 05 	lds	r26, 0x05E5
     504:	b0 91 e6 05 	lds	r27, 0x05E6
     508:	01 96       	adiw	r24, 0x01	; 1
     50a:	a1 1d       	adc	r26, r1
     50c:	b1 1d       	adc	r27, r1
     50e:	80 93 e3 05 	sts	0x05E3, r24
     512:	90 93 e4 05 	sts	0x05E4, r25
     516:	a0 93 e5 05 	sts	0x05E5, r26
     51a:	b0 93 e6 05 	sts	0x05E6, r27
 ShaftCountRight++;  //increment right shaft position count
     51e:	80 91 df 05 	lds	r24, 0x05DF
     522:	90 91 e0 05 	lds	r25, 0x05E0
     526:	a0 91 e1 05 	lds	r26, 0x05E1
     52a:	b0 91 e2 05 	lds	r27, 0x05E2
     52e:	01 96       	adiw	r24, 0x01	; 1
     530:	a1 1d       	adc	r26, r1
     532:	b1 1d       	adc	r27, r1
     534:	80 93 df 05 	sts	0x05DF, r24
     538:	90 93 e0 05 	sts	0x05E0, r25
     53c:	a0 93 e1 05 	sts	0x05E1, r26
     540:	b0 93 e2 05 	sts	0x05E2, r27
}
     544:	bf 91       	pop	r27
     546:	af 91       	pop	r26
     548:	9f 91       	pop	r25
     54a:	8f 91       	pop	r24
     54c:	0f 90       	pop	r0
     54e:	0f be       	out	0x3f, r0	; 63
     550:	0f 90       	pop	r0
     552:	1f 90       	pop	r1
     554:	18 95       	reti

00000556 <__vector_5>:
* Logic :			ISR for left position encoder. Here counting the number of times the circle cuts the encoder
* Example Call:		called by the microcontroller when the interrupt receives a signal
*/

ISR(INT4_vect)
{
     556:	1f 92       	push	r1
     558:	0f 92       	push	r0
     55a:	0f b6       	in	r0, 0x3f	; 63
     55c:	0f 92       	push	r0
     55e:	11 24       	eor	r1, r1
     560:	8f 93       	push	r24
     562:	9f 93       	push	r25
     564:	af 93       	push	r26
     566:	bf 93       	push	r27
 distanceShaft++;
     568:	80 91 e3 05 	lds	r24, 0x05E3
     56c:	90 91 e4 05 	lds	r25, 0x05E4
     570:	a0 91 e5 05 	lds	r26, 0x05E5
     574:	b0 91 e6 05 	lds	r27, 0x05E6
     578:	01 96       	adiw	r24, 0x01	; 1
     57a:	a1 1d       	adc	r26, r1
     57c:	b1 1d       	adc	r27, r1
     57e:	80 93 e3 05 	sts	0x05E3, r24
     582:	90 93 e4 05 	sts	0x05E4, r25
     586:	a0 93 e5 05 	sts	0x05E5, r26
     58a:	b0 93 e6 05 	sts	0x05E6, r27
 ShaftCountLeft++;  //increment left shaft position count
     58e:	80 91 db 05 	lds	r24, 0x05DB
     592:	90 91 dc 05 	lds	r25, 0x05DC
     596:	a0 91 dd 05 	lds	r26, 0x05DD
     59a:	b0 91 de 05 	lds	r27, 0x05DE
     59e:	01 96       	adiw	r24, 0x01	; 1
     5a0:	a1 1d       	adc	r26, r1
     5a2:	b1 1d       	adc	r27, r1
     5a4:	80 93 db 05 	sts	0x05DB, r24
     5a8:	90 93 dc 05 	sts	0x05DC, r25
     5ac:	a0 93 dd 05 	sts	0x05DD, r26
     5b0:	b0 93 de 05 	sts	0x05DE, r27
}
     5b4:	bf 91       	pop	r27
     5b6:	af 91       	pop	r26
     5b8:	9f 91       	pop	r25
     5ba:	8f 91       	pop	r24
     5bc:	0f 90       	pop	r0
     5be:	0f be       	out	0x3f, r0	; 63
     5c0:	0f 90       	pop	r0
     5c2:	1f 90       	pop	r1
     5c4:	18 95       	reti

000005c6 <motion_set>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5c6:	92 b1       	in	r25, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5c8:	90 7f       	andi	r25, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5ca:	8f 70       	andi	r24, 0x0F	; 15
     5cc:	89 2b       	or	r24, r25
 PORTA = PortARestore; 		// executing the command
     5ce:	82 b9       	out	0x02, r24	; 2
}
     5d0:	08 95       	ret

000005d2 <forward>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5d2:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5d4:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5d6:	86 60       	ori	r24, 0x06	; 6
 PORTA = PortARestore; 		// executing the command
     5d8:	82 b9       	out	0x02, r24	; 2
*/

void forward (void) //both wheels forward
{
  motion_set(0x06);
}
     5da:	08 95       	ret

000005dc <back>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5dc:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5de:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5e0:	89 60       	ori	r24, 0x09	; 9
 PORTA = PortARestore; 		// executing the command
     5e2:	82 b9       	out	0x02, r24	; 2
*/

void back (void) //both wheels backward
{
  motion_set(0x09);
}
     5e4:	08 95       	ret

000005e6 <left>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5e6:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5e8:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5ea:	85 60       	ori	r24, 0x05	; 5
 PORTA = PortARestore; 		// executing the command
     5ec:	82 b9       	out	0x02, r24	; 2
*/

void left (void)	//Left wheel backward, Right wheel forward
{
  motion_set(0x05);
}
     5ee:	08 95       	ret

000005f0 <right>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5f0:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5f2:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5f4:	8a 60       	ori	r24, 0x0A	; 10
 PORTA = PortARestore; 		// executing the command
     5f6:	82 b9       	out	0x02, r24	; 2
*/

void right (void) //Left wheel forward, Right wheel backward
{
  motion_set(0x0A);
}
     5f8:	08 95       	ret

000005fa <soft_left>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     5fa:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     5fc:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     5fe:	84 60       	ori	r24, 0x04	; 4
 PORTA = PortARestore; 		// executing the command
     600:	82 b9       	out	0x02, r24	; 2
*/

void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
}
     602:	08 95       	ret

00000604 <soft_right>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     604:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     606:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     608:	82 60       	ori	r24, 0x02	; 2
 PORTA = PortARestore; 		// executing the command
     60a:	82 b9       	out	0x02, r24	; 2
*/

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
}
     60c:	08 95       	ret

0000060e <stop>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     60e:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     610:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
     612:	82 b9       	out	0x02, r24	; 2
*/

void stop (void)
{
  motion_set(0x00);
}
     614:	08 95       	ret

00000616 <angle_rotate>:
* Logic :			For turning robot by specified degrees using encoders. When the shaftCount varibles reach the threshold, the motion is stopped
* Example Call:		angle_rotate(30)
*/

void angle_rotate(unsigned int Degrees)
{
     616:	ef 92       	push	r14
     618:	ff 92       	push	r15
     61a:	0f 93       	push	r16
     61c:	1f 93       	push	r17
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;
 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     61e:	a0 e0       	ldi	r26, 0x00	; 0
     620:	b0 e0       	ldi	r27, 0x00	; 0
     622:	bc 01       	movw	r22, r24
     624:	cd 01       	movw	r24, r26
     626:	0e 94 03 13 	call	0x2606	; 0x2606 <__floatunsisf>
     62a:	28 e4       	ldi	r18, 0x48	; 72
     62c:	31 ee       	ldi	r19, 0xE1	; 225
     62e:	42 e8       	ldi	r20, 0x82	; 130
     630:	50 e4       	ldi	r21, 0x40	; 64
     632:	0e 94 75 11 	call	0x22ea	; 0x22ea <__divsf3>
     636:	0e 94 a5 0e 	call	0x1d4a	; 0x1d4a <__fixunssfsi>
     63a:	7b 01       	movw	r14, r22
     63c:	8c 01       	movw	r16, r24
 ShaftCountRight = 0; 
     63e:	10 92 df 05 	sts	0x05DF, r1
     642:	10 92 e0 05 	sts	0x05E0, r1
     646:	10 92 e1 05 	sts	0x05E1, r1
     64a:	10 92 e2 05 	sts	0x05E2, r1
 ShaftCountLeft = 0; 
     64e:	10 92 db 05 	sts	0x05DB, r1
     652:	10 92 dc 05 	sts	0x05DC, r1
     656:	10 92 dd 05 	sts	0x05DD, r1
     65a:	10 92 de 05 	sts	0x05DE, r1
 while (1)
 {
  //lcd_print(2,8,ShaftCountLeft,2);
  //lcd_print(2,5,ShaftCountRight,2);
  //lcd_print(2,1,ReqdShaftCountInt,3);
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     65e:	80 91 df 05 	lds	r24, 0x05DF
     662:	90 91 e0 05 	lds	r25, 0x05E0
     666:	a0 91 e1 05 	lds	r26, 0x05E1
     66a:	b0 91 e2 05 	lds	r27, 0x05E2
     66e:	20 91 db 05 	lds	r18, 0x05DB
     672:	30 91 dc 05 	lds	r19, 0x05DC
     676:	40 91 dd 05 	lds	r20, 0x05DD
     67a:	50 91 de 05 	lds	r21, 0x05DE
     67e:	8e 15       	cp	r24, r14
     680:	9f 05       	cpc	r25, r15
     682:	a0 07       	cpc	r26, r16
     684:	b1 07       	cpc	r27, r17
     686:	28 f4       	brcc	.+10     	; 0x692 <angle_rotate+0x7c>
     688:	2e 15       	cp	r18, r14
     68a:	3f 05       	cpc	r19, r15
     68c:	40 07       	cpc	r20, r16
     68e:	51 07       	cpc	r21, r17
     690:	30 f3       	brcs	.-52     	; 0x65e <angle_rotate+0x48>

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     692:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     694:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
     696:	82 b9       	out	0x02, r24	; 2
  //lcd_print(2,1,ReqdShaftCountInt,3);
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
  			break;
 }
 stop(); //Stop robot
}
     698:	1f 91       	pop	r17
     69a:	0f 91       	pop	r16
     69c:	ff 90       	pop	r15
     69e:	ef 90       	pop	r14
     6a0:	08 95       	ret

000006a2 <linear_distance_mm>:
* Logic :			For moving robot by specified distance using encoders. When the shaftCount varibles reach the threshold, the motion is stopped
* Example Call:		linear_distance_mm(100)
*/

void linear_distance_mm(unsigned int DistanceInMM)
{
     6a2:	ef 92       	push	r14
     6a4:	ff 92       	push	r15
     6a6:	0f 93       	push	r16
     6a8:	1f 93       	push	r17
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;
 ReqdShaftCount =(float) DistanceInMM / 5.338; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     6aa:	a0 e0       	ldi	r26, 0x00	; 0
     6ac:	b0 e0       	ldi	r27, 0x00	; 0
     6ae:	bc 01       	movw	r22, r24
     6b0:	cd 01       	movw	r24, r26
     6b2:	0e 94 03 13 	call	0x2606	; 0x2606 <__floatunsisf>
     6b6:	25 ee       	ldi	r18, 0xE5	; 229
     6b8:	30 ed       	ldi	r19, 0xD0	; 208
     6ba:	4a ea       	ldi	r20, 0xAA	; 170
     6bc:	50 e4       	ldi	r21, 0x40	; 64
     6be:	0e 94 75 11 	call	0x22ea	; 0x22ea <__divsf3>
     6c2:	0e 94 a5 0e 	call	0x1d4a	; 0x1d4a <__fixunssfsi>
     6c6:	7b 01       	movw	r14, r22
     6c8:	8c 01       	movw	r16, r24
 ShaftCountLeft = ShaftCountRight = 0;
     6ca:	10 92 df 05 	sts	0x05DF, r1
     6ce:	10 92 e0 05 	sts	0x05E0, r1
     6d2:	10 92 e1 05 	sts	0x05E1, r1
     6d6:	10 92 e2 05 	sts	0x05E2, r1
     6da:	80 91 df 05 	lds	r24, 0x05DF
     6de:	90 91 e0 05 	lds	r25, 0x05E0
     6e2:	a0 91 e1 05 	lds	r26, 0x05E1
     6e6:	b0 91 e2 05 	lds	r27, 0x05E2
     6ea:	80 93 db 05 	sts	0x05DB, r24
     6ee:	90 93 dc 05 	sts	0x05DC, r25
     6f2:	a0 93 dd 05 	sts	0x05DD, r26
     6f6:	b0 93 de 05 	sts	0x05DE, r27
 while(1)
 {
  //lcd_print(2,1,ShaftCountLeft,2);
  //lcd_print(2,1,ShaftCountRight,5);
  //lcd_print(2,7,ReqdShaftCountInt,5);
  if((ShaftCountLeft > ReqdShaftCountInt) | (ShaftCountRight > ReqdShaftCountInt))
     6fa:	80 91 db 05 	lds	r24, 0x05DB
     6fe:	90 91 dc 05 	lds	r25, 0x05DC
     702:	a0 91 dd 05 	lds	r26, 0x05DD
     706:	b0 91 de 05 	lds	r27, 0x05DE
     70a:	20 91 df 05 	lds	r18, 0x05DF
     70e:	30 91 e0 05 	lds	r19, 0x05E0
     712:	40 91 e1 05 	lds	r20, 0x05E1
     716:	50 91 e2 05 	lds	r21, 0x05E2
     71a:	e8 16       	cp	r14, r24
     71c:	f9 06       	cpc	r15, r25
     71e:	0a 07       	cpc	r16, r26
     720:	1b 07       	cpc	r17, r27
     722:	28 f0       	brcs	.+10     	; 0x72e <linear_distance_mm+0x8c>
     724:	e2 16       	cp	r14, r18
     726:	f3 06       	cpc	r15, r19
     728:	04 07       	cpc	r16, r20
     72a:	15 07       	cpc	r17, r21
     72c:	30 f7       	brcc	.-52     	; 0x6fa <linear_distance_mm+0x58>

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     72e:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     730:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
     732:	82 b9       	out	0x02, r24	; 2
  {
  	break;
  }
 } 
 stop(); //Stop robot
}
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	ff 90       	pop	r15
     73a:	ef 90       	pop	r14
     73c:	08 95       	ret

0000073e <forward_mm>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     73e:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     740:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     742:	26 60       	ori	r18, 0x06	; 6
 PORTA = PortARestore; 		// executing the command
     744:	22 b9       	out	0x02, r18	; 2
*/

void forward_mm(unsigned int DistanceInMM)
{
 forward();
 linear_distance_mm(DistanceInMM);
     746:	0e 94 51 03 	call	0x6a2	; 0x6a2 <linear_distance_mm>
}
     74a:	08 95       	ret

0000074c <back_mm>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     74c:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     74e:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     750:	29 60       	ori	r18, 0x09	; 9
 PORTA = PortARestore; 		// executing the command
     752:	22 b9       	out	0x02, r18	; 2
*/

void back_mm(unsigned int DistanceInMM)
{
 back();
 linear_distance_mm(DistanceInMM);
     754:	0e 94 51 03 	call	0x6a2	; 0x6a2 <linear_distance_mm>
}
     758:	08 95       	ret

0000075a <left_degrees>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     75a:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     75c:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     75e:	25 60       	ori	r18, 0x05	; 5
 PORTA = PortARestore; 		// executing the command
     760:	22 b9       	out	0x02, r18	; 2

void left_degrees(unsigned int Degrees) 
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
 angle_rotate(Degrees);
     762:	0e 94 0b 03 	call	0x616	; 0x616 <angle_rotate>
}
     766:	08 95       	ret

00000768 <right_degrees>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     768:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     76a:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     76c:	2a 60       	ori	r18, 0x0A	; 10
 PORTA = PortARestore; 		// executing the command
     76e:	22 b9       	out	0x02, r18	; 2

void right_degrees(unsigned int Degrees)
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
 angle_rotate(Degrees);
     770:	0e 94 0b 03 	call	0x616	; 0x616 <angle_rotate>
}
     774:	08 95       	ret

00000776 <soft_left_degrees>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     776:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     778:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     77a:	24 60       	ori	r18, 0x04	; 4
 PORTA = PortARestore; 		// executing the command
     77c:	22 b9       	out	0x02, r18	; 2
void soft_left_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     77e:	88 0f       	add	r24, r24
     780:	99 1f       	adc	r25, r25
     782:	0e 94 0b 03 	call	0x616	; 0x616 <angle_rotate>
}
     786:	08 95       	ret

00000788 <soft_right_degrees>:

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
     788:	22 b1       	in	r18, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     78a:	20 7f       	andi	r18, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     78c:	22 60       	ori	r18, 0x02	; 2
 PORTA = PortARestore; 		// executing the command
     78e:	22 b9       	out	0x02, r18	; 2
void soft_right_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     790:	88 0f       	add	r24, r24
     792:	99 1f       	adc	r25, r25
     794:	0e 94 0b 03 	call	0x616	; 0x616 <angle_rotate>
}
     798:	08 95       	ret

0000079a <adc_pin_config>:
* Example Call:		adc_pin_config()
*/

void adc_pin_config(void)
{
	DDRF=0x00;
     79a:	10 ba       	out	0x10, r1	; 16
	PORTF=0x00;
     79c:	11 ba       	out	0x11, r1	; 17
	DDRK=0x00;
     79e:	10 92 07 01 	sts	0x0107, r1
	PORTK=0x00;
     7a2:	10 92 08 01 	sts	0x0108, r1
}
     7a6:	08 95       	ret

000007a8 <adc_init>:
* Example Call:		adc_pin_config()
*/

void adc_init(void)
{
	ADCSRA=0x00;
     7a8:	ea e7       	ldi	r30, 0x7A	; 122
     7aa:	f0 e0       	ldi	r31, 0x00	; 0
     7ac:	10 82       	st	Z, r1
	ADCSRB=0x00;
     7ae:	10 92 7b 00 	sts	0x007B, r1
	ADMUX=0x00;
     7b2:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA=0x86;	//ADEN=1 ADIE=1....
     7b6:	86 e8       	ldi	r24, 0x86	; 134
     7b8:	80 83       	st	Z, r24
	ACSR=0x80;
     7ba:	80 e8       	ldi	r24, 0x80	; 128
     7bc:	80 bf       	out	0x30, r24	; 48
}
     7be:	08 95       	ret

000007c0 <velocity>:

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
     7c0:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char) right;
     7c4:	60 93 2a 01 	sts	0x012A, r22
}
     7c8:	08 95       	ret

000007ca <port_init>:
* Example Call:		motion_pin_config()
*/

void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
     7ca:	81 b1       	in	r24, 0x01	; 1
     7cc:	8f 60       	ori	r24, 0x0F	; 15
     7ce:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
     7d0:	82 b1       	in	r24, 0x02	; 2
     7d2:	80 7f       	andi	r24, 0xF0	; 240
     7d4:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     7d6:	ea e0       	ldi	r30, 0x0A	; 10
     7d8:	f1 e0       	ldi	r31, 0x01	; 1
     7da:	80 81       	ld	r24, Z
     7dc:	88 61       	ori	r24, 0x18	; 24
     7de:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     7e0:	eb e0       	ldi	r30, 0x0B	; 11
     7e2:	f1 e0       	ldi	r31, 0x01	; 1
     7e4:	80 81       	ld	r24, Z
     7e6:	88 61       	ori	r24, 0x18	; 24
     7e8:	80 83       	st	Z, r24
* Example Call:		left_encoder_pin_config()
*/

void left_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     7ea:	6c 98       	cbi	0x0d, 4	; 13
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     7ec:	74 9a       	sbi	0x0e, 4	; 14
* Example Call:		right_encoder_pin_config()
*/

void right_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     7ee:	6d 98       	cbi	0x0d, 5	; 13
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     7f0:	75 9a       	sbi	0x0e, 5	; 14
* Example Call:		buzzer_on()
*/

void buzzer_pin_config(void)
{
	DDRC=DDRC | 0x08; 		// Port C pin 3 as output
     7f2:	3b 9a       	sbi	0x07, 3	; 7
	PORTC=PORTC & 0xF7;
     7f4:	43 98       	cbi	0x08, 3	; 8
{
 motion_pin_config(); //robot motion pins config
 left_encoder_pin_config(); //left encoder pin config
 right_encoder_pin_config(); //right encoder pin config	
 buzzer_pin_config();//Buzzer Pin
}
     7f6:	08 95       	ret

000007f8 <init_devices>:
* Example Call:		init_devices()
*/

void init_devices()
{
 cli(); //Clears the global interrupt
     7f8:	f8 94       	cli
 port_init();  //Initializes all the ports
     7fa:	0e 94 e5 03 	call	0x7ca	; 0x7ca <port_init>
* Example Call:		lcd_port_config()
*/

void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     7fe:	87 b1       	in	r24, 0x07	; 7
     800:	87 6f       	ori	r24, 0xF7	; 247
     802:	87 b9       	out	0x07, r24	; 7
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     804:	88 b1       	in	r24, 0x08	; 8
     806:	80 78       	andi	r24, 0x80	; 128
     808:	88 b9       	out	0x08, r24	; 8
* Example Call:		adc_pin_config()
*/

void adc_pin_config(void)
{
	DDRF=0x00;
     80a:	10 ba       	out	0x10, r1	; 16
	PORTF=0x00;
     80c:	11 ba       	out	0x11, r1	; 17
	DDRK=0x00;
     80e:	10 92 07 01 	sts	0x0107, r1
	PORTK=0x00;
     812:	10 92 08 01 	sts	0x0108, r1
* Example Call:		init_timer5()
*/

void init_timer5(void)	//Timer For PWM
{
	TCCR5B = 0x00;	//stop
     816:	a1 e2       	ldi	r26, 0x21	; 33
     818:	b1 e0       	ldi	r27, 0x01	; 1
     81a:	1c 92       	st	X, r1
	TCNT5H = 0xFF;	//counter higher 8 bit value to which OCRxH is compared with
     81c:	2f ef       	ldi	r18, 0xFF	; 255
     81e:	20 93 25 01 	sts	0x0125, r18
	TCNT5L = 0x01;	//counter higher 8 bit value to which OCRxH is compared with
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	80 93 24 01 	sts	0x0124, r24
	OCR5AH = 0x00;	//Output compare register high for left motor
     828:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low for left motor
     82c:	20 93 28 01 	sts	0x0128, r18
	OCR5BH = 0x00;	//Output compare register high for right motor	
     830:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register high for right motor
     834:	20 93 2a 01 	sts	0x012A, r18
	OCR5C  = 0xFF;	//Motor C1
     838:	ec e2       	ldi	r30, 0x2C	; 44
     83a:	f1 e0       	ldi	r31, 0x01	; 1
     83c:	8f ef       	ldi	r24, 0xFF	; 255
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	91 83       	std	Z+1, r25	; 0x01
     842:	80 83       	st	Z, r24
	OCR5CH = 0x00;	//Motor C1
     844:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;
     848:	20 83       	st	Z, r18
	TCCR5A = 0xA9;
     84a:	89 ea       	ldi	r24, 0xA9	; 169
     84c:	80 93 20 01 	sts	0x0120, r24
/* COM5A1=1,COM5A0=0,COM5B1=1,COM5B0=0,COM5C1=1,COM5C0=0
For Overriding normal port functionality to OCRnA ouputs
WGM51=0,WGM50=1 along with WGM52 in TCCRB for selecting fast PWM 8 bit mode
*/

	TCCR5B = 0x0B;	//WGM12=1,CS12=0,CS11=1,CS10=1	(Prescaler=64)
     850:	8b e0       	ldi	r24, 0x0B	; 11
     852:	8c 93       	st	X, r24
* Example Call:		left_position_encoder_interrupt_init()
*/

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
 cli(); //Clears the global interrupt
     854:	f8 94       	cli
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     856:	ea e6       	ldi	r30, 0x6A	; 106
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	80 81       	ld	r24, Z
     85c:	82 60       	ori	r24, 0x02	; 2
     85e:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     860:	ec 9a       	sbi	0x1d, 4	; 29
 sei();   // Enables the global interrupt 
     862:	78 94       	sei
* Example Call:		right_position_encoder_interrupt_init()
*/

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
 cli(); //Clears the global interrupt
     864:	f8 94       	cli
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     866:	ea e6       	ldi	r30, 0x6A	; 106
     868:	f0 e0       	ldi	r31, 0x00	; 0
     86a:	80 81       	ld	r24, Z
     86c:	88 60       	ori	r24, 0x08	; 8
     86e:	80 83       	st	Z, r24
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     870:	ed 9a       	sbi	0x1d, 5	; 29
 sei();   // Enables the global interrupt 
     872:	78 94       	sei
* Example Call:		adc_pin_config()
*/

void adc_init(void)
{
	ADCSRA=0x00;
     874:	ea e7       	ldi	r30, 0x7A	; 122
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	10 82       	st	Z, r1
	ADCSRB=0x00;
     87a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX=0x00;
     87e:	10 92 7c 00 	sts	0x007C, r1
	ADCSRA=0x86;	//ADEN=1 ADIE=1....
     882:	86 e8       	ldi	r24, 0x86	; 134
     884:	80 83       	st	Z, r24
	ACSR=0x80;
     886:	80 e8       	ldi	r24, 0x80	; 128
     888:	80 bf       	out	0x30, r24	; 48
 adc_pin_config();
 init_timer5();
 left_position_encoder_interrupt_init();
 right_position_encoder_interrupt_init();
 adc_init();
 sei();   // Enables the global interrupt 
     88a:	78 94       	sei
}
     88c:	08 95       	ret

0000088e <ADC_Conversion>:
* Logic:			Converting the analog Readings to Digital values
* Example Call:		ADC_Conversion(3)
*/

unsigned char ADC_Conversion(unsigned char ch)
{
     88e:	98 2f       	mov	r25, r24
	unsigned char a;
	if(ch>7)
     890:	88 30       	cpi	r24, 0x08	; 8
     892:	18 f0       	brcs	.+6      	; 0x89a <ADC_Conversion+0xc>
	{
		ADCSRB=0x08;
     894:	88 e0       	ldi	r24, 0x08	; 8
     896:	80 93 7b 00 	sts	0x007B, r24
	}
	ch=ch & 0x07;
	ADMUX=0x20 | ch;
     89a:	97 70       	andi	r25, 0x07	; 7
     89c:	90 62       	ori	r25, 0x20	; 32
     89e:	90 93 7c 00 	sts	0x007C, r25
	ADCSRA =ADCSRA | 0x40;		//set start conv bit
     8a2:	80 91 7a 00 	lds	r24, 0x007A
     8a6:	80 64       	ori	r24, 0x40	; 64
     8a8:	80 93 7a 00 	sts	0x007A, r24
	while((ADCSRA & 0x10)==0);	//wait for adc conv to complete
     8ac:	80 91 7a 00 	lds	r24, 0x007A
     8b0:	84 ff       	sbrs	r24, 4
     8b2:	fc cf       	rjmp	.-8      	; 0x8ac <ADC_Conversion+0x1e>
	a=ADCH;						//Result stored here after convo
     8b4:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA=ADCSRA | 0x10;		//Clear ADIF by setting it to 1
     8b8:	90 91 7a 00 	lds	r25, 0x007A
     8bc:	90 61       	ori	r25, 0x10	; 16
     8be:	90 93 7a 00 	sts	0x007A, r25
	ADCSRB=0x00;
     8c2:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     8c6:	08 95       	ret

000008c8 <print_sensor>:
* Logic:			Converting the analog Readings to Digital values and printing them on LCD
* Example Call:		print_sensor(1,1,3);
*/

void print_sensor(char row,char col,unsigned char channel)
{
     8c8:	0f 93       	push	r16
     8ca:	1f 93       	push	r17
     8cc:	18 2f       	mov	r17, r24
     8ce:	06 2f       	mov	r16, r22
     8d0:	84 2f       	mov	r24, r20
	ADC_Value=ADC_Conversion(channel);
     8d2:	0e 94 47 04 	call	0x88e	; 0x88e <ADC_Conversion>
     8d6:	48 2f       	mov	r20, r24
     8d8:	80 93 b5 08 	sts	0x08B5, r24
	lcd_print(row,col,ADC_Value,3);
     8dc:	81 2f       	mov	r24, r17
     8de:	60 2f       	mov	r22, r16
     8e0:	50 e0       	ldi	r21, 0x00	; 0
     8e2:	23 e0       	ldi	r18, 0x03	; 3
     8e4:	30 e0       	ldi	r19, 0x00	; 0
     8e6:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
}
     8ea:	1f 91       	pop	r17
     8ec:	0f 91       	pop	r16
     8ee:	08 95       	ret

000008f0 <addToArr>:
* Output:			values will be stored to array
* Logic:			Initialization
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
     8f0:	cf 92       	push	r12
     8f2:	df 92       	push	r13
     8f4:	ef 92       	push	r14
     8f6:	ff 92       	push	r15
     8f8:	0f 93       	push	r16
     8fa:	1f 93       	push	r17
     8fc:	fc 01       	movw	r30, r24
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     8fe:	71 83       	std	Z+1, r23	; 0x01
     900:	60 83       	st	Z, r22
     902:	53 83       	std	Z+3, r21	; 0x03
     904:	42 83       	std	Z+2, r20	; 0x02
     906:	35 83       	std	Z+5, r19	; 0x05
     908:	24 83       	std	Z+4, r18	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     90a:	17 83       	std	Z+7, r17	; 0x07
     90c:	06 83       	std	Z+6, r16	; 0x06
     90e:	f1 86       	std	Z+9, r15	; 0x09
     910:	e0 86       	std	Z+8, r14	; 0x08
     912:	d3 86       	std	Z+11, r13	; 0x0b
     914:	c2 86       	std	Z+10, r12	; 0x0a
}
     916:	1f 91       	pop	r17
     918:	0f 91       	pop	r16
     91a:	ff 90       	pop	r15
     91c:	ef 90       	pop	r14
     91e:	df 90       	pop	r13
     920:	cf 90       	pop	r12
     922:	08 95       	ret

00000924 <getFinalDest>:
* Output:			length of the resultant array will be returned after storing result in final array
* Logic:			Store the values to array
* Example Call:		getFinalDest(3,finalDest[]);
*/

int getFinalDest(int dest, int finalDest[]) {
     924:	9c 01       	movw	r18, r24
     926:	fb 01       	movw	r30, r22
	if (dest < 25) {
     928:	89 31       	cpi	r24, 0x19	; 25
     92a:	91 05       	cpc	r25, r1
     92c:	2c f4       	brge	.+10     	; 0x938 <getFinalDest+0x14>
		finalDest[0] = dest;
     92e:	91 83       	std	Z+1, r25	; 0x01
     930:	80 83       	st	Z, r24
     932:	21 e0       	ldi	r18, 0x01	; 1
     934:	30 e0       	ldi	r19, 0x00	; 0
     936:	d1 c0       	rjmp	.+418    	; 0xada <getFinalDest+0x1b6>
		return 1;
	} else {
		switch(dest) {
     938:	8d 31       	cpi	r24, 0x1D	; 29
     93a:	91 05       	cpc	r25, r1
     93c:	09 f4       	brne	.+2      	; 0x940 <getFinalDest+0x1c>
     93e:	67 c0       	rjmp	.+206    	; 0xa0e <getFinalDest+0xea>
     940:	8e 31       	cpi	r24, 0x1E	; 30
     942:	91 05       	cpc	r25, r1
     944:	8c f4       	brge	.+34     	; 0x968 <getFinalDest+0x44>
     946:	8a 31       	cpi	r24, 0x1A	; 26
     948:	91 05       	cpc	r25, r1
     94a:	71 f1       	breq	.+92     	; 0x9a8 <getFinalDest+0x84>
     94c:	8b 31       	cpi	r24, 0x1B	; 27
     94e:	91 05       	cpc	r25, r1
     950:	24 f4       	brge	.+8      	; 0x95a <getFinalDest+0x36>
     952:	89 31       	cpi	r24, 0x19	; 25
     954:	91 05       	cpc	r25, r1
     956:	c1 f4       	brne	.+48     	; 0x988 <getFinalDest+0x64>
     958:	1a c0       	rjmp	.+52     	; 0x98e <getFinalDest+0x6a>
     95a:	8b 31       	cpi	r24, 0x1B	; 27
     95c:	91 05       	cpc	r25, r1
     95e:	c9 f1       	breq	.+114    	; 0x9d2 <getFinalDest+0xae>
     960:	8c 31       	cpi	r24, 0x1C	; 28
     962:	91 05       	cpc	r25, r1
     964:	89 f4       	brne	.+34     	; 0x988 <getFinalDest+0x64>
     966:	44 c0       	rjmp	.+136    	; 0x9f0 <getFinalDest+0xcc>
     968:	8f 31       	cpi	r24, 0x1F	; 31
     96a:	91 05       	cpc	r25, r1
     96c:	09 f4       	brne	.+2      	; 0x970 <getFinalDest+0x4c>
     96e:	75 c0       	rjmp	.+234    	; 0xa5a <getFinalDest+0x136>
     970:	8f 31       	cpi	r24, 0x1F	; 31
     972:	91 05       	cpc	r25, r1
     974:	0c f4       	brge	.+2      	; 0x978 <getFinalDest+0x54>
     976:	62 c0       	rjmp	.+196    	; 0xa3c <getFinalDest+0x118>
     978:	80 32       	cpi	r24, 0x20	; 32
     97a:	91 05       	cpc	r25, r1
     97c:	09 f4       	brne	.+2      	; 0x980 <getFinalDest+0x5c>
     97e:	7c c0       	rjmp	.+248    	; 0xa78 <getFinalDest+0x154>
     980:	81 32       	cpi	r24, 0x21	; 33
     982:	91 05       	cpc	r25, r1
     984:	09 f4       	brne	.+2      	; 0x988 <getFinalDest+0x64>
     986:	93 c0       	rjmp	.+294    	; 0xaae <getFinalDest+0x18a>
     988:	20 e0       	ldi	r18, 0x00	; 0
     98a:	30 e0       	ldi	r19, 0x00	; 0
     98c:	a6 c0       	rjmp	.+332    	; 0xada <getFinalDest+0x1b6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     98e:	81 e0       	ldi	r24, 0x01	; 1
     990:	90 e0       	ldi	r25, 0x00	; 0
     992:	91 83       	std	Z+1, r25	; 0x01
     994:	80 83       	st	Z, r24
     996:	33 83       	std	Z+3, r19	; 0x03
     998:	22 83       	std	Z+2, r18	; 0x02
     99a:	8a e1       	ldi	r24, 0x1A	; 26
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	95 83       	std	Z+5, r25	; 0x05
     9a0:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     9a2:	8b e1       	ldi	r24, 0x1B	; 27
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	91 c0       	rjmp	.+290    	; 0xaca <getFinalDest+0x1a6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     9a8:	89 e1       	ldi	r24, 0x19	; 25
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	91 83       	std	Z+1, r25	; 0x01
     9ae:	80 83       	st	Z, r24
     9b0:	33 83       	std	Z+3, r19	; 0x03
     9b2:	22 83       	std	Z+2, r18	; 0x02
     9b4:	8c e1       	ldi	r24, 0x1C	; 28
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	95 83       	std	Z+5, r25	; 0x05
     9ba:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     9bc:	8d e1       	ldi	r24, 0x1D	; 29
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	97 83       	std	Z+7, r25	; 0x07
     9c2:	86 83       	std	Z+6, r24	; 0x06
     9c4:	8e e1       	ldi	r24, 0x1E	; 30
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	91 87       	std	Z+9, r25	; 0x09
     9ca:	80 87       	std	Z+8, r24	; 0x08
     9cc:	8f e1       	ldi	r24, 0x1F	; 31
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	69 c0       	rjmp	.+210    	; 0xaa4 <getFinalDest+0x180>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     9d2:	85 e0       	ldi	r24, 0x05	; 5
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	91 83       	std	Z+1, r25	; 0x01
     9d8:	80 83       	st	Z, r24
     9da:	8c e1       	ldi	r24, 0x1C	; 28
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	93 83       	std	Z+3, r25	; 0x03
     9e0:	82 83       	std	Z+2, r24	; 0x02
     9e2:	8d e1       	ldi	r24, 0x1D	; 29
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	95 83       	std	Z+5, r25	; 0x05
     9e8:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     9ea:	80 e2       	ldi	r24, 0x20	; 32
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	6d c0       	rjmp	.+218    	; 0xaca <getFinalDest+0x1a6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     9f0:	89 e0       	ldi	r24, 0x09	; 9
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	91 83       	std	Z+1, r25	; 0x01
     9f6:	80 83       	st	Z, r24
     9f8:	81 e2       	ldi	r24, 0x21	; 33
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	93 83       	std	Z+3, r25	; 0x03
     9fe:	82 83       	std	Z+2, r24	; 0x02
     a00:	82 e2       	ldi	r24, 0x22	; 34
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	95 83       	std	Z+5, r25	; 0x05
     a06:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     a08:	83 e2       	ldi	r24, 0x23	; 35
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	5e c0       	rjmp	.+188    	; 0xaca <getFinalDest+0x1a6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     a0e:	81 e2       	ldi	r24, 0x21	; 33
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	91 83       	std	Z+1, r25	; 0x01
     a14:	80 83       	st	Z, r24
     a16:	82 e2       	ldi	r24, 0x22	; 34
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	93 83       	std	Z+3, r25	; 0x03
     a1c:	82 83       	std	Z+2, r24	; 0x02
     a1e:	84 e2       	ldi	r24, 0x24	; 36
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	95 83       	std	Z+5, r25	; 0x05
     a24:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     a26:	85 e2       	ldi	r24, 0x25	; 37
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	97 83       	std	Z+7, r25	; 0x07
     a2c:	86 83       	std	Z+6, r24	; 0x06
     a2e:	86 e2       	ldi	r24, 0x26	; 38
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	91 87       	std	Z+9, r25	; 0x09
     a34:	80 87       	std	Z+8, r24	; 0x08
     a36:	87 e2       	ldi	r24, 0x27	; 39
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	34 c0       	rjmp	.+104    	; 0xaa4 <getFinalDest+0x180>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     a3c:	8d e0       	ldi	r24, 0x0D	; 13
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	91 83       	std	Z+1, r25	; 0x01
     a42:	80 83       	st	Z, r24
     a44:	84 e2       	ldi	r24, 0x24	; 36
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	93 83       	std	Z+3, r25	; 0x03
     a4a:	82 83       	std	Z+2, r24	; 0x02
     a4c:	85 e2       	ldi	r24, 0x25	; 37
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	95 83       	std	Z+5, r25	; 0x05
     a52:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     a54:	88 e2       	ldi	r24, 0x28	; 40
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	38 c0       	rjmp	.+112    	; 0xaca <getFinalDest+0x1a6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     a5a:	81 e1       	ldi	r24, 0x11	; 17
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	91 83       	std	Z+1, r25	; 0x01
     a60:	80 83       	st	Z, r24
     a62:	89 e2       	ldi	r24, 0x29	; 41
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	93 83       	std	Z+3, r25	; 0x03
     a68:	82 83       	std	Z+2, r24	; 0x02
     a6a:	8a e2       	ldi	r24, 0x2A	; 42
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	95 83       	std	Z+5, r25	; 0x05
     a70:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     a72:	8b e2       	ldi	r24, 0x2B	; 43
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	29 c0       	rjmp	.+82     	; 0xaca <getFinalDest+0x1a6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     a78:	89 e2       	ldi	r24, 0x29	; 41
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	91 83       	std	Z+1, r25	; 0x01
     a7e:	80 83       	st	Z, r24
     a80:	8a e2       	ldi	r24, 0x2A	; 42
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	93 83       	std	Z+3, r25	; 0x03
     a86:	82 83       	std	Z+2, r24	; 0x02
     a88:	8c e2       	ldi	r24, 0x2C	; 44
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	95 83       	std	Z+5, r25	; 0x05
     a8e:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     a90:	8d e2       	ldi	r24, 0x2D	; 45
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	97 83       	std	Z+7, r25	; 0x07
     a96:	86 83       	std	Z+6, r24	; 0x06
     a98:	8e e2       	ldi	r24, 0x2E	; 46
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	91 87       	std	Z+9, r25	; 0x09
     a9e:	80 87       	std	Z+8, r24	; 0x08
     aa0:	8f e2       	ldi	r24, 0x2F	; 47
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	93 87       	std	Z+11, r25	; 0x0b
     aa6:	82 87       	std	Z+10, r24	; 0x0a
     aa8:	26 e0       	ldi	r18, 0x06	; 6
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	16 c0       	rjmp	.+44     	; 0xada <getFinalDest+0x1b6>
* Example Call:		addToArr(finalDest[],1,2,3,4,5,6);
*/

void addToArr(int finalDest[], int a, int b, int c, int d, int e, int f) {
	//a,b,c,d,e,f are elements to be stored in finalDest array
	finalDest[0] = a; finalDest[1] = b; finalDest[2] = c;
     aae:	85 e1       	ldi	r24, 0x15	; 21
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	91 83       	std	Z+1, r25	; 0x01
     ab4:	80 83       	st	Z, r24
     ab6:	8c e2       	ldi	r24, 0x2C	; 44
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	93 83       	std	Z+3, r25	; 0x03
     abc:	82 83       	std	Z+2, r24	; 0x02
     abe:	8d e2       	ldi	r24, 0x2D	; 45
     ac0:	90 e0       	ldi	r25, 0x00	; 0
     ac2:	95 83       	std	Z+5, r25	; 0x05
     ac4:	84 83       	std	Z+4, r24	; 0x04
	finalDest[3] = d; finalDest[4] = e; finalDest[5] = f;
     ac6:	80 e3       	ldi	r24, 0x30	; 48
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	97 83       	std	Z+7, r25	; 0x07
     acc:	86 83       	std	Z+6, r24	; 0x06
     ace:	11 86       	std	Z+9, r1	; 0x09
     ad0:	10 86       	std	Z+8, r1	; 0x08
     ad2:	13 86       	std	Z+11, r1	; 0x0b
     ad4:	12 86       	std	Z+10, r1	; 0x0a
     ad6:	24 e0       	ldi	r18, 0x04	; 4
     ad8:	30 e0       	ldi	r19, 0x00	; 0
			case 32: addToArr(finalDest,41,42,44,45,46,47); return 6;
			case 33: addToArr(finalDest,21,44,45,48,0,0); return 4;
		}
	}
	return 0;
}
     ada:	c9 01       	movw	r24, r18
     adc:	08 95       	ret

00000ade <getOtherSide>:
* Output:			Other side of edge's vertice number will be returned
* Logic:			Take the edge, if the one end is same as given vertice, return other vertice, else return current vertice
* Example Call:		getOtherSide(1,1);
*/

int getOtherSide(int tempE, int tempG) {
     ade:	ac 01       	movw	r20, r24
	if (edgeList[tempE].endA != tempG) return edgeList[tempE].endA;
     ae0:	fc 01       	movw	r30, r24
     ae2:	b3 e0       	ldi	r27, 0x03	; 3
     ae4:	ee 0f       	add	r30, r30
     ae6:	ff 1f       	adc	r31, r31
     ae8:	ba 95       	dec	r27
     aea:	e1 f7       	brne	.-8      	; 0xae4 <getOtherSide+0x6>
     aec:	88 0f       	add	r24, r24
     aee:	99 1f       	adc	r25, r25
     af0:	e8 0f       	add	r30, r24
     af2:	f9 1f       	adc	r31, r25
     af4:	e3 5c       	subi	r30, 0xC3	; 195
     af6:	f9 4f       	sbci	r31, 0xF9	; 249
     af8:	24 81       	ldd	r18, Z+4	; 0x04
     afa:	35 81       	ldd	r19, Z+5	; 0x05
     afc:	26 17       	cp	r18, r22
     afe:	37 07       	cpc	r19, r23
     b00:	79 f4       	brne	.+30     	; 0xb20 <getOtherSide+0x42>
	return edgeList[tempE].endB;
     b02:	ca 01       	movw	r24, r20
     b04:	fa 01       	movw	r30, r20
     b06:	53 e0       	ldi	r21, 0x03	; 3
     b08:	ee 0f       	add	r30, r30
     b0a:	ff 1f       	adc	r31, r31
     b0c:	5a 95       	dec	r21
     b0e:	e1 f7       	brne	.-8      	; 0xb08 <getOtherSide+0x2a>
     b10:	88 0f       	add	r24, r24
     b12:	99 1f       	adc	r25, r25
     b14:	e8 0f       	add	r30, r24
     b16:	f9 1f       	adc	r31, r25
     b18:	e3 5c       	subi	r30, 0xC3	; 195
     b1a:	f9 4f       	sbci	r31, 0xF9	; 249
     b1c:	26 81       	ldd	r18, Z+6	; 0x06
     b1e:	37 81       	ldd	r19, Z+7	; 0x07
}
     b20:	c9 01       	movw	r24, r18
     b22:	08 95       	ret

00000b24 <dequeue>:
* Output:			Element will be dequeued from the queue
* Logic:			Normal dequeue logic
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
     b24:	9a 01       	movw	r18, r20
     b26:	fa 01       	movw	r30, r20
     b28:	31 96       	adiw	r30, 0x01	; 1
     b2a:	ee 0f       	add	r30, r30
     b2c:	ff 1f       	adc	r31, r31
     b2e:	e8 0f       	add	r30, r24
     b30:	f9 1f       	adc	r31, r25
     b32:	d9 01       	movw	r26, r18
     b34:	aa 0f       	add	r26, r26
     b36:	bb 1f       	adc	r27, r27
     b38:	a8 0f       	add	r26, r24
     b3a:	b9 1f       	adc	r27, r25
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     b3c:	61 50       	subi	r22, 0x01	; 1
     b3e:	70 40       	sbci	r23, 0x00	; 0
     b40:	06 c0       	rjmp	.+12     	; 0xb4e <dequeue+0x2a>
		q[i] = q[i+1];
     b42:	81 91       	ld	r24, Z+
     b44:	91 91       	ld	r25, Z+
     b46:	8d 93       	st	X+, r24
     b48:	9d 93       	st	X+, r25
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     b4a:	2f 5f       	subi	r18, 0xFF	; 255
     b4c:	3f 4f       	sbci	r19, 0xFF	; 255
     b4e:	26 17       	cp	r18, r22
     b50:	37 07       	cpc	r19, r23
     b52:	bc f3       	brlt	.-18     	; 0xb42 <dequeue+0x1e>
		q[i] = q[i+1];
	}
}
     b54:	08 95       	ret

00000b56 <enqueue>:
* Output:			Element will be enqueued to the queue
* Logic:			Normal enqueue logic
* Example Call:		enqueue(q,5,3,23);
*/

void enqueue(int q[],int qLen,int n,int x) { // n -> position to enqueue, x -> element to enqueue
     b56:	cf 93       	push	r28
     b58:	df 93       	push	r29
     b5a:	ec 01       	movw	r28, r24
     b5c:	fb 01       	movw	r30, r22
     b5e:	31 97       	sbiw	r30, 0x01	; 1
     b60:	ee 0f       	add	r30, r30
     b62:	ff 1f       	adc	r31, r31
     b64:	ec 0f       	add	r30, r28
     b66:	fd 1f       	adc	r31, r29
     b68:	db 01       	movw	r26, r22
     b6a:	aa 0f       	add	r26, r26
     b6c:	bb 1f       	adc	r27, r27
     b6e:	ac 0f       	add	r26, r28
     b70:	bd 1f       	adc	r27, r29
     b72:	07 c0       	rjmp	.+14     	; 0xb82 <enqueue+0x2c>
	int i; //for iteration
	for (i = qLen-1; i >= n; i--) {
		q[i+1] = q[i];
     b74:	80 81       	ld	r24, Z
     b76:	91 81       	ldd	r25, Z+1	; 0x01
     b78:	11 96       	adiw	r26, 0x01	; 1
     b7a:	9c 93       	st	X, r25
     b7c:	8e 93       	st	-X, r24
     b7e:	32 97       	sbiw	r30, 0x02	; 2
     b80:	12 97       	sbiw	r26, 0x02	; 2
     b82:	61 50       	subi	r22, 0x01	; 1
     b84:	70 40       	sbci	r23, 0x00	; 0
* Example Call:		enqueue(q,5,3,23);
*/

void enqueue(int q[],int qLen,int n,int x) { // n -> position to enqueue, x -> element to enqueue
	int i; //for iteration
	for (i = qLen-1; i >= n; i--) {
     b86:	64 17       	cp	r22, r20
     b88:	75 07       	cpc	r23, r21
     b8a:	a4 f7       	brge	.-24     	; 0xb74 <enqueue+0x1e>
		q[i+1] = q[i];
	}
	q[n] = x;
     b8c:	44 0f       	add	r20, r20
     b8e:	55 1f       	adc	r21, r21
     b90:	c4 0f       	add	r28, r20
     b92:	d5 1f       	adc	r29, r21
     b94:	39 83       	std	Y+1, r19	; 0x01
     b96:	28 83       	st	Y, r18
}
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	08 95       	ret

00000b9e <addObstacle>:
* Example Call:		addObstacle(1,24);
*/

void addObstacle(int a, int b) { //vertice numbers, the edge between whose is an obstacle
	int i; //for iteration
	a--; b--;
     b9e:	ac 01       	movw	r20, r24
     ba0:	41 50       	subi	r20, 0x01	; 1
     ba2:	50 40       	sbci	r21, 0x00	; 0
     ba4:	61 50       	subi	r22, 0x01	; 1
     ba6:	70 40       	sbci	r23, 0x00	; 0
     ba8:	ed e3       	ldi	r30, 0x3D	; 61
     baa:	f6 e0       	ldi	r31, 0x06	; 6
	for (i = 0; i < 63; i++) {
		if ((edgeList[i].endA==a && edgeList[i].endB==b) || (edgeList[i].endA==b && edgeList[i].endB==a))
			edgeList[i].obstacle = 1;
     bac:	a1 e0       	ldi	r26, 0x01	; 1
     bae:	b0 e0       	ldi	r27, 0x00	; 0

void addObstacle(int a, int b) { //vertice numbers, the edge between whose is an obstacle
	int i; //for iteration
	a--; b--;
	for (i = 0; i < 63; i++) {
		if ((edgeList[i].endA==a && edgeList[i].endB==b) || (edgeList[i].endA==b && edgeList[i].endB==a))
     bb0:	24 81       	ldd	r18, Z+4	; 0x04
     bb2:	35 81       	ldd	r19, Z+5	; 0x05
     bb4:	24 17       	cp	r18, r20
     bb6:	35 07       	cpc	r19, r21
     bb8:	29 f4       	brne	.+10     	; 0xbc4 <addObstacle+0x26>
     bba:	86 81       	ldd	r24, Z+6	; 0x06
     bbc:	97 81       	ldd	r25, Z+7	; 0x07
     bbe:	86 17       	cp	r24, r22
     bc0:	97 07       	cpc	r25, r23
     bc2:	41 f0       	breq	.+16     	; 0xbd4 <addObstacle+0x36>
     bc4:	26 17       	cp	r18, r22
     bc6:	37 07       	cpc	r19, r23
     bc8:	39 f4       	brne	.+14     	; 0xbd8 <addObstacle+0x3a>
     bca:	86 81       	ldd	r24, Z+6	; 0x06
     bcc:	97 81       	ldd	r25, Z+7	; 0x07
     bce:	84 17       	cp	r24, r20
     bd0:	95 07       	cpc	r25, r21
     bd2:	11 f4       	brne	.+4      	; 0xbd8 <addObstacle+0x3a>
			edgeList[i].obstacle = 1;
     bd4:	b1 83       	std	Z+1, r27	; 0x01
     bd6:	a0 83       	st	Z, r26
     bd8:	3a 96       	adiw	r30, 0x0a	; 10
*/

void addObstacle(int a, int b) { //vertice numbers, the edge between whose is an obstacle
	int i; //for iteration
	a--; b--;
	for (i = 0; i < 63; i++) {
     bda:	88 e0       	ldi	r24, 0x08	; 8
     bdc:	e3 3b       	cpi	r30, 0xB3	; 179
     bde:	f8 07       	cpc	r31, r24
     be0:	39 f7       	brne	.-50     	; 0xbb0 <addObstacle+0x12>
		if ((edgeList[i].endA==a && edgeList[i].endB==b) || (edgeList[i].endA==b && edgeList[i].endB==a))
			edgeList[i].obstacle = 1;
	}
}
     be2:	08 95       	ret

00000be4 <init_graph>:
*					Each vertice is assigned their x,y coordinates
*					Each edge is assigned their end vertices, presence of obstacles (initially 0 for all edges) and distance
* Example Call:		init_graph();
*/

void init_graph() {
     be4:	8f 92       	push	r8
     be6:	9f 92       	push	r9
     be8:	af 92       	push	r10
     bea:	bf 92       	push	r11
     bec:	cf 92       	push	r12
     bee:	df 92       	push	r13
     bf0:	ef 92       	push	r14
     bf2:	ff 92       	push	r15
     bf4:	0f 93       	push	r16
     bf6:	1f 93       	push	r17
     bf8:	df 93       	push	r29
     bfa:	cf 93       	push	r28
     bfc:	cd b7       	in	r28, 0x3d	; 61
     bfe:	de b7       	in	r29, 0x3e	; 62
     c00:	cc 5b       	subi	r28, 0xBC	; 188
     c02:	d2 40       	sbci	r29, 0x02	; 2
     c04:	0f b6       	in	r0, 0x3f	; 63
     c06:	f8 94       	cli
     c08:	de bf       	out	0x3e, r29	; 62
     c0a:	0f be       	out	0x3f, r0	; 63
     c0c:	cd bf       	out	0x3d, r28	; 61
	//verticeXY -> XY coordinates of all vertices
	//edgeEnds -> The end points of every edge
	//edgeAngles -> The angle with x-axis of each edge
	//edgeDist -> The distance of the edge
	//i -> for iteration
	int verticeXY[98] = {57,275,63,219,84,169,117,121,164,89,216,65,271,59,328,63,381,88,426,125,463,168,480,221,489,276,480,330,458,384,425,425,381,458,328,484,273,489,214,485,161,461,116,428,83,382,63,333,116,223,146,278,114,329,147,167,209,167,241,217,206,272,240,112,397,164,333,166,302,115,429,225,397,277,336,276,304,223,430,329,305,439,334,382,398,386,241,437,214,382,240,333,302,328,145,382,271,275},
     c0e:	de 01       	movw	r26, r28
     c10:	a3 50       	subi	r26, 0x03	; 3
     c12:	bf 4f       	sbci	r27, 0xFF	; 255
     c14:	ec e0       	ldi	r30, 0x0C	; 12
     c16:	f4 e0       	ldi	r31, 0x04	; 4
     c18:	84 ec       	ldi	r24, 0xC4	; 196
     c1a:	01 90       	ld	r0, Z+
     c1c:	0d 92       	st	X+, r0
     c1e:	81 50       	subi	r24, 0x01	; 1
     c20:	e1 f7       	brne	.-8      	; 0xc1a <init_graph+0x36>
	edgeEnds[126] = {1,2,1,24,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,3,25,25,26,26,27,27,23,25,28,28,29,29,30,30,31,31,26,3,28,32,7,32,29,7,35,35,34,34,33,33,11,33,36,36,37,37,38,38,39,39,34,11,36,37,40,40,15,43,15,43,42,41,42,41,19,42,47,47,46,46,45,45,44,44,41,19,44,45,48,48,23,26,45,29,34,37,42},
     c22:	de 01       	movw	r26, r28
     c24:	af 53       	subi	r26, 0x3F	; 63
     c26:	be 4f       	sbci	r27, 0xFE	; 254
     c28:	e0 e1       	ldi	r30, 0x10	; 16
     c2a:	f3 e0       	ldi	r31, 0x03	; 3
     c2c:	8c ef       	ldi	r24, 0xFC	; 252
     c2e:	01 90       	ld	r0, Z+
     c30:	0d 92       	st	X+, r0
     c32:	81 50       	subi	r24, 0x01	; 1
     c34:	e1 f7       	brne	.-8      	; 0xc2e <init_graph+0x4a>
	edgeAngles[63] = {82,-82,67,52,37,22,7,-7,-22,-37,-52,-67,-82,-97,-112,-127,-142,-157,-172,172,157,142,127,112,-60,-60,-120,-120,60,0,-60,-120,180,0,60,-120,-60,-60,0,0,-60,-120,180,120,60,-120,-60,-60,0,180,60,-120,120,180,-120,-60,0,120,180,180,-60,0,-120},
     c36:	de 01       	movw	r26, r28
     c38:	11 96       	adiw	r26, 0x01	; 1
     c3a:	e2 e9       	ldi	r30, 0x92	; 146
     c3c:	f2 e0       	ldi	r31, 0x02	; 2
     c3e:	8e e7       	ldi	r24, 0x7E	; 126
     c40:	01 90       	ld	r0, Z+
     c42:	0d 92       	st	X+, r0
     c44:	81 50       	subi	r24, 0x01	; 1
     c46:	e1 f7       	brne	.-8      	; 0xc40 <init_graph+0x5c>
	edgeDist[63] = {20,21,19,21,20,20,20,20,21,21,20,20,20,19,21,18,20,21,20,21,21,20,20,18,22,21,21,22,21,21,21,23,21,23,22,23,23,21,23,24,24,22,22,22,23,24,22,22,21,23,23,21,22,22,20,22,23,22,25,22,45,45,44},
     c48:	de 01       	movw	r26, r28
     c4a:	a1 58       	subi	r26, 0x81	; 129
     c4c:	bf 4f       	sbci	r27, 0xFF	; 255
     c4e:	e4 e1       	ldi	r30, 0x14	; 20
     c50:	f2 e0       	ldi	r31, 0x02	; 2
     c52:	8e e7       	ldi	r24, 0x7E	; 126
     c54:	01 90       	ld	r0, Z+
     c56:	0d 92       	st	X+, r0
     c58:	81 50       	subi	r24, 0x01	; 1
     c5a:	e1 f7       	brne	.-8      	; 0xc54 <init_graph+0x70>
     c5c:	e2 ec       	ldi	r30, 0xC2	; 194
     c5e:	f8 e0       	ldi	r31, 0x08	; 8
     c60:	de 01       	movw	r26, r28
     c62:	a3 50       	subi	r26, 0x03	; 3
     c64:	bf 4f       	sbci	r27, 0xFF	; 255
     c66:	20 e0       	ldi	r18, 0x00	; 0
     c68:	30 e0       	ldi	r19, 0x00	; 0
	i;
	for (i = 0; i < 49; i++) { //Vertice Initialization
		verticeList[i].n = i;
     c6a:	31 83       	std	Z+1, r19	; 0x01
     c6c:	20 83       	st	Z, r18
		verticeList[i].x = verticeXY[2*i];
     c6e:	8d 91       	ld	r24, X+
     c70:	9c 91       	ld	r25, X
     c72:	11 97       	sbiw	r26, 0x01	; 1
     c74:	93 83       	std	Z+3, r25	; 0x03
     c76:	82 83       	std	Z+2, r24	; 0x02
		verticeList[i].y = verticeXY[2*i+1];
     c78:	12 96       	adiw	r26, 0x02	; 2
     c7a:	8d 91       	ld	r24, X+
     c7c:	9c 91       	ld	r25, X
     c7e:	13 97       	sbiw	r26, 0x03	; 3
     c80:	95 83       	std	Z+5, r25	; 0x05
     c82:	84 83       	std	Z+4, r24	; 0x04
		verticeList[i].edgeCount = 0;
     c84:	17 82       	std	Z+7, r1	; 0x07
     c86:	16 82       	std	Z+6, r1	; 0x06
	int verticeXY[98] = {57,275,63,219,84,169,117,121,164,89,216,65,271,59,328,63,381,88,426,125,463,168,480,221,489,276,480,330,458,384,425,425,381,458,328,484,273,489,214,485,161,461,116,428,83,382,63,333,116,223,146,278,114,329,147,167,209,167,241,217,206,272,240,112,397,164,333,166,302,115,429,225,397,277,336,276,304,223,430,329,305,439,334,382,398,386,241,437,214,382,240,333,302,328,145,382,271,275},
	edgeEnds[126] = {1,2,1,24,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,3,25,25,26,26,27,27,23,25,28,28,29,29,30,30,31,31,26,3,28,32,7,32,29,7,35,35,34,34,33,33,11,33,36,36,37,37,38,38,39,39,34,11,36,37,40,40,15,43,15,43,42,41,42,41,19,42,47,47,46,46,45,45,44,44,41,19,44,45,48,48,23,26,45,29,34,37,42},
	edgeAngles[63] = {82,-82,67,52,37,22,7,-7,-22,-37,-52,-67,-82,-97,-112,-127,-142,-157,-172,172,157,142,127,112,-60,-60,-120,-120,60,0,-60,-120,180,0,60,-120,-60,-60,0,0,-60,-120,180,120,60,-120,-60,-60,0,180,60,-120,120,180,-120,-60,0,120,180,180,-60,0,-120},
	edgeDist[63] = {20,21,19,21,20,20,20,20,21,21,20,20,20,19,21,18,20,21,20,21,21,20,20,18,22,21,21,22,21,21,21,23,21,23,22,23,23,21,23,24,24,22,22,22,23,24,22,22,21,23,23,21,22,22,20,22,23,22,25,22,45,45,44},
	i;
	for (i = 0; i < 49; i++) { //Vertice Initialization
     c88:	2f 5f       	subi	r18, 0xFF	; 255
     c8a:	3f 4f       	sbci	r19, 0xFF	; 255
     c8c:	74 96       	adiw	r30, 0x14	; 20
     c8e:	14 96       	adiw	r26, 0x04	; 4
     c90:	21 33       	cpi	r18, 0x31	; 49
     c92:	31 05       	cpc	r19, r1
     c94:	51 f7       	brne	.-44     	; 0xc6a <init_graph+0x86>
     c96:	6d e3       	ldi	r22, 0x3D	; 61
     c98:	76 e0       	ldi	r23, 0x06	; 6
     c9a:	5e 01       	movw	r10, r28
     c9c:	08 94       	sec
     c9e:	a1 1c       	adc	r10, r1
     ca0:	b1 1c       	adc	r11, r1
     ca2:	21 ec       	ldi	r18, 0xC1	; 193
     ca4:	e2 2e       	mov	r14, r18
     ca6:	21 e0       	ldi	r18, 0x01	; 1
     ca8:	f2 2e       	mov	r15, r18
     caa:	ec 0e       	add	r14, r28
     cac:	fd 1e       	adc	r15, r29
     cae:	9f e7       	ldi	r25, 0x7F	; 127
     cb0:	c9 2e       	mov	r12, r25
     cb2:	d1 2c       	mov	r13, r1
     cb4:	cc 0e       	add	r12, r28
     cb6:	dd 1e       	adc	r13, r29
     cb8:	00 e0       	ldi	r16, 0x00	; 0
     cba:	10 e0       	ldi	r17, 0x00	; 0
		edgeList[i].obstacle = 0;
		edgeList[i].angle = edgeAngles[i];
		edgeList[i].endA = edgeEnds[2*i]-1;
		edgeList[i].endB = edgeEnds[2*i+1]-1;
		edgeList[i].distance = edgeDist[i];
		verticeList[edgeList[i].endA].edgePoints[(verticeList[edgeList[i].endA].edgeCount)++] = i;
     cbc:	84 e1       	ldi	r24, 0x14	; 20
     cbe:	88 2e       	mov	r8, r24
     cc0:	91 2c       	mov	r9, r1
		verticeList[i].x = verticeXY[2*i];
		verticeList[i].y = verticeXY[2*i+1];
		verticeList[i].edgeCount = 0;
	}
	for (i = 0; i < 63; i++) { //Edge Initialization
		edgeList[i].obstacle = 0;
     cc2:	fb 01       	movw	r30, r22
     cc4:	11 82       	std	Z+1, r1	; 0x01
     cc6:	10 82       	st	Z, r1
		edgeList[i].angle = edgeAngles[i];
     cc8:	f5 01       	movw	r30, r10
     cca:	81 91       	ld	r24, Z+
     ccc:	91 91       	ld	r25, Z+
     cce:	5f 01       	movw	r10, r30
     cd0:	fb 01       	movw	r30, r22
     cd2:	93 83       	std	Z+3, r25	; 0x03
     cd4:	82 83       	std	Z+2, r24	; 0x02
		edgeList[i].endA = edgeEnds[2*i]-1;
     cd6:	f7 01       	movw	r30, r14
     cd8:	80 81       	ld	r24, Z
     cda:	91 81       	ldd	r25, Z+1	; 0x01
     cdc:	01 97       	sbiw	r24, 0x01	; 1
     cde:	fb 01       	movw	r30, r22
     ce0:	95 83       	std	Z+5, r25	; 0x05
     ce2:	84 83       	std	Z+4, r24	; 0x04
		edgeList[i].endB = edgeEnds[2*i+1]-1;
     ce4:	f7 01       	movw	r30, r14
     ce6:	42 81       	ldd	r20, Z+2	; 0x02
     ce8:	53 81       	ldd	r21, Z+3	; 0x03
     cea:	41 50       	subi	r20, 0x01	; 1
     cec:	50 40       	sbci	r21, 0x00	; 0
     cee:	fb 01       	movw	r30, r22
     cf0:	57 83       	std	Z+7, r21	; 0x07
     cf2:	46 83       	std	Z+6, r20	; 0x06
		edgeList[i].distance = edgeDist[i];
     cf4:	f6 01       	movw	r30, r12
     cf6:	21 91       	ld	r18, Z+
     cf8:	31 91       	ld	r19, Z+
     cfa:	6f 01       	movw	r12, r30
     cfc:	fb 01       	movw	r30, r22
     cfe:	31 87       	std	Z+9, r19	; 0x09
     d00:	20 87       	std	Z+8, r18	; 0x08
		verticeList[edgeList[i].endA].edgePoints[(verticeList[edgeList[i].endA].edgeCount)++] = i;
     d02:	88 9d       	mul	r24, r8
     d04:	d0 01       	movw	r26, r0
     d06:	89 9d       	mul	r24, r9
     d08:	b0 0d       	add	r27, r0
     d0a:	98 9d       	mul	r25, r8
     d0c:	b0 0d       	add	r27, r0
     d0e:	11 24       	eor	r1, r1
     d10:	ae 53       	subi	r26, 0x3E	; 62
     d12:	b7 4f       	sbci	r27, 0xF7	; 247
     d14:	16 96       	adiw	r26, 0x06	; 6
     d16:	2d 91       	ld	r18, X+
     d18:	3c 91       	ld	r19, X
     d1a:	17 97       	sbiw	r26, 0x07	; 7
     d1c:	fc 01       	movw	r30, r24
     d1e:	ee 0f       	add	r30, r30
     d20:	ff 1f       	adc	r31, r31
     d22:	ee 0f       	add	r30, r30
     d24:	ff 1f       	adc	r31, r31
     d26:	ee 0f       	add	r30, r30
     d28:	ff 1f       	adc	r31, r31
     d2a:	88 0f       	add	r24, r24
     d2c:	99 1f       	adc	r25, r25
     d2e:	e8 0f       	add	r30, r24
     d30:	f9 1f       	adc	r31, r25
     d32:	e2 0f       	add	r30, r18
     d34:	f3 1f       	adc	r31, r19
     d36:	ee 0f       	add	r30, r30
     d38:	ff 1f       	adc	r31, r31
     d3a:	ee 53       	subi	r30, 0x3E	; 62
     d3c:	f7 4f       	sbci	r31, 0xF7	; 247
     d3e:	11 87       	std	Z+9, r17	; 0x09
     d40:	00 87       	std	Z+8, r16	; 0x08
     d42:	2f 5f       	subi	r18, 0xFF	; 255
     d44:	3f 4f       	sbci	r19, 0xFF	; 255
     d46:	17 96       	adiw	r26, 0x07	; 7
     d48:	3c 93       	st	X, r19
     d4a:	2e 93       	st	-X, r18
     d4c:	16 97       	sbiw	r26, 0x06	; 6
		verticeList[edgeList[i].endB].edgePoints[(verticeList[edgeList[i].endB].edgeCount)++] = i;
     d4e:	48 9d       	mul	r20, r8
     d50:	d0 01       	movw	r26, r0
     d52:	49 9d       	mul	r20, r9
     d54:	b0 0d       	add	r27, r0
     d56:	58 9d       	mul	r21, r8
     d58:	b0 0d       	add	r27, r0
     d5a:	11 24       	eor	r1, r1
     d5c:	ae 53       	subi	r26, 0x3E	; 62
     d5e:	b7 4f       	sbci	r27, 0xF7	; 247
     d60:	16 96       	adiw	r26, 0x06	; 6
     d62:	8d 91       	ld	r24, X+
     d64:	9c 91       	ld	r25, X
     d66:	17 97       	sbiw	r26, 0x07	; 7
     d68:	fa 01       	movw	r30, r20
     d6a:	23 e0       	ldi	r18, 0x03	; 3
     d6c:	ee 0f       	add	r30, r30
     d6e:	ff 1f       	adc	r31, r31
     d70:	2a 95       	dec	r18
     d72:	e1 f7       	brne	.-8      	; 0xd6c <init_graph+0x188>
     d74:	44 0f       	add	r20, r20
     d76:	55 1f       	adc	r21, r21
     d78:	e4 0f       	add	r30, r20
     d7a:	f5 1f       	adc	r31, r21
     d7c:	e8 0f       	add	r30, r24
     d7e:	f9 1f       	adc	r31, r25
     d80:	ee 0f       	add	r30, r30
     d82:	ff 1f       	adc	r31, r31
     d84:	ee 53       	subi	r30, 0x3E	; 62
     d86:	f7 4f       	sbci	r31, 0xF7	; 247
     d88:	11 87       	std	Z+9, r17	; 0x09
     d8a:	00 87       	std	Z+8, r16	; 0x08
     d8c:	01 96       	adiw	r24, 0x01	; 1
     d8e:	17 96       	adiw	r26, 0x07	; 7
     d90:	9c 93       	st	X, r25
     d92:	8e 93       	st	-X, r24
     d94:	16 97       	sbiw	r26, 0x06	; 6
		verticeList[i].n = i;
		verticeList[i].x = verticeXY[2*i];
		verticeList[i].y = verticeXY[2*i+1];
		verticeList[i].edgeCount = 0;
	}
	for (i = 0; i < 63; i++) { //Edge Initialization
     d96:	0f 5f       	subi	r16, 0xFF	; 255
     d98:	1f 4f       	sbci	r17, 0xFF	; 255
     d9a:	66 5f       	subi	r22, 0xF6	; 246
     d9c:	7f 4f       	sbci	r23, 0xFF	; 255
     d9e:	84 e0       	ldi	r24, 0x04	; 4
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	e8 0e       	add	r14, r24
     da4:	f9 1e       	adc	r15, r25
     da6:	0f 33       	cpi	r16, 0x3F	; 63
     da8:	11 05       	cpc	r17, r1
     daa:	09 f0       	breq	.+2      	; 0xdae <init_graph+0x1ca>
     dac:	8a cf       	rjmp	.-236    	; 0xcc2 <init_graph+0xde>
		edgeList[i].endB = edgeEnds[2*i+1]-1;
		edgeList[i].distance = edgeDist[i];
		verticeList[edgeList[i].endA].edgePoints[(verticeList[edgeList[i].endA].edgeCount)++] = i;
		verticeList[edgeList[i].endB].edgePoints[(verticeList[edgeList[i].endB].edgeCount)++] = i;
	}
}
     dae:	c4 54       	subi	r28, 0x44	; 68
     db0:	dd 4f       	sbci	r29, 0xFD	; 253
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	de bf       	out	0x3e, r29	; 62
     db8:	0f be       	out	0x3f, r0	; 63
     dba:	cd bf       	out	0x3d, r28	; 61
     dbc:	cf 91       	pop	r28
     dbe:	df 91       	pop	r29
     dc0:	1f 91       	pop	r17
     dc2:	0f 91       	pop	r16
     dc4:	ff 90       	pop	r15
     dc6:	ef 90       	pop	r14
     dc8:	df 90       	pop	r13
     dca:	cf 90       	pop	r12
     dcc:	bf 90       	pop	r11
     dce:	af 90       	pop	r10
     dd0:	9f 90       	pop	r9
     dd2:	8f 90       	pop	r8
     dd4:	08 95       	ret

00000dd6 <mainFun>:
* Output:			It will store the shortest path from src to dest in global array path
* Logic:			Breadth First Search Algorithm is used to find the shortest distance
* Example Call:		mainFun(1,28,0);
*/

void mainFun(int src,int dest,int compass) {
     dd6:	2f 92       	push	r2
     dd8:	3f 92       	push	r3
     dda:	4f 92       	push	r4
     ddc:	5f 92       	push	r5
     dde:	6f 92       	push	r6
     de0:	7f 92       	push	r7
     de2:	8f 92       	push	r8
     de4:	9f 92       	push	r9
     de6:	af 92       	push	r10
     de8:	bf 92       	push	r11
     dea:	cf 92       	push	r12
     dec:	df 92       	push	r13
     dee:	ef 92       	push	r14
     df0:	ff 92       	push	r15
     df2:	0f 93       	push	r16
     df4:	1f 93       	push	r17
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	cd b7       	in	r28, 0x3d	; 61
     dfc:	de b7       	in	r29, 0x3e	; 62
     dfe:	c0 55       	subi	r28, 0x50	; 80
     e00:	d1 40       	sbci	r29, 0x01	; 1
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	f8 94       	cli
     e06:	de bf       	out	0x3e, r29	; 62
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	cd bf       	out	0x3d, r28	; 61
     e0c:	c3 5b       	subi	r28, 0xB3	; 179
     e0e:	de 4f       	sbci	r29, 0xFE	; 254
     e10:	99 83       	std	Y+1, r25	; 0x01
     e12:	88 83       	st	Y, r24
     e14:	cd 54       	subi	r28, 0x4D	; 77
     e16:	d1 40       	sbci	r29, 0x01	; 1
     e18:	cb 01       	movw	r24, r22
     e1a:	c1 5b       	subi	r28, 0xB1	; 177
     e1c:	de 4f       	sbci	r29, 0xFE	; 254
     e1e:	59 83       	std	Y+1, r21	; 0x01
     e20:	48 83       	st	Y, r20
     e22:	cf 54       	subi	r28, 0x4F	; 79
     e24:	d1 40       	sbci	r29, 0x01	; 1
	int i, j, x, y, z = -1, finalDest[6], finalDestCount, prevPts[49], dist[49], q[50], qLen;
	//q[] for queue and qLen for queue length
	//x, y, z are temporary variables which have multiple functions
	//i & j for iteration
	struct vertice tempV; //used for temporary vertice
	finalDestCount = getFinalDest(dest,finalDest);
     e26:	be 01       	movw	r22, r28
     e28:	6f 5f       	subi	r22, 0xFF	; 255
     e2a:	7f 4f       	sbci	r23, 0xFF	; 255
     e2c:	0e 94 92 04 	call	0x924	; 0x924 <getFinalDest>
     e30:	c7 5b       	subi	r28, 0xB7	; 183
     e32:	de 4f       	sbci	r29, 0xFE	; 254
     e34:	99 83       	std	Y+1, r25	; 0x01
     e36:	88 83       	st	Y, r24
     e38:	c9 54       	subi	r28, 0x49	; 73
     e3a:	d1 40       	sbci	r29, 0x01	; 1
     e3c:	fe 01       	movw	r30, r28
     e3e:	b1 96       	adiw	r30, 0x21	; 33
	for (i = 0; i < 49; i++) prevPts[i] = -1;
     e40:	2f ef       	ldi	r18, 0xFF	; 255
     e42:	3f ef       	ldi	r19, 0xFF	; 255
     e44:	ce 01       	movw	r24, r28
     e46:	8d 57       	subi	r24, 0x7D	; 125
     e48:	9f 4f       	sbci	r25, 0xFF	; 255
     e4a:	21 93       	st	Z+, r18
     e4c:	31 93       	st	Z+, r19
     e4e:	e8 17       	cp	r30, r24
     e50:	f9 07       	cpc	r31, r25
     e52:	d9 f7       	brne	.-10     	; 0xe4a <mainFun+0x74>
     e54:	df 01       	movw	r26, r30
	for (i = 0; i < 49; i++) dist[i] = 20000;
     e56:	20 e2       	ldi	r18, 0x20	; 32
     e58:	3e e4       	ldi	r19, 0x4E	; 78
     e5a:	af 01       	movw	r20, r30
     e5c:	ce 01       	movw	r24, r28
     e5e:	8b 51       	subi	r24, 0x1B	; 27
     e60:	9f 4f       	sbci	r25, 0xFF	; 255
     e62:	2d 93       	st	X+, r18
     e64:	3d 93       	st	X+, r19
     e66:	a8 17       	cp	r26, r24
     e68:	b9 07       	cpc	r27, r25
     e6a:	d9 f7       	brne	.-10     	; 0xe62 <mainFun+0x8c>
	dist[src - 1] = 0;
     e6c:	c3 5b       	subi	r28, 0xB3	; 179
     e6e:	de 4f       	sbci	r29, 0xFE	; 254
     e70:	88 81       	ld	r24, Y
     e72:	99 81       	ldd	r25, Y+1	; 0x01
     e74:	cd 54       	subi	r28, 0x4D	; 77
     e76:	d1 40       	sbci	r29, 0x01	; 1
     e78:	01 97       	sbiw	r24, 0x01	; 1
     e7a:	fc 01       	movw	r30, r24
     e7c:	ee 0f       	add	r30, r30
     e7e:	ff 1f       	adc	r31, r31
     e80:	e4 0f       	add	r30, r20
     e82:	f5 1f       	adc	r31, r21
     e84:	11 82       	std	Z+1, r1	; 0x01
     e86:	10 82       	st	Z, r1
	qLen = 1; q[0] = src - 1;
     e88:	8d 93       	st	X+, r24
     e8a:	9c 93       	st	X, r25
     e8c:	01 e0       	ldi	r16, 0x01	; 1
     e8e:	10 e0       	ldi	r17, 0x00	; 0
	while ( qLen>0 ) {
		for (i = 0; i < finalDestCount; i++)
			if (prevPts[finalDest[i]-1] != -1) {
				for (j = 0; j < qLen; j++) {
					if ( dist[q[j]] >= dist[finalDest[i]-1] ) {
     e90:	b3 e8       	ldi	r27, 0x83	; 131
     e92:	2b 2e       	mov	r2, r27
     e94:	31 2c       	mov	r3, r1
     e96:	2c 0e       	add	r2, r28
     e98:	3d 1e       	adc	r3, r29
     e9a:	a5 ee       	ldi	r26, 0xE5	; 229
     e9c:	4a 2e       	mov	r4, r26
     e9e:	51 2c       	mov	r5, r1
     ea0:	4c 0e       	add	r4, r28
     ea2:	5d 1e       	adc	r5, r29
     ea4:	57 c1       	rjmp	.+686    	; 0x1154 <mainFun+0x37e>
	for (i = 0; i < 49; i++) dist[i] = 20000;
	dist[src - 1] = 0;
	qLen = 1; q[0] = src - 1;
	while ( qLen>0 ) {
		for (i = 0; i < finalDestCount; i++)
			if (prevPts[finalDest[i]-1] != -1) {
     ea6:	d6 01       	movw	r26, r12
     ea8:	2d 91       	ld	r18, X+
     eaa:	3c 91       	ld	r19, X
     eac:	21 50       	subi	r18, 0x01	; 1
     eae:	30 40       	sbci	r19, 0x00	; 0
     eb0:	22 0f       	add	r18, r18
     eb2:	33 1f       	adc	r19, r19
     eb4:	e1 e0       	ldi	r30, 0x01	; 1
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	ec 0f       	add	r30, r28
     eba:	fd 1f       	adc	r31, r29
     ebc:	e2 0f       	add	r30, r18
     ebe:	f3 1f       	adc	r31, r19
     ec0:	80 a1       	ldd	r24, Z+32	; 0x20
     ec2:	91 a1       	ldd	r25, Z+33	; 0x21
     ec4:	8f 5f       	subi	r24, 0xFF	; 255
     ec6:	9f 4f       	sbci	r25, 0xFF	; 255
     ec8:	d1 f1       	breq	.+116    	; 0xf3e <mainFun+0x168>
     eca:	40 e0       	ldi	r20, 0x00	; 0
     ecc:	50 e0       	ldi	r21, 0x00	; 0
				for (j = 0; j < qLen; j++) {
					if ( dist[q[j]] >= dist[finalDest[i]-1] ) {
     ece:	51 01       	movw	r10, r2
     ed0:	a2 0e       	add	r10, r18
     ed2:	b3 1e       	adc	r11, r19
     ed4:	31 c0       	rjmp	.+98     	; 0xf38 <mainFun+0x162>
     ed6:	ba 01       	movw	r22, r20
     ed8:	66 0f       	add	r22, r22
     eda:	77 1f       	adc	r23, r23
     edc:	64 0d       	add	r22, r4
     ede:	75 1d       	adc	r23, r5
     ee0:	db 01       	movw	r26, r22
     ee2:	ed 91       	ld	r30, X+
     ee4:	fc 91       	ld	r31, X
     ee6:	ee 0f       	add	r30, r30
     ee8:	ff 1f       	adc	r31, r31
     eea:	e2 0d       	add	r30, r2
     eec:	f3 1d       	adc	r31, r3
     eee:	20 81       	ld	r18, Z
     ef0:	31 81       	ldd	r19, Z+1	; 0x01
     ef2:	f5 01       	movw	r30, r10
     ef4:	80 81       	ld	r24, Z
     ef6:	91 81       	ldd	r25, Z+1	; 0x01
     ef8:	28 17       	cp	r18, r24
     efa:	39 07       	cpc	r19, r25
     efc:	14 f4       	brge	.+4      	; 0xf02 <mainFun+0x12c>
     efe:	c8 01       	movw	r24, r16
     f00:	18 c0       	rjmp	.+48     	; 0xf32 <mainFun+0x15c>
* Output:			It will store the shortest path from src to dest in global array path
* Logic:			Breadth First Search Algorithm is used to find the shortest distance
* Example Call:		mainFun(1,28,0);
*/

void mainFun(int src,int dest,int compass) {
     f02:	da 01       	movw	r26, r20
     f04:	11 96       	adiw	r26, 0x01	; 1
     f06:	aa 0f       	add	r26, r26
     f08:	bb 1f       	adc	r27, r27
     f0a:	a4 0d       	add	r26, r4
     f0c:	b5 1d       	adc	r27, r5
     f0e:	fb 01       	movw	r30, r22
     f10:	9a 01       	movw	r18, r20
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     f12:	b8 01       	movw	r22, r16
     f14:	61 50       	subi	r22, 0x01	; 1
     f16:	70 40       	sbci	r23, 0x00	; 0
     f18:	06 c0       	rjmp	.+12     	; 0xf26 <mainFun+0x150>
		q[i] = q[i+1];
     f1a:	8d 91       	ld	r24, X+
     f1c:	9d 91       	ld	r25, X+
     f1e:	81 93       	st	Z+, r24
     f20:	91 93       	st	Z+, r25
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     f22:	2f 5f       	subi	r18, 0xFF	; 255
     f24:	3f 4f       	sbci	r19, 0xFF	; 255
     f26:	cb 01       	movw	r24, r22
     f28:	26 17       	cp	r18, r22
     f2a:	37 07       	cpc	r19, r23
     f2c:	b4 f3       	brlt	.-20     	; 0xf1a <mainFun+0x144>
	while ( qLen>0 ) {
		for (i = 0; i < finalDestCount; i++)
			if (prevPts[finalDest[i]-1] != -1) {
				for (j = 0; j < qLen; j++) {
					if ( dist[q[j]] >= dist[finalDest[i]-1] ) {
						dequeue(q,qLen,j); j--; qLen--;
     f2e:	41 50       	subi	r20, 0x01	; 1
     f30:	50 40       	sbci	r21, 0x00	; 0
	dist[src - 1] = 0;
	qLen = 1; q[0] = src - 1;
	while ( qLen>0 ) {
		for (i = 0; i < finalDestCount; i++)
			if (prevPts[finalDest[i]-1] != -1) {
				for (j = 0; j < qLen; j++) {
     f32:	4f 5f       	subi	r20, 0xFF	; 255
     f34:	5f 4f       	sbci	r21, 0xFF	; 255
     f36:	8c 01       	movw	r16, r24
     f38:	40 17       	cp	r20, r16
     f3a:	51 07       	cpc	r21, r17
     f3c:	64 f2       	brlt	.-104    	; 0xed6 <mainFun+0x100>
	for (i = 0; i < 49; i++) prevPts[i] = -1;
	for (i = 0; i < 49; i++) dist[i] = 20000;
	dist[src - 1] = 0;
	qLen = 1; q[0] = src - 1;
	while ( qLen>0 ) {
		for (i = 0; i < finalDestCount; i++)
     f3e:	08 94       	sec
     f40:	e1 1c       	adc	r14, r1
     f42:	f1 1c       	adc	r15, r1
     f44:	22 e0       	ldi	r18, 0x02	; 2
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	c2 0e       	add	r12, r18
     f4a:	d3 1e       	adc	r13, r19
     f4c:	c7 5b       	subi	r28, 0xB7	; 183
     f4e:	de 4f       	sbci	r29, 0xFE	; 254
     f50:	68 81       	ld	r22, Y
     f52:	79 81       	ldd	r23, Y+1	; 0x01
     f54:	c9 54       	subi	r28, 0x49	; 73
     f56:	d1 40       	sbci	r29, 0x01	; 1
     f58:	e6 16       	cp	r14, r22
     f5a:	f7 06       	cpc	r15, r23
     f5c:	0c f4       	brge	.+2      	; 0xf60 <mainFun+0x18a>
     f5e:	a3 cf       	rjmp	.-186    	; 0xea6 <mainFun+0xd0>
     f60:	40 e0       	ldi	r20, 0x00	; 0
     f62:	50 e0       	ldi	r21, 0x00	; 0
     f64:	e0 c0       	rjmp	.+448    	; 0x1126 <mainFun+0x350>
						dequeue(q,qLen,j); j--; qLen--;
					}
				}
			}
		for (i = 0; i < qLen; i++) {
			x = q[i];
     f66:	fa 01       	movw	r30, r20
     f68:	ee 0f       	add	r30, r30
     f6a:	ff 1f       	adc	r31, r31
     f6c:	e4 0d       	add	r30, r4
     f6e:	f5 1d       	adc	r31, r5
     f70:	a0 80       	ld	r10, Z
     f72:	b1 80       	ldd	r11, Z+1	; 0x01
* Output:			It will store the shortest path from src to dest in global array path
* Logic:			Breadth First Search Algorithm is used to find the shortest distance
* Example Call:		mainFun(1,28,0);
*/

void mainFun(int src,int dest,int compass) {
     f74:	da 01       	movw	r26, r20
     f76:	11 96       	adiw	r26, 0x01	; 1
     f78:	aa 0f       	add	r26, r26
     f7a:	bb 1f       	adc	r27, r27
     f7c:	a4 0d       	add	r26, r4
     f7e:	b5 1d       	adc	r27, r5
     f80:	9a 01       	movw	r18, r20
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     f82:	b8 01       	movw	r22, r16
     f84:	61 50       	subi	r22, 0x01	; 1
     f86:	70 40       	sbci	r23, 0x00	; 0
     f88:	06 c0       	rjmp	.+12     	; 0xf96 <mainFun+0x1c0>
		q[i] = q[i+1];
     f8a:	8d 91       	ld	r24, X+
     f8c:	9d 91       	ld	r25, X+
     f8e:	81 93       	st	Z+, r24
     f90:	91 93       	st	Z+, r25
* Example Call:		dequeue(q,5,3);
*/

void dequeue(int q[],int qLen,int n) { // n -> position to dequeue
	int i; //for iteration
	for (i = n; i < qLen-1; i++) {
     f92:	2f 5f       	subi	r18, 0xFF	; 255
     f94:	3f 4f       	sbci	r19, 0xFF	; 255
     f96:	26 17       	cp	r18, r22
     f98:	37 07       	cpc	r19, r23
     f9a:	bc f3       	brlt	.-18     	; 0xf8a <mainFun+0x1b4>
					}
				}
			}
		for (i = 0; i < qLen; i++) {
			x = q[i];
			dequeue(q,qLen,i); i--; qLen--;
     f9c:	7a 01       	movw	r14, r20
     f9e:	08 94       	sec
     fa0:	e1 08       	sbc	r14, r1
     fa2:	f1 08       	sbc	r15, r1
			for (j = 0; j < verticeList[x].edgeCount; j++) {
     fa4:	a4 e1       	ldi	r26, 0x14	; 20
     fa6:	b0 e0       	ldi	r27, 0x00	; 0
     fa8:	aa 9e       	mul	r10, r26
     faa:	c0 01       	movw	r24, r0
     fac:	ab 9e       	mul	r10, r27
     fae:	90 0d       	add	r25, r0
     fb0:	ba 9e       	mul	r11, r26
     fb2:	90 0d       	add	r25, r0
     fb4:	11 24       	eor	r1, r1
     fb6:	fc 01       	movw	r30, r24
     fb8:	ee 53       	subi	r30, 0x3E	; 62
     fba:	f7 4f       	sbci	r31, 0xF7	; 247
     fbc:	26 81       	ldd	r18, Z+6	; 0x06
     fbe:	37 81       	ldd	r19, Z+7	; 0x07
     fc0:	c5 5b       	subi	r28, 0xB5	; 181
     fc2:	de 4f       	sbci	r29, 0xFE	; 254
     fc4:	39 83       	std	Y+1, r19	; 0x01
     fc6:	28 83       	st	Y, r18
     fc8:	cb 54       	subi	r28, 0x4B	; 75
     fca:	d1 40       	sbci	r29, 0x01	; 1
     fcc:	ea ec       	ldi	r30, 0xCA	; 202
     fce:	ce 2e       	mov	r12, r30
     fd0:	e8 e0       	ldi	r30, 0x08	; 8
     fd2:	de 2e       	mov	r13, r30
     fd4:	c8 0e       	add	r12, r24
     fd6:	d9 1e       	adc	r13, r25
     fd8:	8b 01       	movw	r16, r22
     fda:	66 24       	eor	r6, r6
     fdc:	77 24       	eor	r7, r7
				if (edgeList[verticeList[x].edgePoints[j]].obstacle == 1) continue;
				y = getOtherSide(verticeList[x].edgePoints[j],x);
				if (dist[y] > dist[x] + edgeList[verticeList[x].edgePoints[j]].distance) {
     fde:	45 01       	movw	r8, r10
     fe0:	88 0c       	add	r8, r8
     fe2:	99 1c       	adc	r9, r9
     fe4:	82 0c       	add	r8, r2
     fe6:	93 1c       	adc	r9, r3
     fe8:	91 c0       	rjmp	.+290    	; 0x110c <mainFun+0x336>
			}
		for (i = 0; i < qLen; i++) {
			x = q[i];
			dequeue(q,qLen,i); i--; qLen--;
			for (j = 0; j < verticeList[x].edgeCount; j++) {
				if (edgeList[verticeList[x].edgePoints[j]].obstacle == 1) continue;
     fea:	d6 01       	movw	r26, r12
     fec:	2c 91       	ld	r18, X
     fee:	11 96       	adiw	r26, 0x01	; 1
     ff0:	3c 91       	ld	r19, X
     ff2:	c9 01       	movw	r24, r18
     ff4:	fc 01       	movw	r30, r24
     ff6:	43 e0       	ldi	r20, 0x03	; 3
     ff8:	ee 0f       	add	r30, r30
     ffa:	ff 1f       	adc	r31, r31
     ffc:	4a 95       	dec	r20
     ffe:	e1 f7       	brne	.-8      	; 0xff8 <mainFun+0x222>
    1000:	88 0f       	add	r24, r24
    1002:	99 1f       	adc	r25, r25
    1004:	e8 0f       	add	r30, r24
    1006:	f9 1f       	adc	r31, r25
    1008:	e3 5c       	subi	r30, 0xC3	; 195
    100a:	f9 4f       	sbci	r31, 0xF9	; 249
    100c:	80 81       	ld	r24, Z
    100e:	91 81       	ldd	r25, Z+1	; 0x01
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	09 f4       	brne	.+2      	; 0x1016 <mainFun+0x240>
    1014:	74 c0       	rjmp	.+232    	; 0x10fe <mainFun+0x328>
* Logic:			Take the edge, if the one end is same as given vertice, return other vertice, else return current vertice
* Example Call:		getOtherSide(1,1);
*/

int getOtherSide(int tempE, int tempG) {
	if (edgeList[tempE].endA != tempG) return edgeList[tempE].endA;
    1016:	c9 01       	movw	r24, r18
    1018:	fc 01       	movw	r30, r24
    101a:	a3 e0       	ldi	r26, 0x03	; 3
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	aa 95       	dec	r26
    1022:	e1 f7       	brne	.-8      	; 0x101c <mainFun+0x246>
    1024:	88 0f       	add	r24, r24
    1026:	99 1f       	adc	r25, r25
    1028:	e8 0f       	add	r30, r24
    102a:	f9 1f       	adc	r31, r25
    102c:	e3 5c       	subi	r30, 0xC3	; 195
    102e:	f9 4f       	sbci	r31, 0xF9	; 249
    1030:	64 81       	ldd	r22, Z+4	; 0x04
    1032:	75 81       	ldd	r23, Z+5	; 0x05
    1034:	6a 15       	cp	r22, r10
    1036:	7b 05       	cpc	r23, r11
    1038:	79 f4       	brne	.+30     	; 0x1058 <mainFun+0x282>
	return edgeList[tempE].endB;
    103a:	c9 01       	movw	r24, r18
    103c:	fc 01       	movw	r30, r24
    103e:	63 e0       	ldi	r22, 0x03	; 3
    1040:	ee 0f       	add	r30, r30
    1042:	ff 1f       	adc	r31, r31
    1044:	6a 95       	dec	r22
    1046:	e1 f7       	brne	.-8      	; 0x1040 <mainFun+0x26a>
    1048:	88 0f       	add	r24, r24
    104a:	99 1f       	adc	r25, r25
    104c:	e8 0f       	add	r30, r24
    104e:	f9 1f       	adc	r31, r25
    1050:	e3 5c       	subi	r30, 0xC3	; 195
    1052:	f9 4f       	sbci	r31, 0xF9	; 249
    1054:	66 81       	ldd	r22, Z+6	; 0x06
    1056:	77 81       	ldd	r23, Z+7	; 0x07
			x = q[i];
			dequeue(q,qLen,i); i--; qLen--;
			for (j = 0; j < verticeList[x].edgeCount; j++) {
				if (edgeList[verticeList[x].edgePoints[j]].obstacle == 1) continue;
				y = getOtherSide(verticeList[x].edgePoints[j],x);
				if (dist[y] > dist[x] + edgeList[verticeList[x].edgePoints[j]].distance) {
    1058:	c9 01       	movw	r24, r18
    105a:	f9 01       	movw	r30, r18
    105c:	43 e0       	ldi	r20, 0x03	; 3
    105e:	ee 0f       	add	r30, r30
    1060:	ff 1f       	adc	r31, r31
    1062:	4a 95       	dec	r20
    1064:	e1 f7       	brne	.-8      	; 0x105e <mainFun+0x288>
    1066:	88 0f       	add	r24, r24
    1068:	99 1f       	adc	r25, r25
    106a:	e8 0f       	add	r30, r24
    106c:	f9 1f       	adc	r31, r25
    106e:	e3 5c       	subi	r30, 0xC3	; 195
    1070:	f9 4f       	sbci	r31, 0xF9	; 249
    1072:	d4 01       	movw	r26, r8
    1074:	4d 91       	ld	r20, X+
    1076:	5c 91       	ld	r21, X
    1078:	80 85       	ldd	r24, Z+8	; 0x08
    107a:	91 85       	ldd	r25, Z+9	; 0x09
    107c:	48 0f       	add	r20, r24
    107e:	59 1f       	adc	r21, r25
    1080:	fb 01       	movw	r30, r22
    1082:	ee 0f       	add	r30, r30
    1084:	ff 1f       	adc	r31, r31
    1086:	e2 0d       	add	r30, r2
    1088:	f3 1d       	adc	r31, r3
    108a:	80 81       	ld	r24, Z
    108c:	91 81       	ldd	r25, Z+1	; 0x01
    108e:	48 17       	cp	r20, r24
    1090:	59 07       	cpc	r21, r25
    1092:	ac f5       	brge	.+106    	; 0x10fe <mainFun+0x328>
					dist[y] = dist[x] + edgeList[verticeList[x].edgePoints[j]].distance;
					prevPts[y] = x;
					enqueue(q,qLen,i+1,y); qLen++; i++;
    1094:	08 94       	sec
    1096:	e1 1c       	adc	r14, r1
    1098:	f1 1c       	adc	r15, r1
    109a:	98 01       	movw	r18, r16
    109c:	f8 01       	movw	r30, r16
    109e:	31 97       	sbiw	r30, 0x01	; 1
    10a0:	ee 0f       	add	r30, r30
    10a2:	ff 1f       	adc	r31, r31
    10a4:	e4 0d       	add	r30, r4
    10a6:	f5 1d       	adc	r31, r5
    10a8:	d8 01       	movw	r26, r16
    10aa:	aa 0f       	add	r26, r26
    10ac:	bb 1f       	adc	r27, r27
    10ae:	a4 0d       	add	r26, r4
    10b0:	b5 1d       	adc	r27, r5
    10b2:	07 c0       	rjmp	.+14     	; 0x10c2 <mainFun+0x2ec>
*/

void enqueue(int q[],int qLen,int n,int x) { // n -> position to enqueue, x -> element to enqueue
	int i; //for iteration
	for (i = qLen-1; i >= n; i--) {
		q[i+1] = q[i];
    10b4:	80 81       	ld	r24, Z
    10b6:	91 81       	ldd	r25, Z+1	; 0x01
    10b8:	11 96       	adiw	r26, 0x01	; 1
    10ba:	9c 93       	st	X, r25
    10bc:	8e 93       	st	-X, r24
    10be:	32 97       	sbiw	r30, 0x02	; 2
    10c0:	12 97       	sbiw	r26, 0x02	; 2
    10c2:	21 50       	subi	r18, 0x01	; 1
    10c4:	30 40       	sbci	r19, 0x00	; 0
* Example Call:		enqueue(q,5,3,23);
*/

void enqueue(int q[],int qLen,int n,int x) { // n -> position to enqueue, x -> element to enqueue
	int i; //for iteration
	for (i = qLen-1; i >= n; i--) {
    10c6:	2e 15       	cp	r18, r14
    10c8:	3f 05       	cpc	r19, r15
    10ca:	a4 f7       	brge	.-24     	; 0x10b4 <mainFun+0x2de>
			dequeue(q,qLen,i); i--; qLen--;
			for (j = 0; j < verticeList[x].edgeCount; j++) {
				if (edgeList[verticeList[x].edgePoints[j]].obstacle == 1) continue;
				y = getOtherSide(verticeList[x].edgePoints[j],x);
				if (dist[y] > dist[x] + edgeList[verticeList[x].edgePoints[j]].distance) {
					dist[y] = dist[x] + edgeList[verticeList[x].edgePoints[j]].distance;
    10cc:	fb 01       	movw	r30, r22
    10ce:	ee 0f       	add	r30, r30
    10d0:	ff 1f       	adc	r31, r31
    10d2:	d1 01       	movw	r26, r2
    10d4:	ae 0f       	add	r26, r30
    10d6:	bf 1f       	adc	r27, r31
    10d8:	4d 93       	st	X+, r20
    10da:	5c 93       	st	X, r21
					prevPts[y] = x;
    10dc:	21 e0       	ldi	r18, 0x01	; 1
    10de:	30 e0       	ldi	r19, 0x00	; 0
    10e0:	2c 0f       	add	r18, r28
    10e2:	3d 1f       	adc	r19, r29
    10e4:	e2 0f       	add	r30, r18
    10e6:	f3 1f       	adc	r31, r19
    10e8:	b1 a2       	std	Z+33, r11	; 0x21
    10ea:	a0 a2       	std	Z+32, r10	; 0x20
void enqueue(int q[],int qLen,int n,int x) { // n -> position to enqueue, x -> element to enqueue
	int i; //for iteration
	for (i = qLen-1; i >= n; i--) {
		q[i+1] = q[i];
	}
	q[n] = x;
    10ec:	f7 01       	movw	r30, r14
    10ee:	ee 0f       	add	r30, r30
    10f0:	ff 1f       	adc	r31, r31
    10f2:	e4 0d       	add	r30, r4
    10f4:	f5 1d       	adc	r31, r5
    10f6:	71 83       	std	Z+1, r23	; 0x01
    10f8:	60 83       	st	Z, r22
				if (edgeList[verticeList[x].edgePoints[j]].obstacle == 1) continue;
				y = getOtherSide(verticeList[x].edgePoints[j],x);
				if (dist[y] > dist[x] + edgeList[verticeList[x].edgePoints[j]].distance) {
					dist[y] = dist[x] + edgeList[verticeList[x].edgePoints[j]].distance;
					prevPts[y] = x;
					enqueue(q,qLen,i+1,y); qLen++; i++;
    10fa:	0f 5f       	subi	r16, 0xFF	; 255
    10fc:	1f 4f       	sbci	r17, 0xFF	; 255
				}
			}
		for (i = 0; i < qLen; i++) {
			x = q[i];
			dequeue(q,qLen,i); i--; qLen--;
			for (j = 0; j < verticeList[x].edgeCount; j++) {
    10fe:	08 94       	sec
    1100:	61 1c       	adc	r6, r1
    1102:	71 1c       	adc	r7, r1
    1104:	62 e0       	ldi	r22, 0x02	; 2
    1106:	70 e0       	ldi	r23, 0x00	; 0
    1108:	c6 0e       	add	r12, r22
    110a:	d7 1e       	adc	r13, r23
    110c:	c5 5b       	subi	r28, 0xB5	; 181
    110e:	de 4f       	sbci	r29, 0xFE	; 254
    1110:	88 81       	ld	r24, Y
    1112:	99 81       	ldd	r25, Y+1	; 0x01
    1114:	cb 54       	subi	r28, 0x4B	; 75
    1116:	d1 40       	sbci	r29, 0x01	; 1
    1118:	68 16       	cp	r6, r24
    111a:	79 06       	cpc	r7, r25
    111c:	0c f4       	brge	.+2      	; 0x1120 <mainFun+0x34a>
    111e:	65 cf       	rjmp	.-310    	; 0xfea <mainFun+0x214>
					if ( dist[q[j]] >= dist[finalDest[i]-1] ) {
						dequeue(q,qLen,j); j--; qLen--;
					}
				}
			}
		for (i = 0; i < qLen; i++) {
    1120:	a7 01       	movw	r20, r14
    1122:	4f 5f       	subi	r20, 0xFF	; 255
    1124:	5f 4f       	sbci	r21, 0xFF	; 255
    1126:	40 17       	cp	r20, r16
    1128:	51 07       	cpc	r21, r17
    112a:	0c f4       	brge	.+2      	; 0x112e <mainFun+0x358>
    112c:	1c cf       	rjmp	.-456    	; 0xf66 <mainFun+0x190>
	finalDestCount = getFinalDest(dest,finalDest);
	for (i = 0; i < 49; i++) prevPts[i] = -1;
	for (i = 0; i < 49; i++) dist[i] = 20000;
	dist[src - 1] = 0;
	qLen = 1; q[0] = src - 1;
	while ( qLen>0 ) {
    112e:	10 16       	cp	r1, r16
    1130:	11 06       	cpc	r1, r17
    1132:	84 f0       	brlt	.+32     	; 0x1154 <mainFun+0x37e>
    1134:	8e 01       	movw	r16, r28
    1136:	0d 5f       	subi	r16, 0xFD	; 253
    1138:	1f 4f       	sbci	r17, 0xFF	; 255
    113a:	41 e0       	ldi	r20, 0x01	; 1
    113c:	50 e0       	ldi	r21, 0x00	; 0
    113e:	ee 24       	eor	r14, r14
    1140:	ff 24       	eor	r15, r15
    1142:	be 01       	movw	r22, r28
    1144:	6f 5f       	subi	r22, 0xFF	; 255
    1146:	7f 4f       	sbci	r23, 0xFF	; 255
				}
			}
		}
	}
	for (x = 0, i = 1; i < finalDestCount; i++) {
		if (dist[finalDest[i]-1] < dist[finalDest[x]-1])
    1148:	93 e8       	ldi	r25, 0x83	; 131
    114a:	c9 2e       	mov	r12, r25
    114c:	d1 2c       	mov	r13, r1
    114e:	cc 0e       	add	r12, r28
    1150:	dd 1e       	adc	r13, r29
    1152:	26 c0       	rjmp	.+76     	; 0x11a0 <mainFun+0x3ca>
	finalDestCount = getFinalDest(dest,finalDest);
	for (i = 0; i < 49; i++) prevPts[i] = -1;
	for (i = 0; i < 49; i++) dist[i] = 20000;
	dist[src - 1] = 0;
	qLen = 1; q[0] = src - 1;
	while ( qLen>0 ) {
    1154:	6e 01       	movw	r12, r28
    1156:	08 94       	sec
    1158:	c1 1c       	adc	r12, r1
    115a:	d1 1c       	adc	r13, r1
    115c:	ee 24       	eor	r14, r14
    115e:	ff 24       	eor	r15, r15
    1160:	f5 ce       	rjmp	.-534    	; 0xf4c <mainFun+0x176>
				}
			}
		}
	}
	for (x = 0, i = 1; i < finalDestCount; i++) {
		if (dist[finalDest[i]-1] < dist[finalDest[x]-1])
    1162:	f8 01       	movw	r30, r16
    1164:	a0 81       	ld	r26, Z
    1166:	b1 81       	ldd	r27, Z+1	; 0x01
    1168:	11 97       	sbiw	r26, 0x01	; 1
    116a:	aa 0f       	add	r26, r26
    116c:	bb 1f       	adc	r27, r27
    116e:	ac 0d       	add	r26, r12
    1170:	bd 1d       	adc	r27, r13
    1172:	26 0f       	add	r18, r22
    1174:	37 1f       	adc	r19, r23
    1176:	f9 01       	movw	r30, r18
    1178:	80 81       	ld	r24, Z
    117a:	91 81       	ldd	r25, Z+1	; 0x01
    117c:	01 97       	sbiw	r24, 0x01	; 1
    117e:	88 0f       	add	r24, r24
    1180:	99 1f       	adc	r25, r25
    1182:	8c 0d       	add	r24, r12
    1184:	9d 1d       	adc	r25, r13
    1186:	2d 91       	ld	r18, X+
    1188:	3c 91       	ld	r19, X
    118a:	dc 01       	movw	r26, r24
    118c:	8d 91       	ld	r24, X+
    118e:	9c 91       	ld	r25, X
    1190:	28 17       	cp	r18, r24
    1192:	39 07       	cpc	r19, r25
    1194:	0c f4       	brge	.+2      	; 0x1198 <mainFun+0x3c2>
    1196:	7a 01       	movw	r14, r20
					enqueue(q,qLen,i+1,y); qLen++; i++;
				}
			}
		}
	}
	for (x = 0, i = 1; i < finalDestCount; i++) {
    1198:	4f 5f       	subi	r20, 0xFF	; 255
    119a:	5f 4f       	sbci	r21, 0xFF	; 255
    119c:	0e 5f       	subi	r16, 0xFE	; 254
    119e:	1f 4f       	sbci	r17, 0xFF	; 255
    11a0:	97 01       	movw	r18, r14
    11a2:	22 0f       	add	r18, r18
    11a4:	33 1f       	adc	r19, r19
    11a6:	c7 5b       	subi	r28, 0xB7	; 183
    11a8:	de 4f       	sbci	r29, 0xFE	; 254
    11aa:	e8 81       	ld	r30, Y
    11ac:	f9 81       	ldd	r31, Y+1	; 0x01
    11ae:	c9 54       	subi	r28, 0x49	; 73
    11b0:	d1 40       	sbci	r29, 0x01	; 1
    11b2:	4e 17       	cp	r20, r30
    11b4:	5f 07       	cpc	r21, r31
    11b6:	ac f2       	brlt	.-86     	; 0x1162 <mainFun+0x38c>
		if (dist[finalDest[i]-1] < dist[finalDest[x]-1])
			x = i;
	}
	z = finalDest[x] - 1;
    11b8:	62 0f       	add	r22, r18
    11ba:	73 1f       	adc	r23, r19
    11bc:	db 01       	movw	r26, r22
    11be:	4d 91       	ld	r20, X+
    11c0:	5c 91       	ld	r21, X
    11c2:	41 50       	subi	r20, 0x01	; 1
    11c4:	50 40       	sbci	r21, 0x00	; 0
	pathLen = 0;
    11c6:	10 92 c1 08 	sts	0x08C1, r1
    11ca:	10 92 c0 08 	sts	0x08C0, r1
	while (prevPts[z] != -1) {
    11ce:	3e 01       	movw	r6, r28
    11d0:	08 94       	sec
    11d2:	61 1c       	adc	r6, r1
    11d4:	71 1c       	adc	r7, r1
		path[pathLen++] = z+1;
		tempV = verticeList[z];
    11d6:	74 e1       	ldi	r23, 0x14	; 20
    11d8:	87 2e       	mov	r8, r23
    11da:	91 2c       	mov	r9, r1
    11dc:	6d e0       	ldi	r22, 0x0D	; 13
    11de:	a6 2e       	mov	r10, r22
    11e0:	b1 2c       	mov	r11, r1
    11e2:	ac 0e       	add	r10, r28
    11e4:	bd 1e       	adc	r11, r29
    11e6:	35 e1       	ldi	r19, 0x15	; 21
    11e8:	c3 2e       	mov	r12, r19
    11ea:	d1 2c       	mov	r13, r1
    11ec:	cc 0e       	add	r12, r28
    11ee:	dd 1e       	adc	r13, r29
    11f0:	ec c0       	rjmp	.+472    	; 0x13ca <mainFun+0x5f4>
			x = i;
	}
	z = finalDest[x] - 1;
	pathLen = 0;
	while (prevPts[z] != -1) {
		path[pathLen++] = z+1;
    11f2:	80 91 c0 08 	lds	r24, 0x08C0
    11f6:	90 91 c1 08 	lds	r25, 0x08C1
    11fa:	4f 5f       	subi	r20, 0xFF	; 255
    11fc:	5f 4f       	sbci	r21, 0xFF	; 255
    11fe:	fc 01       	movw	r30, r24
    1200:	ee 0f       	add	r30, r30
    1202:	ff 1f       	adc	r31, r31
    1204:	e7 51       	subi	r30, 0x17	; 23
    1206:	fa 4f       	sbci	r31, 0xFA	; 250
    1208:	51 83       	std	Z+1, r21	; 0x01
    120a:	40 83       	st	Z, r20
    120c:	41 50       	subi	r20, 0x01	; 1
    120e:	50 40       	sbci	r21, 0x00	; 0
    1210:	01 96       	adiw	r24, 0x01	; 1
    1212:	90 93 c1 08 	sts	0x08C1, r25
    1216:	80 93 c0 08 	sts	0x08C0, r24
		tempV = verticeList[z];
    121a:	48 9d       	mul	r20, r8
    121c:	f0 01       	movw	r30, r0
    121e:	49 9d       	mul	r20, r9
    1220:	f0 0d       	add	r31, r0
    1222:	58 9d       	mul	r21, r8
    1224:	f0 0d       	add	r31, r0
    1226:	11 24       	eor	r1, r1
    1228:	d5 01       	movw	r26, r10
    122a:	ee 53       	subi	r30, 0x3E	; 62
    122c:	f7 4f       	sbci	r31, 0xF7	; 247
    122e:	84 e1       	ldi	r24, 0x14	; 20
    1230:	01 90       	ld	r0, Z+
    1232:	0d 92       	st	X+, r0
    1234:	81 50       	subi	r24, 0x01	; 1
    1236:	e1 f7       	brne	.-8      	; 0x1230 <mainFun+0x45a>
    1238:	6b 89       	ldd	r22, Y+19	; 0x13
    123a:	7c 89       	ldd	r23, Y+20	; 0x14
    123c:	d6 01       	movw	r26, r12
    123e:	20 e0       	ldi	r18, 0x00	; 0
    1240:	30 e0       	ldi	r19, 0x00	; 0
    1242:	1e c0       	rjmp	.+60     	; 0x1280 <mainFun+0x4aa>
		for (i = 0; i < tempV.edgeCount; i++) {
			x = tempV.edgePoints[i];
    1244:	ed 90       	ld	r14, X+
    1246:	fc 90       	ld	r15, X
    1248:	11 97       	sbiw	r26, 0x01	; 1
* Logic:			Take the edge, if the one end is same as given vertice, return other vertice, else return current vertice
* Example Call:		getOtherSide(1,1);
*/

int getOtherSide(int tempE, int tempG) {
	if (edgeList[tempE].endA != tempG) return edgeList[tempE].endA;
    124a:	f7 01       	movw	r30, r14
    124c:	ee 0f       	add	r30, r30
    124e:	ff 1f       	adc	r31, r31
    1250:	c7 01       	movw	r24, r14
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
    1256:	88 0f       	add	r24, r24
    1258:	99 1f       	adc	r25, r25
    125a:	88 0f       	add	r24, r24
    125c:	99 1f       	adc	r25, r25
    125e:	e8 0f       	add	r30, r24
    1260:	f9 1f       	adc	r31, r25
    1262:	e3 5c       	subi	r30, 0xC3	; 195
    1264:	f9 4f       	sbci	r31, 0xF9	; 249
    1266:	84 81       	ldd	r24, Z+4	; 0x04
    1268:	95 81       	ldd	r25, Z+5	; 0x05
    126a:	84 17       	cp	r24, r20
    126c:	95 07       	cpc	r25, r21
    126e:	11 f4       	brne	.+4      	; 0x1274 <mainFun+0x49e>
	return edgeList[tempE].endB;
    1270:	86 81       	ldd	r24, Z+6	; 0x06
    1272:	97 81       	ldd	r25, Z+7	; 0x07
    1274:	12 96       	adiw	r26, 0x02	; 2
	while (prevPts[z] != -1) {
		path[pathLen++] = z+1;
		tempV = verticeList[z];
		for (i = 0; i < tempV.edgeCount; i++) {
			x = tempV.edgePoints[i];
			if (getOtherSide(x,z) == prevPts[z]) break;
    1276:	80 17       	cp	r24, r16
    1278:	91 07       	cpc	r25, r17
    127a:	29 f0       	breq	.+10     	; 0x1286 <mainFun+0x4b0>
	z = finalDest[x] - 1;
	pathLen = 0;
	while (prevPts[z] != -1) {
		path[pathLen++] = z+1;
		tempV = verticeList[z];
		for (i = 0; i < tempV.edgeCount; i++) {
    127c:	2f 5f       	subi	r18, 0xFF	; 255
    127e:	3f 4f       	sbci	r19, 0xFF	; 255
    1280:	26 17       	cp	r18, r22
    1282:	37 07       	cpc	r19, r23
    1284:	fc f2       	brlt	.-66     	; 0x1244 <mainFun+0x46e>
			x = tempV.edgePoints[i];
			if (getOtherSide(x,z) == prevPts[z]) break;
		}
		path[pathLen++] = edgeList[x].distance;
    1286:	20 91 c0 08 	lds	r18, 0x08C0
    128a:	30 91 c1 08 	lds	r19, 0x08C1
    128e:	d7 01       	movw	r26, r14
    1290:	aa 0f       	add	r26, r26
    1292:	bb 1f       	adc	r27, r27
    1294:	c7 01       	movw	r24, r14
    1296:	73 e0       	ldi	r23, 0x03	; 3
    1298:	88 0f       	add	r24, r24
    129a:	99 1f       	adc	r25, r25
    129c:	7a 95       	dec	r23
    129e:	e1 f7       	brne	.-8      	; 0x1298 <mainFun+0x4c2>
    12a0:	a8 0f       	add	r26, r24
    12a2:	b9 1f       	adc	r27, r25
    12a4:	a3 5c       	subi	r26, 0xC3	; 195
    12a6:	b9 4f       	sbci	r27, 0xF9	; 249
    12a8:	18 96       	adiw	r26, 0x08	; 8
    12aa:	8d 91       	ld	r24, X+
    12ac:	9c 91       	ld	r25, X
    12ae:	19 97       	sbiw	r26, 0x09	; 9
    12b0:	f9 01       	movw	r30, r18
    12b2:	ee 0f       	add	r30, r30
    12b4:	ff 1f       	adc	r31, r31
    12b6:	e7 51       	subi	r30, 0x17	; 23
    12b8:	fa 4f       	sbci	r31, 0xFA	; 250
    12ba:	91 83       	std	Z+1, r25	; 0x01
    12bc:	80 83       	st	Z, r24
    12be:	2f 5f       	subi	r18, 0xFF	; 255
    12c0:	3f 4f       	sbci	r19, 0xFF	; 255
    12c2:	30 93 c1 08 	sts	0x08C1, r19
    12c6:	20 93 c0 08 	sts	0x08C0, r18
		if (z == edgeList[x].endA) path[pathLen++] = edgeList[x].angle + 180;
    12ca:	14 96       	adiw	r26, 0x04	; 4
    12cc:	8d 91       	ld	r24, X+
    12ce:	9c 91       	ld	r25, X
    12d0:	15 97       	sbiw	r26, 0x05	; 5
    12d2:	48 17       	cp	r20, r24
    12d4:	59 07       	cpc	r21, r25
    12d6:	c1 f4       	brne	.+48     	; 0x1308 <mainFun+0x532>
    12d8:	20 91 c0 08 	lds	r18, 0x08C0
    12dc:	30 91 c1 08 	lds	r19, 0x08C1
    12e0:	12 96       	adiw	r26, 0x02	; 2
    12e2:	8d 91       	ld	r24, X+
    12e4:	9c 91       	ld	r25, X
    12e6:	13 97       	sbiw	r26, 0x03	; 3
    12e8:	8c 54       	subi	r24, 0x4C	; 76
    12ea:	9f 4f       	sbci	r25, 0xFF	; 255
    12ec:	f9 01       	movw	r30, r18
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	e7 51       	subi	r30, 0x17	; 23
    12f4:	fa 4f       	sbci	r31, 0xFA	; 250
    12f6:	91 83       	std	Z+1, r25	; 0x01
    12f8:	80 83       	st	Z, r24
    12fa:	2f 5f       	subi	r18, 0xFF	; 255
    12fc:	3f 4f       	sbci	r19, 0xFF	; 255
    12fe:	30 93 c1 08 	sts	0x08C1, r19
    1302:	20 93 c0 08 	sts	0x08C0, r18
    1306:	14 c0       	rjmp	.+40     	; 0x1330 <mainFun+0x55a>
		else path[pathLen++] = edgeList[x].angle;
    1308:	80 91 c0 08 	lds	r24, 0x08C0
    130c:	90 91 c1 08 	lds	r25, 0x08C1
    1310:	12 96       	adiw	r26, 0x02	; 2
    1312:	2d 91       	ld	r18, X+
    1314:	3c 91       	ld	r19, X
    1316:	13 97       	sbiw	r26, 0x03	; 3
    1318:	fc 01       	movw	r30, r24
    131a:	ee 0f       	add	r30, r30
    131c:	ff 1f       	adc	r31, r31
    131e:	e7 51       	subi	r30, 0x17	; 23
    1320:	fa 4f       	sbci	r31, 0xFA	; 250
    1322:	31 83       	std	Z+1, r19	; 0x01
    1324:	20 83       	st	Z, r18
    1326:	01 96       	adiw	r24, 0x01	; 1
    1328:	90 93 c1 08 	sts	0x08C1, r25
    132c:	80 93 c0 08 	sts	0x08C0, r24
		if (path[pathLen-1] > 180) path[pathLen-1] -= 360;
    1330:	e0 91 c0 08 	lds	r30, 0x08C0
    1334:	f0 91 c1 08 	lds	r31, 0x08C1
    1338:	ee 0f       	add	r30, r30
    133a:	ff 1f       	adc	r31, r31
    133c:	e9 51       	subi	r30, 0x19	; 25
    133e:	fa 4f       	sbci	r31, 0xFA	; 250
    1340:	80 81       	ld	r24, Z
    1342:	91 81       	ldd	r25, Z+1	; 0x01
    1344:	85 3b       	cpi	r24, 0xB5	; 181
    1346:	91 05       	cpc	r25, r1
    1348:	6c f0       	brlt	.+26     	; 0x1364 <mainFun+0x58e>
    134a:	e0 91 c0 08 	lds	r30, 0x08C0
    134e:	f0 91 c1 08 	lds	r31, 0x08C1
    1352:	ee 0f       	add	r30, r30
    1354:	ff 1f       	adc	r31, r31
    1356:	e9 51       	subi	r30, 0x19	; 25
    1358:	fa 4f       	sbci	r31, 0xFA	; 250
    135a:	80 81       	ld	r24, Z
    135c:	91 81       	ldd	r25, Z+1	; 0x01
    135e:	88 56       	subi	r24, 0x68	; 104
    1360:	91 40       	sbci	r25, 0x01	; 1
    1362:	19 c0       	rjmp	.+50     	; 0x1396 <mainFun+0x5c0>
		else if (path[pathLen-1] <= -180) path[pathLen-1] +=360;
    1364:	e0 91 c0 08 	lds	r30, 0x08C0
    1368:	f0 91 c1 08 	lds	r31, 0x08C1
    136c:	ee 0f       	add	r30, r30
    136e:	ff 1f       	adc	r31, r31
    1370:	e9 51       	subi	r30, 0x19	; 25
    1372:	fa 4f       	sbci	r31, 0xFA	; 250
    1374:	80 81       	ld	r24, Z
    1376:	91 81       	ldd	r25, Z+1	; 0x01
    1378:	8d 54       	subi	r24, 0x4D	; 77
    137a:	9f 4f       	sbci	r25, 0xFF	; 255
    137c:	74 f4       	brge	.+28     	; 0x139a <mainFun+0x5c4>
    137e:	e0 91 c0 08 	lds	r30, 0x08C0
    1382:	f0 91 c1 08 	lds	r31, 0x08C1
    1386:	ee 0f       	add	r30, r30
    1388:	ff 1f       	adc	r31, r31
    138a:	e9 51       	subi	r30, 0x19	; 25
    138c:	fa 4f       	sbci	r31, 0xFA	; 250
    138e:	80 81       	ld	r24, Z
    1390:	91 81       	ldd	r25, Z+1	; 0x01
    1392:	88 59       	subi	r24, 0x98	; 152
    1394:	9e 4f       	sbci	r25, 0xFE	; 254
    1396:	91 83       	std	Z+1, r25	; 0x01
    1398:	80 83       	st	Z, r24
		path[pathLen-1] = -path[pathLen-1];
    139a:	e0 91 c0 08 	lds	r30, 0x08C0
    139e:	f0 91 c1 08 	lds	r31, 0x08C1
    13a2:	a0 91 c0 08 	lds	r26, 0x08C0
    13a6:	b0 91 c1 08 	lds	r27, 0x08C1
    13aa:	aa 0f       	add	r26, r26
    13ac:	bb 1f       	adc	r27, r27
    13ae:	a9 51       	subi	r26, 0x19	; 25
    13b0:	ba 4f       	sbci	r27, 0xFA	; 250
    13b2:	8d 91       	ld	r24, X+
    13b4:	9c 91       	ld	r25, X
    13b6:	90 95       	com	r25
    13b8:	81 95       	neg	r24
    13ba:	9f 4f       	sbci	r25, 0xFF	; 255
    13bc:	ee 0f       	add	r30, r30
    13be:	ff 1f       	adc	r31, r31
    13c0:	e9 51       	subi	r30, 0x19	; 25
    13c2:	fa 4f       	sbci	r31, 0xFA	; 250
    13c4:	91 83       	std	Z+1, r25	; 0x01
    13c6:	80 83       	st	Z, r24
    13c8:	a8 01       	movw	r20, r16
		if (dist[finalDest[i]-1] < dist[finalDest[x]-1])
			x = i;
	}
	z = finalDest[x] - 1;
	pathLen = 0;
	while (prevPts[z] != -1) {
    13ca:	fa 01       	movw	r30, r20
    13cc:	ee 0f       	add	r30, r30
    13ce:	ff 1f       	adc	r31, r31
    13d0:	e6 0d       	add	r30, r6
    13d2:	f7 1d       	adc	r31, r7
    13d4:	00 a1       	ldd	r16, Z+32	; 0x20
    13d6:	11 a1       	ldd	r17, Z+33	; 0x21
    13d8:	ef ef       	ldi	r30, 0xFF	; 255
    13da:	0f 3f       	cpi	r16, 0xFF	; 255
    13dc:	1e 07       	cpc	r17, r30
    13de:	09 f0       	breq	.+2      	; 0x13e2 <mainFun+0x60c>
    13e0:	08 cf       	rjmp	.-496    	; 0x11f2 <mainFun+0x41c>
		if (path[pathLen-1] > 180) path[pathLen-1] -= 360;
		else if (path[pathLen-1] <= -180) path[pathLen-1] +=360;
		path[pathLen-1] = -path[pathLen-1];
		z = prevPts[z];
	}
	path[pathLen++] = src;
    13e2:	80 91 c0 08 	lds	r24, 0x08C0
    13e6:	90 91 c1 08 	lds	r25, 0x08C1
    13ea:	fc 01       	movw	r30, r24
    13ec:	ee 0f       	add	r30, r30
    13ee:	ff 1f       	adc	r31, r31
    13f0:	e7 51       	subi	r30, 0x17	; 23
    13f2:	fa 4f       	sbci	r31, 0xFA	; 250
    13f4:	c3 5b       	subi	r28, 0xB3	; 179
    13f6:	de 4f       	sbci	r29, 0xFE	; 254
    13f8:	28 81       	ld	r18, Y
    13fa:	39 81       	ldd	r19, Y+1	; 0x01
    13fc:	cd 54       	subi	r28, 0x4D	; 77
    13fe:	d1 40       	sbci	r29, 0x01	; 1
    1400:	31 83       	std	Z+1, r19	; 0x01
    1402:	20 83       	st	Z, r18
    1404:	01 96       	adiw	r24, 0x01	; 1
    1406:	90 93 c1 08 	sts	0x08C1, r25
    140a:	80 93 c0 08 	sts	0x08C0, r24
    140e:	00 e0       	ldi	r16, 0x00	; 0
    1410:	10 e0       	ldi	r17, 0x00	; 0
    1412:	27 c0       	rjmp	.+78     	; 0x1462 <mainFun+0x68c>
	for (i = 0; i < pathLen/2; i++) {
		x = path[i];
    1414:	d8 01       	movw	r26, r16
    1416:	aa 0f       	add	r26, r26
    1418:	bb 1f       	adc	r27, r27
    141a:	a7 51       	subi	r26, 0x17	; 23
    141c:	ba 4f       	sbci	r27, 0xFA	; 250
    141e:	2d 91       	ld	r18, X+
    1420:	3c 91       	ld	r19, X
    1422:	11 97       	sbiw	r26, 0x01	; 1
		path[i] = path[pathLen-i-1];
    1424:	e0 91 c0 08 	lds	r30, 0x08C0
    1428:	f0 91 c1 08 	lds	r31, 0x08C1
    142c:	31 97       	sbiw	r30, 0x01	; 1
    142e:	e0 1b       	sub	r30, r16
    1430:	f1 0b       	sbc	r31, r17
    1432:	ee 0f       	add	r30, r30
    1434:	ff 1f       	adc	r31, r31
    1436:	e7 51       	subi	r30, 0x17	; 23
    1438:	fa 4f       	sbci	r31, 0xFA	; 250
    143a:	80 81       	ld	r24, Z
    143c:	91 81       	ldd	r25, Z+1	; 0x01
    143e:	11 96       	adiw	r26, 0x01	; 1
    1440:	9c 93       	st	X, r25
    1442:	8e 93       	st	-X, r24
		path[pathLen-i-1] = x;
    1444:	e0 91 c0 08 	lds	r30, 0x08C0
    1448:	f0 91 c1 08 	lds	r31, 0x08C1
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	e0 1b       	sub	r30, r16
    1450:	f1 0b       	sbc	r31, r17
    1452:	ee 0f       	add	r30, r30
    1454:	ff 1f       	adc	r31, r31
    1456:	e7 51       	subi	r30, 0x17	; 23
    1458:	fa 4f       	sbci	r31, 0xFA	; 250
    145a:	31 83       	std	Z+1, r19	; 0x01
    145c:	20 83       	st	Z, r18
		else if (path[pathLen-1] <= -180) path[pathLen-1] +=360;
		path[pathLen-1] = -path[pathLen-1];
		z = prevPts[z];
	}
	path[pathLen++] = src;
	for (i = 0; i < pathLen/2; i++) {
    145e:	0f 5f       	subi	r16, 0xFF	; 255
    1460:	1f 4f       	sbci	r17, 0xFF	; 255
    1462:	80 91 c0 08 	lds	r24, 0x08C0
    1466:	90 91 c1 08 	lds	r25, 0x08C1
    146a:	62 e0       	ldi	r22, 0x02	; 2
    146c:	70 e0       	ldi	r23, 0x00	; 0
    146e:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__divmodhi4>
    1472:	06 17       	cp	r16, r22
    1474:	17 07       	cpc	r17, r23
    1476:	74 f2       	brlt	.-100    	; 0x1414 <mainFun+0x63e>
    1478:	21 e0       	ldi	r18, 0x01	; 1
    147a:	30 e0       	ldi	r19, 0x00	; 0
    147c:	30 c0       	rjmp	.+96     	; 0x14de <mainFun+0x708>
		x = path[i];
		path[i] = path[pathLen-i-1];
		path[pathLen-i-1] = x;
	}
	for (i = 1; i < pathLen; i+=3) {
		x = path[i];
    147e:	f9 01       	movw	r30, r18
    1480:	ee 0f       	add	r30, r30
    1482:	ff 1f       	adc	r31, r31
    1484:	e7 51       	subi	r30, 0x17	; 23
    1486:	fa 4f       	sbci	r31, 0xFA	; 250
    1488:	40 81       	ld	r20, Z
    148a:	51 81       	ldd	r21, Z+1	; 0x01
		path[i] -= compass;
    148c:	80 81       	ld	r24, Z
    148e:	91 81       	ldd	r25, Z+1	; 0x01
    1490:	c1 5b       	subi	r28, 0xB1	; 177
    1492:	de 4f       	sbci	r29, 0xFE	; 254
    1494:	68 81       	ld	r22, Y
    1496:	79 81       	ldd	r23, Y+1	; 0x01
    1498:	cf 54       	subi	r28, 0x4F	; 79
    149a:	d1 40       	sbci	r29, 0x01	; 1
    149c:	86 1b       	sub	r24, r22
    149e:	97 0b       	sbc	r25, r23
    14a0:	91 83       	std	Z+1, r25	; 0x01
    14a2:	80 83       	st	Z, r24
		if (path[i] >= 180) path[i] -= 360;
    14a4:	80 81       	ld	r24, Z
    14a6:	91 81       	ldd	r25, Z+1	; 0x01
    14a8:	84 3b       	cpi	r24, 0xB4	; 180
    14aa:	91 05       	cpc	r25, r1
    14ac:	2c f0       	brlt	.+10     	; 0x14b8 <mainFun+0x6e2>
    14ae:	80 81       	ld	r24, Z
    14b0:	91 81       	ldd	r25, Z+1	; 0x01
    14b2:	88 56       	subi	r24, 0x68	; 104
    14b4:	91 40       	sbci	r25, 0x01	; 1
    14b6:	09 c0       	rjmp	.+18     	; 0x14ca <mainFun+0x6f4>
		else if (path[i] <= -180) path[i] += 360;
    14b8:	80 81       	ld	r24, Z
    14ba:	91 81       	ldd	r25, Z+1	; 0x01
    14bc:	8d 54       	subi	r24, 0x4D	; 77
    14be:	9f 4f       	sbci	r25, 0xFF	; 255
    14c0:	34 f4       	brge	.+12     	; 0x14ce <mainFun+0x6f8>
    14c2:	80 81       	ld	r24, Z
    14c4:	91 81       	ldd	r25, Z+1	; 0x01
    14c6:	88 59       	subi	r24, 0x98	; 152
    14c8:	9e 4f       	sbci	r25, 0xFE	; 254
    14ca:	91 83       	std	Z+1, r25	; 0x01
    14cc:	80 83       	st	Z, r24
	for (i = 0; i < pathLen/2; i++) {
		x = path[i];
		path[i] = path[pathLen-i-1];
		path[pathLen-i-1] = x;
	}
	for (i = 1; i < pathLen; i+=3) {
    14ce:	2d 5f       	subi	r18, 0xFD	; 253
    14d0:	3f 4f       	sbci	r19, 0xFF	; 255
    14d2:	c1 5b       	subi	r28, 0xB1	; 177
    14d4:	de 4f       	sbci	r29, 0xFE	; 254
    14d6:	59 83       	std	Y+1, r21	; 0x01
    14d8:	48 83       	st	Y, r20
    14da:	cf 54       	subi	r28, 0x4F	; 79
    14dc:	d1 40       	sbci	r29, 0x01	; 1
    14de:	80 91 c0 08 	lds	r24, 0x08C0
    14e2:	90 91 c1 08 	lds	r25, 0x08C1
    14e6:	28 17       	cp	r18, r24
    14e8:	39 07       	cpc	r19, r25
    14ea:	4c f2       	brlt	.-110    	; 0x147e <mainFun+0x6a8>
		path[i] -= compass;
		if (path[i] >= 180) path[i] -= 360;
		else if (path[i] <= -180) path[i] += 360;
		compass = x;
	}
}
    14ec:	c0 5b       	subi	r28, 0xB0	; 176
    14ee:	de 4f       	sbci	r29, 0xFE	; 254
    14f0:	0f b6       	in	r0, 0x3f	; 63
    14f2:	f8 94       	cli
    14f4:	de bf       	out	0x3e, r29	; 62
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	cd bf       	out	0x3d, r28	; 61
    14fa:	cf 91       	pop	r28
    14fc:	df 91       	pop	r29
    14fe:	1f 91       	pop	r17
    1500:	0f 91       	pop	r16
    1502:	ff 90       	pop	r15
    1504:	ef 90       	pop	r14
    1506:	df 90       	pop	r13
    1508:	cf 90       	pop	r12
    150a:	bf 90       	pop	r11
    150c:	af 90       	pop	r10
    150e:	9f 90       	pop	r9
    1510:	8f 90       	pop	r8
    1512:	7f 90       	pop	r7
    1514:	6f 90       	pop	r6
    1516:	5f 90       	pop	r5
    1518:	4f 90       	pop	r4
    151a:	3f 90       	pop	r3
    151c:	2f 90       	pop	r2
    151e:	08 95       	ret

00001520 <printLCD1>:
* Output:			Prints a,b,c, on the LCD Screen 
* Logic:			Debugger function used to check sensor and other values by printing them on Row 1 of LCD
* Example Call:		printNsetDJ()
*/

void printLCD1(int a,int b,int c) {
    1520:	0f 93       	push	r16
    1522:	1f 93       	push	r17
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	9c 01       	movw	r18, r24
    152a:	8b 01       	movw	r16, r22
    152c:	ea 01       	movw	r28, r20
	lcd_print(1,1,a,2);
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	61 e0       	ldi	r22, 0x01	; 1
    1532:	a9 01       	movw	r20, r18
    1534:	22 e0       	ldi	r18, 0x02	; 2
    1536:	30 e0       	ldi	r19, 0x00	; 0
    1538:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
	lcd_print(1,4,b,2);
    153c:	81 e0       	ldi	r24, 0x01	; 1
    153e:	64 e0       	ldi	r22, 0x04	; 4
    1540:	a8 01       	movw	r20, r16
    1542:	22 e0       	ldi	r18, 0x02	; 2
    1544:	30 e0       	ldi	r19, 0x00	; 0
    1546:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
	if (c>=0) lcd_print(1,7,c,3);		//Checking Negative Value
    154a:	d7 fd       	sbrc	r29, 7
    154c:	04 c0       	rjmp	.+8      	; 0x1556 <printLCD1+0x36>
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	67 e0       	ldi	r22, 0x07	; 7
    1552:	ae 01       	movw	r20, r28
    1554:	06 c0       	rjmp	.+12     	; 0x1562 <printLCD1+0x42>
	else lcd_print(1,7,-c,3);
    1556:	44 27       	eor	r20, r20
    1558:	55 27       	eor	r21, r21
    155a:	4c 1b       	sub	r20, r28
    155c:	5d 0b       	sbc	r21, r29
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	67 e0       	ldi	r22, 0x07	; 7
    1562:	23 e0       	ldi	r18, 0x03	; 3
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
}
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	08 95       	ret

00001574 <printLCD2>:
* Output:			Prints a,b,c, on the LCD Screen 
* Logic:			Debugger function used to check sensor and other values by printing them on Row 2 of LCD
* Example Call:		printNsetDJ()
*/

void printLCD2(int a,int b,int c) {
    1574:	0f 93       	push	r16
    1576:	1f 93       	push	r17
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	9c 01       	movw	r18, r24
    157e:	eb 01       	movw	r28, r22
    1580:	8a 01       	movw	r16, r20
	lcd_print(2,1,a,3);
    1582:	82 e0       	ldi	r24, 0x02	; 2
    1584:	61 e0       	ldi	r22, 0x01	; 1
    1586:	a9 01       	movw	r20, r18
    1588:	23 e0       	ldi	r18, 0x03	; 3
    158a:	30 e0       	ldi	r19, 0x00	; 0
    158c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
	if (b>=0) lcd_print(2,5,b,3);	//Checking Negative Value
    1590:	d7 fd       	sbrc	r29, 7
    1592:	04 c0       	rjmp	.+8      	; 0x159c <printLCD2+0x28>
    1594:	82 e0       	ldi	r24, 0x02	; 2
    1596:	65 e0       	ldi	r22, 0x05	; 5
    1598:	ae 01       	movw	r20, r28
    159a:	06 c0       	rjmp	.+12     	; 0x15a8 <printLCD2+0x34>
	else lcd_print(2,5,-b,3);
    159c:	44 27       	eor	r20, r20
    159e:	55 27       	eor	r21, r21
    15a0:	4c 1b       	sub	r20, r28
    15a2:	5d 0b       	sbc	r21, r29
    15a4:	82 e0       	ldi	r24, 0x02	; 2
    15a6:	65 e0       	ldi	r22, 0x05	; 5
    15a8:	23 e0       	ldi	r18, 0x03	; 3
    15aa:	30 e0       	ldi	r19, 0x00	; 0
    15ac:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
	if (c>=0) lcd_print(2,9,c,3);
    15b0:	17 fd       	sbrc	r17, 7
    15b2:	04 c0       	rjmp	.+8      	; 0x15bc <printLCD2+0x48>
    15b4:	82 e0       	ldi	r24, 0x02	; 2
    15b6:	69 e0       	ldi	r22, 0x09	; 9
    15b8:	a8 01       	movw	r20, r16
    15ba:	06 c0       	rjmp	.+12     	; 0x15c8 <printLCD2+0x54>
	else lcd_print(2,9,-c,3);
    15bc:	44 27       	eor	r20, r20
    15be:	55 27       	eor	r21, r21
    15c0:	40 1b       	sub	r20, r16
    15c2:	51 0b       	sbc	r21, r17
    15c4:	82 e0       	ldi	r24, 0x02	; 2
    15c6:	69 e0       	ldi	r22, 0x09	; 9
    15c8:	23 e0       	ldi	r18, 0x03	; 3
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
}
    15d0:	df 91       	pop	r29
    15d2:	cf 91       	pop	r28
    15d4:	1f 91       	pop	r17
    15d6:	0f 91       	pop	r16
    15d8:	08 95       	ret

000015da <beep>:
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
    15da:	88 e0       	ldi	r24, 0x08	; 8
    15dc:	88 b9       	out	0x08, r24	; 8
    15de:	88 e8       	ldi	r24, 0x88	; 136
    15e0:	93 e1       	ldi	r25, 0x13	; 19
    15e2:	20 e7       	ldi	r18, 0x70	; 112
    15e4:	31 e0       	ldi	r19, 0x01	; 1
    15e6:	f9 01       	movw	r30, r18
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	f1 f7       	brne	.-4      	; 0x15e8 <beep+0xe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15ee:	d9 f7       	brne	.-10     	; 0x15e6 <beep+0xc>
* Example Call:		buzzer_off()
*/

void buzzer_off(void)
{
	PORTC= 0x00;
    15f0:	18 b8       	out	0x08, r1	; 8
    15f2:	88 e8       	ldi	r24, 0x88	; 136
    15f4:	93 e1       	ldi	r25, 0x13	; 19
    15f6:	20 e7       	ldi	r18, 0x70	; 112
    15f8:	31 e0       	ldi	r19, 0x01	; 1
    15fa:	f9 01       	movw	r30, r18
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	f1 f7       	brne	.-4      	; 0x15fc <beep+0x22>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1600:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1602:	d9 f7       	brne	.-10     	; 0x15fa <beep+0x20>
{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
		_delay_ms(500);
}
    1604:	08 95       	ret

00001606 <Sharp_dist>:

unsigned int Sharp_dist(unsigned char adc_reading)
{
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	a0 e0       	ldi	r26, 0x00	; 0
    160a:	b0 e0       	ldi	r27, 0x00	; 0
    160c:	bc 01       	movw	r22, r24
    160e:	cd 01       	movw	r24, r26
    1610:	0e 94 03 13 	call	0x2606	; 0x2606 <__floatunsisf>
    1614:	2f ee       	ldi	r18, 0xEF	; 239
    1616:	39 ec       	ldi	r19, 0xC9	; 201
    1618:	43 e9       	ldi	r20, 0x93	; 147
    161a:	5f e3       	ldi	r21, 0x3F	; 63
    161c:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <pow>
    1620:	9b 01       	movw	r18, r22
    1622:	ac 01       	movw	r20, r24
	distanceInt = (int)distance;
    1624:	60 e0       	ldi	r22, 0x00	; 0
    1626:	70 e0       	ldi	r23, 0x00	; 0
    1628:	80 e8       	ldi	r24, 0x80	; 128
    162a:	9f e3       	ldi	r25, 0x3F	; 63
    162c:	0e 94 75 11 	call	0x22ea	; 0x22ea <__divsf3>
    1630:	2a e9       	ldi	r18, 0x9A	; 154
    1632:	39 ef       	ldi	r19, 0xF9	; 249
    1634:	4e e2       	ldi	r20, 0x2E	; 46
    1636:	55 e4       	ldi	r21, 0x45	; 69
    1638:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <__mulsf3>
    163c:	20 e0       	ldi	r18, 0x00	; 0
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	40 e2       	ldi	r20, 0x20	; 32
    1642:	51 e4       	ldi	r21, 0x41	; 65
    1644:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <__mulsf3>
    1648:	0e 94 af 12 	call	0x255e	; 0x255e <__fixsfsi>
    164c:	88 27       	eor	r24, r24
    164e:	77 fd       	sbrc	r23, 7
    1650:	80 95       	com	r24
    1652:	98 2f       	mov	r25, r24
    1654:	0e 94 51 12 	call	0x24a2	; 0x24a2 <__floatsisf>
    1658:	0e 94 af 12 	call	0x255e	; 0x255e <__fixsfsi>
    165c:	9b 01       	movw	r18, r22
    165e:	83 e0       	ldi	r24, 0x03	; 3
    1660:	61 32       	cpi	r22, 0x21	; 33
    1662:	78 07       	cpc	r23, r24
    1664:	10 f0       	brcs	.+4      	; 0x166a <Sharp_dist+0x64>
    1666:	20 e2       	ldi	r18, 0x20	; 32
    1668:	33 e0       	ldi	r19, 0x03	; 3
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
}
    166a:	c9 01       	movw	r24, r18
    166c:	08 95       	ret

0000166e <printNsetDJ>:
* Logic:			Calls prewritten function ADC_Conversion and gets sensort values. 
* Example Call:		printNsetDJ()
*/

int printNsetDJ(void)
{
    166e:	cf 93       	push	r28
    1670:	df 93       	push	r29
	 djFlag=100 when the bot is tilted towards the right
	 djFlag=1 when the bot is tilted toward the left
	 It takes other values depending on number of sensors is in and out of the line
*/
/* 	 Sharp holds the Sharp sensor adc value*/
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    1672:	83 e0       	ldi	r24, 0x03	; 3
    1674:	0e 94 47 04 	call	0x88e	; 0x88e <ADC_Conversion>
    1678:	80 93 d8 05 	sts	0x05D8, r24
	Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    167c:	82 e0       	ldi	r24, 0x02	; 2
    167e:	0e 94 47 04 	call	0x88e	; 0x88e <ADC_Conversion>
    1682:	80 93 d9 05 	sts	0x05D9, r24
	Right_white_line = ADC_Conversion(1);   //Getting data of Right WL Sensor
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	0e 94 47 04 	call	0x88e	; 0x88e <ADC_Conversion>
    168c:	80 93 da 05 	sts	0x05DA, r24
	Sharp=ADC_Conversion(11);
    1690:	8b e0       	ldi	r24, 0x0B	; 11
    1692:	0e 94 47 04 	call	0x88e	; 0x88e <ADC_Conversion>
	djFlag = 0;
	distance_Sharp=Sharp_dist(Sharp); 		//Converting Voltage value to distance in mm
    1696:	0e 94 03 0b 	call	0x1606	; 0x1606 <Sharp_dist>
    169a:	90 93 e8 05 	sts	0x05E8, r25
    169e:	80 93 e7 05 	sts	0x05E7, r24
	if (Left_white_line>THRESHOLD) djFlag = 100;
    16a2:	80 91 d8 05 	lds	r24, 0x05D8
    16a6:	85 31       	cpi	r24, 0x15	; 21
    16a8:	18 f0       	brcs	.+6      	; 0x16b0 <printNsetDJ+0x42>
    16aa:	c4 e6       	ldi	r28, 0x64	; 100
    16ac:	d0 e0       	ldi	r29, 0x00	; 0
    16ae:	02 c0       	rjmp	.+4      	; 0x16b4 <printNsetDJ+0x46>
    16b0:	c0 e0       	ldi	r28, 0x00	; 0
    16b2:	d0 e0       	ldi	r29, 0x00	; 0
	if (Center_white_line>THRESHOLD) djFlag += 10;
    16b4:	80 91 d9 05 	lds	r24, 0x05D9
    16b8:	85 31       	cpi	r24, 0x15	; 21
    16ba:	08 f0       	brcs	.+2      	; 0x16be <printNsetDJ+0x50>
    16bc:	2a 96       	adiw	r28, 0x0a	; 10
	if (Right_white_line>THRESHOLD) djFlag +=1;
    16be:	80 91 da 05 	lds	r24, 0x05DA
    16c2:	85 31       	cpi	r24, 0x15	; 21
    16c4:	08 f0       	brcs	.+2      	; 0x16c8 <printNsetDJ+0x5a>
    16c6:	21 96       	adiw	r28, 0x01	; 1
	lcd_print(1,13,djFlag,3);
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	6d e0       	ldi	r22, 0x0D	; 13
    16cc:	ae 01       	movw	r20, r28
    16ce:	23 e0       	ldi	r18, 0x03	; 3
    16d0:	30 e0       	ldi	r19, 0x00	; 0
    16d2:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
	//Setting the djFlag
	//lcd_print (2,13,distance_Sharp,3);
	return djFlag;
}
    16d6:	ce 01       	movw	r24, r28
    16d8:	df 91       	pop	r29
    16da:	cf 91       	pop	r28
    16dc:	08 95       	ret

000016de <main>:
					Detailed description will be provided at required places.
* Example Call:		Automatically called by the microcontroller
*/

int main(void)
{
    16de:	2f 92       	push	r2
    16e0:	3f 92       	push	r3
    16e2:	4f 92       	push	r4
    16e4:	5f 92       	push	r5
    16e6:	6f 92       	push	r6
    16e8:	7f 92       	push	r7
    16ea:	8f 92       	push	r8
    16ec:	9f 92       	push	r9
    16ee:	af 92       	push	r10
    16f0:	bf 92       	push	r11
    16f2:	cf 92       	push	r12
    16f4:	df 92       	push	r13
    16f6:	ef 92       	push	r14
    16f8:	ff 92       	push	r15
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	df 93       	push	r29
    1700:	cf 93       	push	r28
    1702:	cd b7       	in	r28, 0x3d	; 61
    1704:	de b7       	in	r29, 0x3e	; 62
    1706:	64 97       	sbiw	r28, 0x14	; 20
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	0f be       	out	0x3f, r0	; 63
    1710:	cd bf       	out	0x3d, r28	; 61
	int djFlag,compass = 0, rotA, arr[10] = {1,7,29,26,18,24,13,30,16,20},ii,last = 1, shFlag = 0, i, reqd;
    1712:	de 01       	movw	r26, r28
    1714:	11 96       	adiw	r26, 0x01	; 1
    1716:	e0 e0       	ldi	r30, 0x00	; 0
    1718:	f2 e0       	ldi	r31, 0x02	; 2
    171a:	84 e1       	ldi	r24, 0x14	; 20
    171c:	01 90       	ld	r0, Z+
    171e:	0d 92       	st	X+, r0
    1720:	81 50       	subi	r24, 0x01	; 1
    1722:	e1 f7       	brne	.-8      	; 0x171c <main+0x3e>
	//arr : Input String is stored in this array . Number 1 is added to every string 
	//Compass : Current angle of robot w.r.t. X Axis
	//last:	Holds the position of current node if an obstacle is detected on the path to next node
	//shFlag:
	//***** Robot is maintained at actual angle with the help of compass which stores tha angle it has turned****
	init_devices();
    1724:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <init_devices>
	init_graph();
    1728:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <init_graph>
	lcd_set_4bit();
    172c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
	lcd_init();
    1730:	0e 94 29 01 	call	0x252	; 0x252 <lcd_init>
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
    1734:	88 e0       	ldi	r24, 0x08	; 8
    1736:	88 b9       	out	0x08, r24	; 8
    1738:	88 e8       	ldi	r24, 0x88	; 136
    173a:	93 e1       	ldi	r25, 0x13	; 19
    173c:	20 e7       	ldi	r18, 0x70	; 112
    173e:	31 e0       	ldi	r19, 0x01	; 1
    1740:	f9 01       	movw	r30, r18
    1742:	31 97       	sbiw	r30, 0x01	; 1
    1744:	f1 f7       	brne	.-4      	; 0x1742 <main+0x64>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1746:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1748:	d9 f7       	brne	.-10     	; 0x1740 <main+0x62>
* Example Call:		buzzer_off()
*/

void buzzer_off(void)
{
	PORTC= 0x00;
    174a:	18 b8       	out	0x08, r1	; 8
    174c:	88 e8       	ldi	r24, 0x88	; 136
    174e:	93 e1       	ldi	r25, 0x13	; 19
    1750:	20 e7       	ldi	r18, 0x70	; 112
    1752:	31 e0       	ldi	r19, 0x01	; 1
    1754:	f9 01       	movw	r30, r18
    1756:	31 97       	sbiw	r30, 0x01	; 1
    1758:	f1 f7       	brne	.-4      	; 0x1756 <main+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    175a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    175c:	d9 f7       	brne	.-10     	; 0x1754 <main+0x76>
    175e:	88 24       	eor	r8, r8
    1760:	99 24       	eor	r9, r9
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	68 2e       	mov	r6, r24
    1766:	71 2c       	mov	r7, r1
    1768:	01 e0       	ldi	r16, 0x01	; 1
    176a:	20 2e       	mov	r2, r16
    176c:	31 2c       	mov	r3, r1
    176e:	ee 24       	eor	r14, r14
    1770:	ff 24       	eor	r15, r15

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1772:	18 ec       	ldi	r17, 0xC8	; 200
    1774:	51 2e       	mov	r5, r17
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
    1776:	b8 e0       	ldi	r27, 0x08	; 8
    1778:	4b 2e       	mov	r4, r27
	beep();//Beep
	for (ii = 1; ii < 10; ii++) {
		//if There's an obstacle, this function is called again to get the new shortest path
		//Find Shortest path between MNP 1 and the first MNP in the number string in the first iteratoin
		//Later on , shortest path between current and the next number in the number string
		mainFun(last,arr[ii],compass);		//Calls the algorithm written in graph.h file. Shortest path stored in Array 'path'
    177a:	f3 01       	movw	r30, r6
    177c:	ee 0f       	add	r30, r30
    177e:	ff 1f       	adc	r31, r31
    1780:	21 e0       	ldi	r18, 0x01	; 1
    1782:	30 e0       	ldi	r19, 0x00	; 0
    1784:	2c 0f       	add	r18, r28
    1786:	3d 1f       	adc	r19, r29
    1788:	e2 0f       	add	r30, r18
    178a:	f3 1f       	adc	r31, r19
    178c:	00 81       	ld	r16, Z
    178e:	11 81       	ldd	r17, Z+1	; 0x01
    1790:	c1 01       	movw	r24, r2
    1792:	b8 01       	movw	r22, r16
    1794:	a4 01       	movw	r20, r8
    1796:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <mainFun>
		printLCD1(last,arr[ii],compass);
    179a:	c1 01       	movw	r24, r2
    179c:	b8 01       	movw	r22, r16
    179e:	a4 01       	movw	r20, r8
    17a0:	0e 94 90 0a 	call	0x1520	; 0x1520 <printLCD1>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    17a4:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    17a8:	50 92 2a 01 	sts	0x012A, r5
    17ac:	cc 24       	eor	r12, r12
    17ae:	dd 24       	eor	r13, r13
    17b0:	64 c2       	rjmp	.+1224   	; 0x1c7a <main+0x59c>

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    17b2:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    17b4:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
    17b6:	82 b9       	out	0x02, r24	; 2
    17b8:	88 e9       	ldi	r24, 0x98	; 152
    17ba:	9a e3       	ldi	r25, 0x3A	; 58
    17bc:	e0 e7       	ldi	r30, 0x70	; 112
    17be:	f1 e0       	ldi	r31, 0x01	; 1
    17c0:	31 97       	sbiw	r30, 0x01	; 1
    17c2:	f1 f7       	brne	.-4      	; 0x17c0 <main+0xe2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17c4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17c6:	d1 f7       	brne	.-12     	; 0x17bc <main+0xde>
		This pattern follows
		*/
		for (i = 0; i < pathLen - 1; i+=3) {			//Access every third element in array i.e. MNP
			stop();
			_delay_ms(1500);
			printLCD2(path[i],path[i+1],compass);
    17c8:	f6 01       	movw	r30, r12
    17ca:	ee 0f       	add	r30, r30
    17cc:	ff 1f       	adc	r31, r31
    17ce:	e7 51       	subi	r30, 0x17	; 23
    17d0:	fa 4f       	sbci	r31, 0xFA	; 250
    17d2:	80 81       	ld	r24, Z
    17d4:	91 81       	ldd	r25, Z+1	; 0x01
					Detailed description will be provided at required places.
* Example Call:		Automatically called by the microcontroller
*/

int main(void)
{
    17d6:	76 01       	movw	r14, r12
    17d8:	08 94       	sec
    17da:	e1 1c       	adc	r14, r1
    17dc:	f1 1c       	adc	r15, r1
		This pattern follows
		*/
		for (i = 0; i < pathLen - 1; i+=3) {			//Access every third element in array i.e. MNP
			stop();
			_delay_ms(1500);
			printLCD2(path[i],path[i+1],compass);
    17de:	87 01       	movw	r16, r14
    17e0:	00 0f       	add	r16, r16
    17e2:	11 1f       	adc	r17, r17
    17e4:	07 51       	subi	r16, 0x17	; 23
    17e6:	1a 4f       	sbci	r17, 0xFA	; 250
    17e8:	f8 01       	movw	r30, r16
    17ea:	60 81       	ld	r22, Z
    17ec:	71 81       	ldd	r23, Z+1	; 0x01
    17ee:	a4 01       	movw	r20, r8
    17f0:	0e 94 ba 0a 	call	0x1574	; 0x1574 <printLCD2>

			//You're at node, rotate an angle

			lcd_print(2,13,1,1);
    17f4:	82 e0       	ldi	r24, 0x02	; 2
    17f6:	6d e0       	ldi	r22, 0x0D	; 13
    17f8:	41 e0       	ldi	r20, 0x01	; 1
    17fa:	50 e0       	ldi	r21, 0x00	; 0
    17fc:	21 e0       	ldi	r18, 0x01	; 1
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1804:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    1806:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    1808:	86 60       	ori	r24, 0x06	; 6
 PORTA = PortARestore; 		// executing the command
    180a:	82 b9       	out	0x02, r24	; 2
			reqd = 8;									//Setting Threshold for encoder
			shFlag = 0; 
			forward();			
			//forward_mm(40);
			if (path[i+1] == 0) forward_mm(40);			//Angle 0 degree.. go 4cm forward
    180c:	f8 01       	movw	r30, r16
    180e:	80 81       	ld	r24, Z
    1810:	91 81       	ldd	r25, Z+1	; 0x01
    1812:	89 2b       	or	r24, r25
    1814:	19 f4       	brne	.+6      	; 0x181c <main+0x13e>
    1816:	88 e2       	ldi	r24, 0x28	; 40
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	07 c0       	rjmp	.+14     	; 0x182a <main+0x14c>
			else if (path[i+1] <= 20) forward_mm(20);	//Angle <=20 degree go 2cm forward
    181c:	f8 01       	movw	r30, r16
    181e:	80 81       	ld	r24, Z
    1820:	91 81       	ldd	r25, Z+1	; 0x01
    1822:	45 97       	sbiw	r24, 0x15	; 21
    1824:	2c f4       	brge	.+10     	; 0x1830 <main+0x152>
    1826:	84 e1       	ldi	r24, 0x14	; 20
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	0e 94 9f 03 	call	0x73e	; 0x73e <forward_mm>
    182e:	59 c0       	rjmp	.+178    	; 0x18e2 <main+0x204>
			else {										//Otherwise Do not turn much
				ShaftCountLeft = ShaftCountRight = 0;
    1830:	10 92 df 05 	sts	0x05DF, r1
    1834:	10 92 e0 05 	sts	0x05E0, r1
    1838:	10 92 e1 05 	sts	0x05E1, r1
    183c:	10 92 e2 05 	sts	0x05E2, r1
    1840:	80 91 df 05 	lds	r24, 0x05DF
    1844:	90 91 e0 05 	lds	r25, 0x05E0
    1848:	a0 91 e1 05 	lds	r26, 0x05E1
    184c:	b0 91 e2 05 	lds	r27, 0x05E2
    1850:	80 93 db 05 	sts	0x05DB, r24
    1854:	90 93 dc 05 	sts	0x05DC, r25
    1858:	a0 93 dd 05 	sts	0x05DD, r26
    185c:	b0 93 de 05 	sts	0x05DE, r27
				while (1) {
					if ( (ShaftCountLeft > reqd) | (ShaftCountRight > reqd) )
    1860:	80 91 db 05 	lds	r24, 0x05DB
    1864:	90 91 dc 05 	lds	r25, 0x05DC
    1868:	a0 91 dd 05 	lds	r26, 0x05DD
    186c:	b0 91 de 05 	lds	r27, 0x05DE
    1870:	20 91 df 05 	lds	r18, 0x05DF
    1874:	30 91 e0 05 	lds	r19, 0x05E0
    1878:	40 91 e1 05 	lds	r20, 0x05E1
    187c:	50 91 e2 05 	lds	r21, 0x05E2
    1880:	09 97       	sbiw	r24, 0x09	; 9
    1882:	a1 05       	cpc	r26, r1
    1884:	b1 05       	cpc	r27, r1
    1886:	68 f5       	brcc	.+90     	; 0x18e2 <main+0x204>
    1888:	29 30       	cpi	r18, 0x09	; 9
    188a:	31 05       	cpc	r19, r1
    188c:	41 05       	cpc	r20, r1
    188e:	51 05       	cpc	r21, r1
    1890:	40 f5       	brcc	.+80     	; 0x18e2 <main+0x204>
						break;
					djFlag = printNsetDJ();
    1892:	0e 94 37 0b 	call	0x166e	; 0x166e <printNsetDJ>
					switch (djFlag) {					//Line follower Logic
    1896:	8b 30       	cpi	r24, 0x0B	; 11
    1898:	91 05       	cpc	r25, r1
    189a:	b1 f0       	breq	.+44     	; 0x18c8 <main+0x1ea>
    189c:	8c 30       	cpi	r24, 0x0C	; 12
    189e:	91 05       	cpc	r25, r1
    18a0:	4c f4       	brge	.+18     	; 0x18b4 <main+0x1d6>
    18a2:	81 30       	cpi	r24, 0x01	; 1
    18a4:	91 05       	cpc	r25, r1
    18a6:	81 f0       	breq	.+32     	; 0x18c8 <main+0x1ea>
    18a8:	8a 30       	cpi	r24, 0x0A	; 10
    18aa:	91 05       	cpc	r25, r1
    18ac:	a9 f0       	breq	.+42     	; 0x18d8 <main+0x1fa>
    18ae:	89 2b       	or	r24, r25
    18b0:	99 f0       	breq	.+38     	; 0x18d8 <main+0x1fa>
    18b2:	d6 cf       	rjmp	.-84     	; 0x1860 <main+0x182>
    18b4:	8e 36       	cpi	r24, 0x6E	; 110
    18b6:	91 05       	cpc	r25, r1
    18b8:	61 f0       	breq	.+24     	; 0x18d2 <main+0x1f4>
    18ba:	8f 36       	cpi	r24, 0x6F	; 111
    18bc:	91 05       	cpc	r25, r1
    18be:	61 f0       	breq	.+24     	; 0x18d8 <main+0x1fa>
    18c0:	84 36       	cpi	r24, 0x64	; 100
    18c2:	91 05       	cpc	r25, r1
    18c4:	69 f6       	brne	.-102    	; 0x1860 <main+0x182>
    18c6:	05 c0       	rjmp	.+10     	; 0x18d2 <main+0x1f4>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    18c8:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    18cc:	10 92 2a 01 	sts	0x012A, r1
    18d0:	c7 cf       	rjmp	.-114    	; 0x1860 <main+0x182>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    18d2:	10 92 28 01 	sts	0x0128, r1
    18d6:	02 c0       	rjmp	.+4      	; 0x18dc <main+0x1fe>
	OCR5BL = (unsigned char) right;
    18d8:	50 92 28 01 	sts	0x0128, r5
    18dc:	50 92 2a 01 	sts	0x012A, r5
    18e0:	bf cf       	rjmp	.-130    	; 0x1860 <main+0x182>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    18e2:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    18e6:	50 92 2a 01 	sts	0x012A, r5

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    18ea:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    18ec:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
    18ee:	82 b9       	out	0x02, r24	; 2

			//Angle depends on battery charge & light conditions

			//path[i+1] denotes angle to be turned

			if (path[i+1] <= 90 && path[i+1] >= -90) rotA = path[i+1]*2/5;	//Angle for turning based on trial and error. Turn less if angle>90 ot <-90(angle*2/5). 
    18f0:	f7 01       	movw	r30, r14
    18f2:	ee 0f       	add	r30, r30
    18f4:	ff 1f       	adc	r31, r31
    18f6:	e7 51       	subi	r30, 0x17	; 23
    18f8:	fa 4f       	sbci	r31, 0xFA	; 250
    18fa:	80 81       	ld	r24, Z
    18fc:	91 81       	ldd	r25, Z+1	; 0x01
    18fe:	8b 35       	cpi	r24, 0x5B	; 91
    1900:	91 05       	cpc	r25, r1
    1902:	64 f4       	brge	.+24     	; 0x191c <main+0x23e>
    1904:	80 81       	ld	r24, Z
    1906:	91 81       	ldd	r25, Z+1	; 0x01
    1908:	86 5a       	subi	r24, 0xA6	; 166
    190a:	9f 4f       	sbci	r25, 0xFF	; 255
    190c:	3c f0       	brlt	.+14     	; 0x191c <main+0x23e>
    190e:	80 81       	ld	r24, Z
    1910:	91 81       	ldd	r25, Z+1	; 0x01
    1912:	88 0f       	add	r24, r24
    1914:	99 1f       	adc	r25, r25
    1916:	65 e0       	ldi	r22, 0x05	; 5
    1918:	70 e0       	ldi	r23, 0x00	; 0
    191a:	0b c0       	rjmp	.+22     	; 0x1932 <main+0x254>
			else rotA = path[i+1]*2/3;										//Else turn greater (angle*2/3)
    191c:	f7 01       	movw	r30, r14
    191e:	ee 0f       	add	r30, r30
    1920:	ff 1f       	adc	r31, r31
    1922:	e7 51       	subi	r30, 0x17	; 23
    1924:	fa 4f       	sbci	r31, 0xFA	; 250
    1926:	80 81       	ld	r24, Z
    1928:	91 81       	ldd	r25, Z+1	; 0x01
    192a:	88 0f       	add	r24, r24
    192c:	99 1f       	adc	r25, r25
    192e:	63 e0       	ldi	r22, 0x03	; 3
    1930:	70 e0       	ldi	r23, 0x00	; 0
    1932:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__divmodhi4>
			//_delay_ms(500);
			if (path[i+1]>20) right_degrees(rotA);
    1936:	f7 01       	movw	r30, r14
    1938:	ee 0f       	add	r30, r30
    193a:	ff 1f       	adc	r31, r31
    193c:	e7 51       	subi	r30, 0x17	; 23
    193e:	fa 4f       	sbci	r31, 0xFA	; 250
    1940:	80 81       	ld	r24, Z
    1942:	91 81       	ldd	r25, Z+1	; 0x01
    1944:	45 97       	sbiw	r24, 0x15	; 21
    1946:	24 f0       	brlt	.+8      	; 0x1950 <main+0x272>
    1948:	cb 01       	movw	r24, r22
    194a:	0e 94 b4 03 	call	0x768	; 0x768 <right_degrees>
    194e:	0b c0       	rjmp	.+22     	; 0x1966 <main+0x288>
			else if (path[i+1]<-20) left_degrees(-rotA);
    1950:	80 81       	ld	r24, Z
    1952:	91 81       	ldd	r25, Z+1	; 0x01
    1954:	8c 5e       	subi	r24, 0xEC	; 236
    1956:	9f 4f       	sbci	r25, 0xFF	; 255
    1958:	34 f4       	brge	.+12     	; 0x1966 <main+0x288>
    195a:	88 27       	eor	r24, r24
    195c:	99 27       	eor	r25, r25
    195e:	86 1b       	sub	r24, r22
    1960:	97 0b       	sbc	r25, r23
    1962:	0e 94 ad 03 	call	0x75a	; 0x75a <left_degrees>
			//_delay_ms(1000);
			do {
				djFlag = printNsetDJ();
				if (path[i+1]>20) right_degrees(5);
    1966:	87 01       	movw	r16, r14
    1968:	00 0f       	add	r16, r16
    196a:	11 1f       	adc	r17, r17
    196c:	07 51       	subi	r16, 0x17	; 23
    196e:	1a 4f       	sbci	r17, 0xFA	; 250
			//_delay_ms(500);
			if (path[i+1]>20) right_degrees(rotA);
			else if (path[i+1]<-20) left_degrees(-rotA);
			//_delay_ms(1000);
			do {
				djFlag = printNsetDJ();
    1970:	0e 94 37 0b 	call	0x166e	; 0x166e <printNsetDJ>
    1974:	5c 01       	movw	r10, r24
				if (path[i+1]>20) right_degrees(5);
    1976:	f8 01       	movw	r30, r16
    1978:	80 81       	ld	r24, Z
    197a:	91 81       	ldd	r25, Z+1	; 0x01
    197c:	45 97       	sbiw	r24, 0x15	; 21
    197e:	2c f0       	brlt	.+10     	; 0x198a <main+0x2ac>
    1980:	85 e0       	ldi	r24, 0x05	; 5
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	0e 94 b4 03 	call	0x768	; 0x768 <right_degrees>
    1988:	0a c0       	rjmp	.+20     	; 0x199e <main+0x2c0>
				else if (path[i+1]<-20) left_degrees(5);
    198a:	f8 01       	movw	r30, r16
    198c:	80 81       	ld	r24, Z
    198e:	91 81       	ldd	r25, Z+1	; 0x01
    1990:	8c 5e       	subi	r24, 0xEC	; 236
    1992:	9f 4f       	sbci	r25, 0xFF	; 255
    1994:	84 f4       	brge	.+32     	; 0x19b6 <main+0x2d8>
    1996:	85 e0       	ldi	r24, 0x05	; 5
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	0e 94 ad 03 	call	0x75a	; 0x75a <left_degrees>
				else break;
			} while ( ((djFlag/10)%10) !=1 );					//Function for aligning robot to line by turning 5 degress until center on white line 
    199e:	c5 01       	movw	r24, r10
    19a0:	6a e0       	ldi	r22, 0x0A	; 10
    19a2:	70 e0       	ldi	r23, 0x00	; 0
    19a4:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__divmodhi4>
    19a8:	cb 01       	movw	r24, r22
    19aa:	6a e0       	ldi	r22, 0x0A	; 10
    19ac:	70 e0       	ldi	r23, 0x00	; 0
    19ae:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__divmodhi4>
    19b2:	01 97       	sbiw	r24, 0x01	; 1
    19b4:	e9 f6       	brne	.-70     	; 0x1970 <main+0x292>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    19b6:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    19ba:	50 92 2a 01 	sts	0x012A, r5
			velocity(MAX_VEL,MAX_VEL);

			//Update compass

			lcd_print(2,13,2,1);
    19be:	82 e0       	ldi	r24, 0x02	; 2
    19c0:	6d e0       	ldi	r22, 0x0D	; 13
    19c2:	42 e0       	ldi	r20, 0x02	; 2
    19c4:	50 e0       	ldi	r21, 0x00	; 0
    19c6:	21 e0       	ldi	r18, 0x01	; 1
    19c8:	30 e0       	ldi	r19, 0x00	; 0
    19ca:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
			compass += path[i+1];								//Updates compass with current angle bot makes w.r.t X axis
    19ce:	f7 01       	movw	r30, r14
    19d0:	ee 0f       	add	r30, r30
    19d2:	ff 1f       	adc	r31, r31
    19d4:	e7 51       	subi	r30, 0x17	; 23
    19d6:	fa 4f       	sbci	r31, 0xFA	; 250
    19d8:	80 81       	ld	r24, Z
    19da:	91 81       	ldd	r25, Z+1	; 0x01
    19dc:	88 0e       	add	r8, r24
    19de:	99 1e       	adc	r9, r25
			if (compass > 180) compass -= 360;
    19e0:	25 eb       	ldi	r18, 0xB5	; 181
    19e2:	82 16       	cp	r8, r18
    19e4:	91 04       	cpc	r9, r1
    19e6:	2c f0       	brlt	.+10     	; 0x19f2 <main+0x314>
    19e8:	88 e9       	ldi	r24, 0x98	; 152
    19ea:	9e ef       	ldi	r25, 0xFE	; 254
    19ec:	88 0e       	add	r8, r24
    19ee:	99 1e       	adc	r9, r25
    19f0:	09 c0       	rjmp	.+18     	; 0x1a04 <main+0x326>
			if (compass < -180) compass += 360;
    19f2:	9c e4       	ldi	r25, 0x4C	; 76
    19f4:	89 16       	cp	r8, r25
    19f6:	9f ef       	ldi	r25, 0xFF	; 255
    19f8:	99 06       	cpc	r9, r25
    19fa:	24 f4       	brge	.+8      	; 0x1a04 <main+0x326>
    19fc:	e8 e6       	ldi	r30, 0x68	; 104
    19fe:	f1 e0       	ldi	r31, 0x01	; 1
    1a00:	8e 0e       	add	r8, r30
    1a02:	9f 1e       	adc	r9, r31
			printLCD2(path[i],path[i+1],compass);
    1a04:	f6 01       	movw	r30, r12
    1a06:	ee 0f       	add	r30, r30
    1a08:	ff 1f       	adc	r31, r31
    1a0a:	e7 51       	subi	r30, 0x17	; 23
    1a0c:	fa 4f       	sbci	r31, 0xFA	; 250
    1a0e:	80 81       	ld	r24, Z
    1a10:	91 81       	ldd	r25, Z+1	; 0x01
    1a12:	f7 01       	movw	r30, r14
    1a14:	ee 0f       	add	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	e7 51       	subi	r30, 0x17	; 23
    1a1a:	fa 4f       	sbci	r31, 0xFA	; 250
    1a1c:	60 81       	ld	r22, Z
    1a1e:	71 81       	ldd	r23, Z+1	; 0x01
    1a20:	a4 01       	movw	r20, r8
    1a22:	0e 94 ba 0a 	call	0x1574	; 0x1574 <printLCD2>

			//Check for obstacle

			lcd_print(2,13,3,1);
    1a26:	82 e0       	ldi	r24, 0x02	; 2
    1a28:	6d e0       	ldi	r22, 0x0D	; 13
    1a2a:	43 e0       	ldi	r20, 0x03	; 3
    1a2c:	50 e0       	ldi	r21, 0x00	; 0
    1a2e:	21 e0       	ldi	r18, 0x01	; 1
    1a30:	30 e0       	ldi	r19, 0x00	; 0
    1a32:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
				Sharp sensor and obstacle is less than that distance, then it knows that there is an obstacle along
				that edge when it in the current node. So it doesn't follow the current path. Instead It finds the
				shortest path neglecting that edge from the current node to the destination node.
			*/

			if (distance_Sharp < path[i+2]*8 ) {
    1a36:	f6 01       	movw	r30, r12
    1a38:	ee 0f       	add	r30, r30
    1a3a:	ff 1f       	adc	r31, r31
    1a3c:	e3 51       	subi	r30, 0x13	; 19
    1a3e:	fa 4f       	sbci	r31, 0xFA	; 250
    1a40:	80 81       	ld	r24, Z
    1a42:	91 81       	ldd	r25, Z+1	; 0x01
    1a44:	73 e0       	ldi	r23, 0x03	; 3
    1a46:	88 0f       	add	r24, r24
    1a48:	99 1f       	adc	r25, r25
    1a4a:	7a 95       	dec	r23
    1a4c:	e1 f7       	brne	.-8      	; 0x1a46 <main+0x368>
    1a4e:	20 91 e7 05 	lds	r18, 0x05E7
    1a52:	30 91 e8 05 	lds	r19, 0x05E8
    1a56:	28 17       	cp	r18, r24
    1a58:	39 07       	cpc	r19, r25
    1a5a:	0c f0       	brlt	.+2      	; 0x1a5e <main+0x380>
    1a5c:	61 c0       	rjmp	.+194    	; 0x1b20 <main+0x442>
    1a5e:	a4 01       	movw	r20, r8

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1a60:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    1a62:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
    1a64:	82 b9       	out	0x02, r24	; 2
    1a66:	80 e1       	ldi	r24, 0x10	; 16
    1a68:	97 e2       	ldi	r25, 0x27	; 39
    1a6a:	e0 e7       	ldi	r30, 0x70	; 112
    1a6c:	f1 e0       	ldi	r31, 0x01	; 1
    1a6e:	31 97       	sbiw	r30, 0x01	; 1
    1a70:	f1 f7       	brne	.-4      	; 0x1a6e <main+0x390>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a72:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a74:	d1 f7       	brne	.-12     	; 0x1a6a <main+0x38c>
				stop();
				_delay_ms(1000);
				printLCD2(path[i],path[i+1],compass);
    1a76:	86 01       	movw	r16, r12
    1a78:	00 0f       	add	r16, r16
    1a7a:	11 1f       	adc	r17, r17
    1a7c:	07 51       	subi	r16, 0x17	; 23
    1a7e:	1a 4f       	sbci	r17, 0xFA	; 250
    1a80:	f8 01       	movw	r30, r16
    1a82:	80 81       	ld	r24, Z
    1a84:	91 81       	ldd	r25, Z+1	; 0x01
    1a86:	ee 0c       	add	r14, r14
    1a88:	ff 1c       	adc	r15, r15
    1a8a:	29 ee       	ldi	r18, 0xE9	; 233
    1a8c:	35 e0       	ldi	r19, 0x05	; 5
    1a8e:	e2 0e       	add	r14, r18
    1a90:	f3 1e       	adc	r15, r19
    1a92:	f7 01       	movw	r30, r14
    1a94:	60 81       	ld	r22, Z
    1a96:	71 81       	ldd	r23, Z+1	; 0x01
    1a98:	0e 94 ba 0a 	call	0x1574	; 0x1574 <printLCD2>
				addObstacle(path[i],path[i+3]);
    1a9c:	f8 01       	movw	r30, r16
    1a9e:	00 81       	ld	r16, Z
    1aa0:	11 81       	ldd	r17, Z+1	; 0x01
    1aa2:	f6 01       	movw	r30, r12
    1aa4:	ee 0f       	add	r30, r30
    1aa6:	ff 1f       	adc	r31, r31
    1aa8:	e1 51       	subi	r30, 0x11	; 17
    1aaa:	fa 4f       	sbci	r31, 0xFA	; 250
    1aac:	01 90       	ld	r0, Z+
    1aae:	f0 81       	ld	r31, Z
    1ab0:	e0 2d       	mov	r30, r0
* Example Call:		addObstacle(1,24);
*/

void addObstacle(int a, int b) { //vertice numbers, the edge between whose is an obstacle
	int i; //for iteration
	a--; b--;
    1ab2:	01 50       	subi	r16, 0x01	; 1
    1ab4:	10 40       	sbci	r17, 0x00	; 0
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	ad e3       	ldi	r26, 0x3D	; 61
    1aba:	b6 e0       	ldi	r27, 0x06	; 6
	for (i = 0; i < 63; i++) {
		if ((edgeList[i].endA==a && edgeList[i].endB==b) || (edgeList[i].endA==b && edgeList[i].endB==a))
    1abc:	14 96       	adiw	r26, 0x04	; 4
    1abe:	2d 91       	ld	r18, X+
    1ac0:	3c 91       	ld	r19, X
    1ac2:	15 97       	sbiw	r26, 0x05	; 5
    1ac4:	20 17       	cp	r18, r16
    1ac6:	31 07       	cpc	r19, r17
    1ac8:	39 f4       	brne	.+14     	; 0x1ad8 <main+0x3fa>
    1aca:	16 96       	adiw	r26, 0x06	; 6
    1acc:	8d 91       	ld	r24, X+
    1ace:	9c 91       	ld	r25, X
    1ad0:	17 97       	sbiw	r26, 0x07	; 7
    1ad2:	8e 17       	cp	r24, r30
    1ad4:	9f 07       	cpc	r25, r31
    1ad6:	51 f0       	breq	.+20     	; 0x1aec <main+0x40e>
    1ad8:	2e 17       	cp	r18, r30
    1ada:	3f 07       	cpc	r19, r31
    1adc:	61 f4       	brne	.+24     	; 0x1af6 <main+0x418>
    1ade:	16 96       	adiw	r26, 0x06	; 6
    1ae0:	8d 91       	ld	r24, X+
    1ae2:	9c 91       	ld	r25, X
    1ae4:	17 97       	sbiw	r26, 0x07	; 7
    1ae6:	80 17       	cp	r24, r16
    1ae8:	91 07       	cpc	r25, r17
    1aea:	29 f4       	brne	.+10     	; 0x1af6 <main+0x418>
			edgeList[i].obstacle = 1;
    1aec:	21 e0       	ldi	r18, 0x01	; 1
    1aee:	30 e0       	ldi	r19, 0x00	; 0
    1af0:	11 96       	adiw	r26, 0x01	; 1
    1af2:	3c 93       	st	X, r19
    1af4:	2e 93       	st	-X, r18
    1af6:	1a 96       	adiw	r26, 0x0a	; 10
*/

void addObstacle(int a, int b) { //vertice numbers, the edge between whose is an obstacle
	int i; //for iteration
	a--; b--;
	for (i = 0; i < 63; i++) {
    1af8:	38 e0       	ldi	r19, 0x08	; 8
    1afa:	a3 3b       	cpi	r26, 0xB3	; 179
    1afc:	b3 07       	cpc	r27, r19
    1afe:	f1 f6       	brne	.-68     	; 0x1abc <main+0x3de>
				last = path[i];
    1b00:	cc 0c       	add	r12, r12
    1b02:	dd 1c       	adc	r13, r13
    1b04:	89 ee       	ldi	r24, 0xE9	; 233
    1b06:	95 e0       	ldi	r25, 0x05	; 5
    1b08:	c8 0e       	add	r12, r24
    1b0a:	d9 1e       	adc	r13, r25
    1b0c:	f6 01       	movw	r30, r12
    1b0e:	20 80       	ld	r2, Z
    1b10:	31 80       	ldd	r3, Z+1	; 0x01
				ii--;
    1b12:	08 94       	sec
    1b14:	61 08       	sbc	r6, r1
    1b16:	71 08       	sbc	r7, r1
    1b18:	81 e0       	ldi	r24, 0x01	; 1
    1b1a:	e8 2e       	mov	r14, r24
    1b1c:	f1 2c       	mov	r15, r1
    1b1e:	f2 c0       	rjmp	.+484    	; 0x1d04 <main+0x626>
				break;
			}

			//Get out of the node
			
			lcd_print(2,13,4,1);
    1b20:	82 e0       	ldi	r24, 0x02	; 2
    1b22:	6d e0       	ldi	r22, 0x0D	; 13
    1b24:	44 e0       	ldi	r20, 0x04	; 4
    1b26:	50 e0       	ldi	r21, 0x00	; 0
    1b28:	21 e0       	ldi	r18, 0x01	; 1
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
			distanceShaft = 0;
    1b30:	10 92 e3 05 	sts	0x05E3, r1
    1b34:	10 92 e4 05 	sts	0x05E4, r1
    1b38:	10 92 e5 05 	sts	0x05E5, r1
    1b3c:	10 92 e6 05 	sts	0x05E6, r1

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1b40:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    1b42:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    1b44:	86 60       	ori	r24, 0x06	; 6
 PORTA = PortARestore; 		// executing the command
    1b46:	82 b9       	out	0x02, r24	; 2
			forward();
			reqd = 12;
			ShaftCountLeft = ShaftCountRight = 0;
    1b48:	10 92 df 05 	sts	0x05DF, r1
    1b4c:	10 92 e0 05 	sts	0x05E0, r1
    1b50:	10 92 e1 05 	sts	0x05E1, r1
    1b54:	10 92 e2 05 	sts	0x05E2, r1
    1b58:	80 91 df 05 	lds	r24, 0x05DF
    1b5c:	90 91 e0 05 	lds	r25, 0x05E0
    1b60:	a0 91 e1 05 	lds	r26, 0x05E1
    1b64:	b0 91 e2 05 	lds	r27, 0x05E2
    1b68:	80 93 db 05 	sts	0x05DB, r24
    1b6c:	90 93 dc 05 	sts	0x05DC, r25
    1b70:	a0 93 dd 05 	sts	0x05DD, r26
    1b74:	b0 93 de 05 	sts	0x05DE, r27
			while (1) {
				if ( (ShaftCountLeft > reqd) | (ShaftCountRight > reqd) )
    1b78:	80 91 db 05 	lds	r24, 0x05DB
    1b7c:	90 91 dc 05 	lds	r25, 0x05DC
    1b80:	a0 91 dd 05 	lds	r26, 0x05DD
    1b84:	b0 91 de 05 	lds	r27, 0x05DE
    1b88:	20 91 df 05 	lds	r18, 0x05DF
    1b8c:	30 91 e0 05 	lds	r19, 0x05E0
    1b90:	40 91 e1 05 	lds	r20, 0x05E1
    1b94:	50 91 e2 05 	lds	r21, 0x05E2
    1b98:	0d 97       	sbiw	r24, 0x0d	; 13
    1b9a:	a1 05       	cpc	r26, r1
    1b9c:	b1 05       	cpc	r27, r1
    1b9e:	68 f5       	brcc	.+90     	; 0x1bfa <main+0x51c>
    1ba0:	2d 30       	cpi	r18, 0x0D	; 13
    1ba2:	31 05       	cpc	r19, r1
    1ba4:	41 05       	cpc	r20, r1
    1ba6:	51 05       	cpc	r21, r1
    1ba8:	40 f5       	brcc	.+80     	; 0x1bfa <main+0x51c>
					break;
				djFlag = printNsetDJ();
    1baa:	0e 94 37 0b 	call	0x166e	; 0x166e <printNsetDJ>
				switch (djFlag) {
    1bae:	8b 30       	cpi	r24, 0x0B	; 11
    1bb0:	91 05       	cpc	r25, r1
    1bb2:	b1 f0       	breq	.+44     	; 0x1be0 <main+0x502>
    1bb4:	8c 30       	cpi	r24, 0x0C	; 12
    1bb6:	91 05       	cpc	r25, r1
    1bb8:	4c f4       	brge	.+18     	; 0x1bcc <main+0x4ee>
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	91 05       	cpc	r25, r1
    1bbe:	81 f0       	breq	.+32     	; 0x1be0 <main+0x502>
    1bc0:	8a 30       	cpi	r24, 0x0A	; 10
    1bc2:	91 05       	cpc	r25, r1
    1bc4:	a9 f0       	breq	.+42     	; 0x1bf0 <main+0x512>
    1bc6:	89 2b       	or	r24, r25
    1bc8:	99 f0       	breq	.+38     	; 0x1bf0 <main+0x512>
    1bca:	d6 cf       	rjmp	.-84     	; 0x1b78 <main+0x49a>
    1bcc:	8e 36       	cpi	r24, 0x6E	; 110
    1bce:	91 05       	cpc	r25, r1
    1bd0:	61 f0       	breq	.+24     	; 0x1bea <main+0x50c>
    1bd2:	8f 36       	cpi	r24, 0x6F	; 111
    1bd4:	91 05       	cpc	r25, r1
    1bd6:	61 f0       	breq	.+24     	; 0x1bf0 <main+0x512>
    1bd8:	84 36       	cpi	r24, 0x64	; 100
    1bda:	91 05       	cpc	r25, r1
    1bdc:	69 f6       	brne	.-102    	; 0x1b78 <main+0x49a>
    1bde:	05 c0       	rjmp	.+10     	; 0x1bea <main+0x50c>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1be0:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    1be4:	10 92 2a 01 	sts	0x012A, r1
    1be8:	c7 cf       	rjmp	.-114    	; 0x1b78 <main+0x49a>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1bea:	10 92 28 01 	sts	0x0128, r1
    1bee:	02 c0       	rjmp	.+4      	; 0x1bf4 <main+0x516>
	OCR5BL = (unsigned char) right;
    1bf0:	50 92 28 01 	sts	0x0128, r5
    1bf4:	50 92 2a 01 	sts	0x012A, r5
    1bf8:	bf cf       	rjmp	.-130    	; 0x1b78 <main+0x49a>
				}
			}

			//Follow the line, if you reach a node, break

			lcd_print(2,13,5,1);
    1bfa:	82 e0       	ldi	r24, 0x02	; 2
    1bfc:	6d e0       	ldi	r22, 0x0D	; 13
    1bfe:	45 e0       	ldi	r20, 0x05	; 5
    1c00:	50 e0       	ldi	r21, 0x00	; 0
    1c02:	21 e0       	ldi	r18, 0x01	; 1
    1c04:	30 e0       	ldi	r19, 0x00	; 0
    1c06:	0e 94 8b 01 	call	0x316	; 0x316 <lcd_print>
			while (1) {
				djFlag = printNsetDJ();
    1c0a:	0e 94 37 0b 	call	0x166e	; 0x166e <printNsetDJ>
				if (djFlag == 11 || djFlag == 110 || djFlag==111) break;	//Node Reached Condition
    1c0e:	8b 30       	cpi	r24, 0x0B	; 11
    1c10:	91 05       	cpc	r25, r1
    1c12:	49 f1       	breq	.+82     	; 0x1c66 <main+0x588>
    1c14:	8e 36       	cpi	r24, 0x6E	; 110
    1c16:	91 05       	cpc	r25, r1
    1c18:	31 f1       	breq	.+76     	; 0x1c66 <main+0x588>
    1c1a:	8f 36       	cpi	r24, 0x6F	; 111
    1c1c:	91 05       	cpc	r25, r1
    1c1e:	19 f1       	breq	.+70     	; 0x1c66 <main+0x588>
				switch(djFlag) {
    1c20:	81 30       	cpi	r24, 0x01	; 1
    1c22:	91 05       	cpc	r25, r1
    1c24:	69 f0       	breq	.+26     	; 0x1c40 <main+0x562>
    1c26:	82 30       	cpi	r24, 0x02	; 2
    1c28:	91 05       	cpc	r25, r1
    1c2a:	1c f4       	brge	.+6      	; 0x1c32 <main+0x554>
    1c2c:	89 2b       	or	r24, r25
    1c2e:	69 f0       	breq	.+26     	; 0x1c4a <main+0x56c>
    1c30:	ec cf       	rjmp	.-40     	; 0x1c0a <main+0x52c>
    1c32:	8a 30       	cpi	r24, 0x0A	; 10
    1c34:	91 05       	cpc	r25, r1
    1c36:	49 f0       	breq	.+18     	; 0x1c4a <main+0x56c>
    1c38:	84 36       	cpi	r24, 0x64	; 100
    1c3a:	91 05       	cpc	r25, r1
    1c3c:	31 f7       	brne	.-52     	; 0x1c0a <main+0x52c>
    1c3e:	0e c0       	rjmp	.+28     	; 0x1c5c <main+0x57e>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1c40:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    1c44:	10 92 2a 01 	sts	0x012A, r1
    1c48:	e0 cf       	rjmp	.-64     	; 0x1c0a <main+0x52c>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1c4a:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    1c4e:	50 92 2a 01 	sts	0x012A, r5

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1c52:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    1c54:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    1c56:	86 60       	ori	r24, 0x06	; 6
 PORTA = PortARestore; 		// executing the command
    1c58:	82 b9       	out	0x02, r24	; 2
    1c5a:	d7 cf       	rjmp	.-82     	; 0x1c0a <main+0x52c>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1c5c:	10 92 28 01 	sts	0x0128, r1
	OCR5BL = (unsigned char) right;
    1c60:	50 92 2a 01 	sts	0x012A, r5
    1c64:	d2 cf       	rjmp	.-92     	; 0x1c0a <main+0x52c>

void velocity(unsigned char left,unsigned char right)	//Set PWM Velocity
{
	//lcd_print(2,1,left,3);
	//lcd_print(2,5,right,3);
	OCR5AL = (unsigned char) left;
    1c66:	50 92 28 01 	sts	0x0128, r5
	OCR5BL = (unsigned char) right;
    1c6a:	50 92 2a 01 	sts	0x012A, r5
		1st Element : MNP
		2nd Element : Angle to be rotated
		3rd Element	: Distance to be moved
		This pattern follows
		*/
		for (i = 0; i < pathLen - 1; i+=3) {			//Access every third element in array i.e. MNP
    1c6e:	23 e0       	ldi	r18, 0x03	; 3
    1c70:	30 e0       	ldi	r19, 0x00	; 0
    1c72:	c2 0e       	add	r12, r18
    1c74:	d3 1e       	adc	r13, r19
    1c76:	ee 24       	eor	r14, r14
    1c78:	ff 24       	eor	r15, r15
    1c7a:	80 91 c0 08 	lds	r24, 0x08C0
    1c7e:	90 91 c1 08 	lds	r25, 0x08C1
    1c82:	01 97       	sbiw	r24, 0x01	; 1
    1c84:	c8 16       	cp	r12, r24
    1c86:	d9 06       	cpc	r13, r25
    1c88:	0c f4       	brge	.+2      	; 0x1c8c <main+0x5ae>
    1c8a:	93 cd       	rjmp	.-1242   	; 0x17b2 <main+0xd4>
    1c8c:	97 01       	movw	r18, r14
			}
			velocity(MAX_VEL,MAX_VEL);
			if (shFlag == 1) break;					//Node Reached and there is obstacle in the next node
		}
		//ADD Comment HERE
		if (shFlag == 1) continue;
    1c8e:	41 e0       	ldi	r20, 0x01	; 1
    1c90:	e4 16       	cp	r14, r20
    1c92:	f1 04       	cpc	r15, r1
    1c94:	09 f4       	brne	.+2      	; 0x1c98 <main+0x5ba>
    1c96:	36 c0       	rjmp	.+108    	; 0x1d04 <main+0x626>
		last = path[i];								//Stores current position
    1c98:	cc 0c       	add	r12, r12
    1c9a:	dd 1c       	adc	r13, r13
    1c9c:	89 ee       	ldi	r24, 0xE9	; 233
    1c9e:	95 e0       	ldi	r25, 0x05	; 5
    1ca0:	c8 0e       	add	r12, r24
    1ca2:	d9 1e       	adc	r13, r25
    1ca4:	f6 01       	movw	r30, r12
    1ca6:	20 80       	ld	r2, Z
    1ca8:	31 80       	ldd	r3, Z+1	; 0x01

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;
 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1caa:	82 b1       	in	r24, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    1cac:	80 7f       	andi	r24, 0xF0	; 240
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
    1cae:	82 b9       	out	0x02, r24	; 2
		stop();
		//Node Detected 500 milli seconds beep
		if (ii != 9) beep();
    1cb0:	f9 e0       	ldi	r31, 0x09	; 9
    1cb2:	6f 16       	cp	r6, r31
    1cb4:	71 04       	cpc	r7, r1
    1cb6:	99 f0       	breq	.+38     	; 0x1cde <main+0x600>
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
    1cb8:	48 b8       	out	0x08, r4	; 8
    1cba:	88 e8       	ldi	r24, 0x88	; 136
    1cbc:	93 e1       	ldi	r25, 0x13	; 19
    1cbe:	e0 e7       	ldi	r30, 0x70	; 112
    1cc0:	f1 e0       	ldi	r31, 0x01	; 1
    1cc2:	31 97       	sbiw	r30, 0x01	; 1
    1cc4:	f1 f7       	brne	.-4      	; 0x1cc2 <main+0x5e4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cc6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cc8:	d1 f7       	brne	.-12     	; 0x1cbe <main+0x5e0>
* Example Call:		buzzer_off()
*/

void buzzer_off(void)
{
	PORTC= 0x00;
    1cca:	18 b8       	out	0x08, r1	; 8
    1ccc:	88 e8       	ldi	r24, 0x88	; 136
    1cce:	93 e1       	ldi	r25, 0x13	; 19
    1cd0:	e0 e7       	ldi	r30, 0x70	; 112
    1cd2:	f1 e0       	ldi	r31, 0x01	; 1
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	f1 f7       	brne	.-4      	; 0x1cd4 <main+0x5f6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cd8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cda:	d1 f7       	brne	.-12     	; 0x1cd0 <main+0x5f2>
    1cdc:	12 c0       	rjmp	.+36     	; 0x1d02 <main+0x624>
*/

void buzzer_on(void)
{
	
	PORTC= 0x08;   // pin 3 to high 0000 1000
    1cde:	48 b8       	out	0x08, r4	; 8
    1ce0:	80 e6       	ldi	r24, 0x60	; 96
    1ce2:	9a ee       	ldi	r25, 0xEA	; 234
    1ce4:	e0 e7       	ldi	r30, 0x70	; 112
    1ce6:	f1 e0       	ldi	r31, 0x01	; 1
    1ce8:	31 97       	sbiw	r30, 0x01	; 1
    1cea:	f1 f7       	brne	.-4      	; 0x1ce8 <main+0x60a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cee:	d1 f7       	brne	.-12     	; 0x1ce4 <main+0x606>
* Example Call:		buzzer_off()
*/

void buzzer_off(void)
{
	PORTC= 0x00;
    1cf0:	18 b8       	out	0x08, r1	; 8
    1cf2:	80 e6       	ldi	r24, 0x60	; 96
    1cf4:	9a ee       	ldi	r25, 0xEA	; 234
    1cf6:	e0 e7       	ldi	r30, 0x70	; 112
    1cf8:	f1 e0       	ldi	r31, 0x01	; 1
    1cfa:	31 97       	sbiw	r30, 0x01	; 1
    1cfc:	f1 f7       	brne	.-4      	; 0x1cfa <main+0x61c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cfe:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d00:	d1 f7       	brne	.-12     	; 0x1cf6 <main+0x618>
    1d02:	79 01       	movw	r14, r18
	init_devices();
	init_graph();
	lcd_set_4bit();
	lcd_init();
	beep();//Beep
	for (ii = 1; ii < 10; ii++) {
    1d04:	08 94       	sec
    1d06:	61 1c       	adc	r6, r1
    1d08:	71 1c       	adc	r7, r1
    1d0a:	2a e0       	ldi	r18, 0x0A	; 10
    1d0c:	62 16       	cp	r6, r18
    1d0e:	71 04       	cpc	r7, r1
    1d10:	0c f4       	brge	.+2      	; 0x1d14 <main+0x636>
    1d12:	33 cd       	rjmp	.-1434   	; 0x177a <main+0x9c>
			_delay_ms(6000);
			buzzer_off();
			_delay_ms(6000);
		}
	}
}
    1d14:	80 e0       	ldi	r24, 0x00	; 0
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	64 96       	adiw	r28, 0x14	; 20
    1d1a:	0f b6       	in	r0, 0x3f	; 63
    1d1c:	f8 94       	cli
    1d1e:	de bf       	out	0x3e, r29	; 62
    1d20:	0f be       	out	0x3f, r0	; 63
    1d22:	cd bf       	out	0x3d, r28	; 61
    1d24:	cf 91       	pop	r28
    1d26:	df 91       	pop	r29
    1d28:	1f 91       	pop	r17
    1d2a:	0f 91       	pop	r16
    1d2c:	ff 90       	pop	r15
    1d2e:	ef 90       	pop	r14
    1d30:	df 90       	pop	r13
    1d32:	cf 90       	pop	r12
    1d34:	bf 90       	pop	r11
    1d36:	af 90       	pop	r10
    1d38:	9f 90       	pop	r9
    1d3a:	8f 90       	pop	r8
    1d3c:	7f 90       	pop	r7
    1d3e:	6f 90       	pop	r6
    1d40:	5f 90       	pop	r5
    1d42:	4f 90       	pop	r4
    1d44:	3f 90       	pop	r3
    1d46:	2f 90       	pop	r2
    1d48:	08 95       	ret

00001d4a <__fixunssfsi>:
    1d4a:	ef 92       	push	r14
    1d4c:	ff 92       	push	r15
    1d4e:	0f 93       	push	r16
    1d50:	1f 93       	push	r17
    1d52:	7b 01       	movw	r14, r22
    1d54:	8c 01       	movw	r16, r24
    1d56:	20 e0       	ldi	r18, 0x00	; 0
    1d58:	30 e0       	ldi	r19, 0x00	; 0
    1d5a:	40 e0       	ldi	r20, 0x00	; 0
    1d5c:	5f e4       	ldi	r21, 0x4F	; 79
    1d5e:	0e 94 21 12 	call	0x2442	; 0x2442 <__gesf2>
    1d62:	88 23       	and	r24, r24
    1d64:	8c f0       	brlt	.+34     	; 0x1d88 <__fixunssfsi+0x3e>
    1d66:	c8 01       	movw	r24, r16
    1d68:	b7 01       	movw	r22, r14
    1d6a:	20 e0       	ldi	r18, 0x00	; 0
    1d6c:	30 e0       	ldi	r19, 0x00	; 0
    1d6e:	40 e0       	ldi	r20, 0x00	; 0
    1d70:	5f e4       	ldi	r21, 0x4F	; 79
    1d72:	0e 94 1d 10 	call	0x203a	; 0x203a <__subsf3>
    1d76:	0e 94 af 12 	call	0x255e	; 0x255e <__fixsfsi>
    1d7a:	9b 01       	movw	r18, r22
    1d7c:	ac 01       	movw	r20, r24
    1d7e:	20 50       	subi	r18, 0x00	; 0
    1d80:	30 40       	sbci	r19, 0x00	; 0
    1d82:	40 40       	sbci	r20, 0x00	; 0
    1d84:	50 48       	sbci	r21, 0x80	; 128
    1d86:	06 c0       	rjmp	.+12     	; 0x1d94 <__fixunssfsi+0x4a>
    1d88:	c8 01       	movw	r24, r16
    1d8a:	b7 01       	movw	r22, r14
    1d8c:	0e 94 af 12 	call	0x255e	; 0x255e <__fixsfsi>
    1d90:	9b 01       	movw	r18, r22
    1d92:	ac 01       	movw	r20, r24
    1d94:	b9 01       	movw	r22, r18
    1d96:	ca 01       	movw	r24, r20
    1d98:	1f 91       	pop	r17
    1d9a:	0f 91       	pop	r16
    1d9c:	ff 90       	pop	r15
    1d9e:	ef 90       	pop	r14
    1da0:	08 95       	ret

00001da2 <_fpadd_parts>:
    1da2:	a0 e0       	ldi	r26, 0x00	; 0
    1da4:	b0 e0       	ldi	r27, 0x00	; 0
    1da6:	e7 ed       	ldi	r30, 0xD7	; 215
    1da8:	fe e0       	ldi	r31, 0x0E	; 14
    1daa:	0c 94 98 15 	jmp	0x2b30	; 0x2b30 <__prologue_saves__>
    1dae:	dc 01       	movw	r26, r24
    1db0:	2b 01       	movw	r4, r22
    1db2:	fa 01       	movw	r30, r20
    1db4:	9c 91       	ld	r25, X
    1db6:	92 30       	cpi	r25, 0x02	; 2
    1db8:	08 f4       	brcc	.+2      	; 0x1dbc <_fpadd_parts+0x1a>
    1dba:	39 c1       	rjmp	.+626    	; 0x202e <_fpadd_parts+0x28c>
    1dbc:	eb 01       	movw	r28, r22
    1dbe:	88 81       	ld	r24, Y
    1dc0:	82 30       	cpi	r24, 0x02	; 2
    1dc2:	08 f4       	brcc	.+2      	; 0x1dc6 <_fpadd_parts+0x24>
    1dc4:	33 c1       	rjmp	.+614    	; 0x202c <_fpadd_parts+0x28a>
    1dc6:	94 30       	cpi	r25, 0x04	; 4
    1dc8:	69 f4       	brne	.+26     	; 0x1de4 <_fpadd_parts+0x42>
    1dca:	84 30       	cpi	r24, 0x04	; 4
    1dcc:	09 f0       	breq	.+2      	; 0x1dd0 <_fpadd_parts+0x2e>
    1dce:	2f c1       	rjmp	.+606    	; 0x202e <_fpadd_parts+0x28c>
    1dd0:	11 96       	adiw	r26, 0x01	; 1
    1dd2:	9c 91       	ld	r25, X
    1dd4:	11 97       	sbiw	r26, 0x01	; 1
    1dd6:	89 81       	ldd	r24, Y+1	; 0x01
    1dd8:	98 17       	cp	r25, r24
    1dda:	09 f4       	brne	.+2      	; 0x1dde <_fpadd_parts+0x3c>
    1ddc:	28 c1       	rjmp	.+592    	; 0x202e <_fpadd_parts+0x28c>
    1dde:	a0 ed       	ldi	r26, 0xD0	; 208
    1de0:	b4 e0       	ldi	r27, 0x04	; 4
    1de2:	25 c1       	rjmp	.+586    	; 0x202e <_fpadd_parts+0x28c>
    1de4:	84 30       	cpi	r24, 0x04	; 4
    1de6:	09 f4       	brne	.+2      	; 0x1dea <_fpadd_parts+0x48>
    1de8:	21 c1       	rjmp	.+578    	; 0x202c <_fpadd_parts+0x28a>
    1dea:	82 30       	cpi	r24, 0x02	; 2
    1dec:	a9 f4       	brne	.+42     	; 0x1e18 <_fpadd_parts+0x76>
    1dee:	92 30       	cpi	r25, 0x02	; 2
    1df0:	09 f0       	breq	.+2      	; 0x1df4 <_fpadd_parts+0x52>
    1df2:	1d c1       	rjmp	.+570    	; 0x202e <_fpadd_parts+0x28c>
    1df4:	9a 01       	movw	r18, r20
    1df6:	ad 01       	movw	r20, r26
    1df8:	88 e0       	ldi	r24, 0x08	; 8
    1dfa:	ea 01       	movw	r28, r20
    1dfc:	09 90       	ld	r0, Y+
    1dfe:	ae 01       	movw	r20, r28
    1e00:	e9 01       	movw	r28, r18
    1e02:	09 92       	st	Y+, r0
    1e04:	9e 01       	movw	r18, r28
    1e06:	81 50       	subi	r24, 0x01	; 1
    1e08:	c1 f7       	brne	.-16     	; 0x1dfa <_fpadd_parts+0x58>
    1e0a:	e2 01       	movw	r28, r4
    1e0c:	89 81       	ldd	r24, Y+1	; 0x01
    1e0e:	11 96       	adiw	r26, 0x01	; 1
    1e10:	9c 91       	ld	r25, X
    1e12:	89 23       	and	r24, r25
    1e14:	81 83       	std	Z+1, r24	; 0x01
    1e16:	08 c1       	rjmp	.+528    	; 0x2028 <_fpadd_parts+0x286>
    1e18:	92 30       	cpi	r25, 0x02	; 2
    1e1a:	09 f4       	brne	.+2      	; 0x1e1e <_fpadd_parts+0x7c>
    1e1c:	07 c1       	rjmp	.+526    	; 0x202c <_fpadd_parts+0x28a>
    1e1e:	12 96       	adiw	r26, 0x02	; 2
    1e20:	2d 90       	ld	r2, X+
    1e22:	3c 90       	ld	r3, X
    1e24:	13 97       	sbiw	r26, 0x03	; 3
    1e26:	eb 01       	movw	r28, r22
    1e28:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2c:	14 96       	adiw	r26, 0x04	; 4
    1e2e:	ad 90       	ld	r10, X+
    1e30:	bd 90       	ld	r11, X+
    1e32:	cd 90       	ld	r12, X+
    1e34:	dc 90       	ld	r13, X
    1e36:	17 97       	sbiw	r26, 0x07	; 7
    1e38:	ec 80       	ldd	r14, Y+4	; 0x04
    1e3a:	fd 80       	ldd	r15, Y+5	; 0x05
    1e3c:	0e 81       	ldd	r16, Y+6	; 0x06
    1e3e:	1f 81       	ldd	r17, Y+7	; 0x07
    1e40:	91 01       	movw	r18, r2
    1e42:	28 1b       	sub	r18, r24
    1e44:	39 0b       	sbc	r19, r25
    1e46:	b9 01       	movw	r22, r18
    1e48:	37 ff       	sbrs	r19, 7
    1e4a:	04 c0       	rjmp	.+8      	; 0x1e54 <_fpadd_parts+0xb2>
    1e4c:	66 27       	eor	r22, r22
    1e4e:	77 27       	eor	r23, r23
    1e50:	62 1b       	sub	r22, r18
    1e52:	73 0b       	sbc	r23, r19
    1e54:	60 32       	cpi	r22, 0x20	; 32
    1e56:	71 05       	cpc	r23, r1
    1e58:	0c f0       	brlt	.+2      	; 0x1e5c <_fpadd_parts+0xba>
    1e5a:	61 c0       	rjmp	.+194    	; 0x1f1e <_fpadd_parts+0x17c>
    1e5c:	12 16       	cp	r1, r18
    1e5e:	13 06       	cpc	r1, r19
    1e60:	6c f5       	brge	.+90     	; 0x1ebc <_fpadd_parts+0x11a>
    1e62:	37 01       	movw	r6, r14
    1e64:	48 01       	movw	r8, r16
    1e66:	06 2e       	mov	r0, r22
    1e68:	04 c0       	rjmp	.+8      	; 0x1e72 <_fpadd_parts+0xd0>
    1e6a:	96 94       	lsr	r9
    1e6c:	87 94       	ror	r8
    1e6e:	77 94       	ror	r7
    1e70:	67 94       	ror	r6
    1e72:	0a 94       	dec	r0
    1e74:	d2 f7       	brpl	.-12     	; 0x1e6a <_fpadd_parts+0xc8>
    1e76:	21 e0       	ldi	r18, 0x01	; 1
    1e78:	30 e0       	ldi	r19, 0x00	; 0
    1e7a:	40 e0       	ldi	r20, 0x00	; 0
    1e7c:	50 e0       	ldi	r21, 0x00	; 0
    1e7e:	04 c0       	rjmp	.+8      	; 0x1e88 <_fpadd_parts+0xe6>
    1e80:	22 0f       	add	r18, r18
    1e82:	33 1f       	adc	r19, r19
    1e84:	44 1f       	adc	r20, r20
    1e86:	55 1f       	adc	r21, r21
    1e88:	6a 95       	dec	r22
    1e8a:	d2 f7       	brpl	.-12     	; 0x1e80 <_fpadd_parts+0xde>
    1e8c:	21 50       	subi	r18, 0x01	; 1
    1e8e:	30 40       	sbci	r19, 0x00	; 0
    1e90:	40 40       	sbci	r20, 0x00	; 0
    1e92:	50 40       	sbci	r21, 0x00	; 0
    1e94:	2e 21       	and	r18, r14
    1e96:	3f 21       	and	r19, r15
    1e98:	40 23       	and	r20, r16
    1e9a:	51 23       	and	r21, r17
    1e9c:	21 15       	cp	r18, r1
    1e9e:	31 05       	cpc	r19, r1
    1ea0:	41 05       	cpc	r20, r1
    1ea2:	51 05       	cpc	r21, r1
    1ea4:	21 f0       	breq	.+8      	; 0x1eae <_fpadd_parts+0x10c>
    1ea6:	21 e0       	ldi	r18, 0x01	; 1
    1ea8:	30 e0       	ldi	r19, 0x00	; 0
    1eaa:	40 e0       	ldi	r20, 0x00	; 0
    1eac:	50 e0       	ldi	r21, 0x00	; 0
    1eae:	79 01       	movw	r14, r18
    1eb0:	8a 01       	movw	r16, r20
    1eb2:	e6 28       	or	r14, r6
    1eb4:	f7 28       	or	r15, r7
    1eb6:	08 29       	or	r16, r8
    1eb8:	19 29       	or	r17, r9
    1eba:	3c c0       	rjmp	.+120    	; 0x1f34 <_fpadd_parts+0x192>
    1ebc:	23 2b       	or	r18, r19
    1ebe:	d1 f1       	breq	.+116    	; 0x1f34 <_fpadd_parts+0x192>
    1ec0:	26 0e       	add	r2, r22
    1ec2:	37 1e       	adc	r3, r23
    1ec4:	35 01       	movw	r6, r10
    1ec6:	46 01       	movw	r8, r12
    1ec8:	06 2e       	mov	r0, r22
    1eca:	04 c0       	rjmp	.+8      	; 0x1ed4 <_fpadd_parts+0x132>
    1ecc:	96 94       	lsr	r9
    1ece:	87 94       	ror	r8
    1ed0:	77 94       	ror	r7
    1ed2:	67 94       	ror	r6
    1ed4:	0a 94       	dec	r0
    1ed6:	d2 f7       	brpl	.-12     	; 0x1ecc <_fpadd_parts+0x12a>
    1ed8:	21 e0       	ldi	r18, 0x01	; 1
    1eda:	30 e0       	ldi	r19, 0x00	; 0
    1edc:	40 e0       	ldi	r20, 0x00	; 0
    1ede:	50 e0       	ldi	r21, 0x00	; 0
    1ee0:	04 c0       	rjmp	.+8      	; 0x1eea <_fpadd_parts+0x148>
    1ee2:	22 0f       	add	r18, r18
    1ee4:	33 1f       	adc	r19, r19
    1ee6:	44 1f       	adc	r20, r20
    1ee8:	55 1f       	adc	r21, r21
    1eea:	6a 95       	dec	r22
    1eec:	d2 f7       	brpl	.-12     	; 0x1ee2 <_fpadd_parts+0x140>
    1eee:	21 50       	subi	r18, 0x01	; 1
    1ef0:	30 40       	sbci	r19, 0x00	; 0
    1ef2:	40 40       	sbci	r20, 0x00	; 0
    1ef4:	50 40       	sbci	r21, 0x00	; 0
    1ef6:	2a 21       	and	r18, r10
    1ef8:	3b 21       	and	r19, r11
    1efa:	4c 21       	and	r20, r12
    1efc:	5d 21       	and	r21, r13
    1efe:	21 15       	cp	r18, r1
    1f00:	31 05       	cpc	r19, r1
    1f02:	41 05       	cpc	r20, r1
    1f04:	51 05       	cpc	r21, r1
    1f06:	21 f0       	breq	.+8      	; 0x1f10 <_fpadd_parts+0x16e>
    1f08:	21 e0       	ldi	r18, 0x01	; 1
    1f0a:	30 e0       	ldi	r19, 0x00	; 0
    1f0c:	40 e0       	ldi	r20, 0x00	; 0
    1f0e:	50 e0       	ldi	r21, 0x00	; 0
    1f10:	59 01       	movw	r10, r18
    1f12:	6a 01       	movw	r12, r20
    1f14:	a6 28       	or	r10, r6
    1f16:	b7 28       	or	r11, r7
    1f18:	c8 28       	or	r12, r8
    1f1a:	d9 28       	or	r13, r9
    1f1c:	0b c0       	rjmp	.+22     	; 0x1f34 <_fpadd_parts+0x192>
    1f1e:	82 15       	cp	r24, r2
    1f20:	93 05       	cpc	r25, r3
    1f22:	2c f0       	brlt	.+10     	; 0x1f2e <_fpadd_parts+0x18c>
    1f24:	1c 01       	movw	r2, r24
    1f26:	aa 24       	eor	r10, r10
    1f28:	bb 24       	eor	r11, r11
    1f2a:	65 01       	movw	r12, r10
    1f2c:	03 c0       	rjmp	.+6      	; 0x1f34 <_fpadd_parts+0x192>
    1f2e:	ee 24       	eor	r14, r14
    1f30:	ff 24       	eor	r15, r15
    1f32:	87 01       	movw	r16, r14
    1f34:	11 96       	adiw	r26, 0x01	; 1
    1f36:	9c 91       	ld	r25, X
    1f38:	d2 01       	movw	r26, r4
    1f3a:	11 96       	adiw	r26, 0x01	; 1
    1f3c:	8c 91       	ld	r24, X
    1f3e:	98 17       	cp	r25, r24
    1f40:	09 f4       	brne	.+2      	; 0x1f44 <_fpadd_parts+0x1a2>
    1f42:	45 c0       	rjmp	.+138    	; 0x1fce <_fpadd_parts+0x22c>
    1f44:	99 23       	and	r25, r25
    1f46:	39 f0       	breq	.+14     	; 0x1f56 <_fpadd_parts+0x1b4>
    1f48:	a8 01       	movw	r20, r16
    1f4a:	97 01       	movw	r18, r14
    1f4c:	2a 19       	sub	r18, r10
    1f4e:	3b 09       	sbc	r19, r11
    1f50:	4c 09       	sbc	r20, r12
    1f52:	5d 09       	sbc	r21, r13
    1f54:	06 c0       	rjmp	.+12     	; 0x1f62 <_fpadd_parts+0x1c0>
    1f56:	a6 01       	movw	r20, r12
    1f58:	95 01       	movw	r18, r10
    1f5a:	2e 19       	sub	r18, r14
    1f5c:	3f 09       	sbc	r19, r15
    1f5e:	40 0b       	sbc	r20, r16
    1f60:	51 0b       	sbc	r21, r17
    1f62:	57 fd       	sbrc	r21, 7
    1f64:	08 c0       	rjmp	.+16     	; 0x1f76 <_fpadd_parts+0x1d4>
    1f66:	11 82       	std	Z+1, r1	; 0x01
    1f68:	33 82       	std	Z+3, r3	; 0x03
    1f6a:	22 82       	std	Z+2, r2	; 0x02
    1f6c:	24 83       	std	Z+4, r18	; 0x04
    1f6e:	35 83       	std	Z+5, r19	; 0x05
    1f70:	46 83       	std	Z+6, r20	; 0x06
    1f72:	57 83       	std	Z+7, r21	; 0x07
    1f74:	1d c0       	rjmp	.+58     	; 0x1fb0 <_fpadd_parts+0x20e>
    1f76:	81 e0       	ldi	r24, 0x01	; 1
    1f78:	81 83       	std	Z+1, r24	; 0x01
    1f7a:	33 82       	std	Z+3, r3	; 0x03
    1f7c:	22 82       	std	Z+2, r2	; 0x02
    1f7e:	88 27       	eor	r24, r24
    1f80:	99 27       	eor	r25, r25
    1f82:	dc 01       	movw	r26, r24
    1f84:	82 1b       	sub	r24, r18
    1f86:	93 0b       	sbc	r25, r19
    1f88:	a4 0b       	sbc	r26, r20
    1f8a:	b5 0b       	sbc	r27, r21
    1f8c:	84 83       	std	Z+4, r24	; 0x04
    1f8e:	95 83       	std	Z+5, r25	; 0x05
    1f90:	a6 83       	std	Z+6, r26	; 0x06
    1f92:	b7 83       	std	Z+7, r27	; 0x07
    1f94:	0d c0       	rjmp	.+26     	; 0x1fb0 <_fpadd_parts+0x20e>
    1f96:	22 0f       	add	r18, r18
    1f98:	33 1f       	adc	r19, r19
    1f9a:	44 1f       	adc	r20, r20
    1f9c:	55 1f       	adc	r21, r21
    1f9e:	24 83       	std	Z+4, r18	; 0x04
    1fa0:	35 83       	std	Z+5, r19	; 0x05
    1fa2:	46 83       	std	Z+6, r20	; 0x06
    1fa4:	57 83       	std	Z+7, r21	; 0x07
    1fa6:	82 81       	ldd	r24, Z+2	; 0x02
    1fa8:	93 81       	ldd	r25, Z+3	; 0x03
    1faa:	01 97       	sbiw	r24, 0x01	; 1
    1fac:	93 83       	std	Z+3, r25	; 0x03
    1fae:	82 83       	std	Z+2, r24	; 0x02
    1fb0:	24 81       	ldd	r18, Z+4	; 0x04
    1fb2:	35 81       	ldd	r19, Z+5	; 0x05
    1fb4:	46 81       	ldd	r20, Z+6	; 0x06
    1fb6:	57 81       	ldd	r21, Z+7	; 0x07
    1fb8:	da 01       	movw	r26, r20
    1fba:	c9 01       	movw	r24, r18
    1fbc:	01 97       	sbiw	r24, 0x01	; 1
    1fbe:	a1 09       	sbc	r26, r1
    1fc0:	b1 09       	sbc	r27, r1
    1fc2:	8f 5f       	subi	r24, 0xFF	; 255
    1fc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1fc6:	af 4f       	sbci	r26, 0xFF	; 255
    1fc8:	bf 43       	sbci	r27, 0x3F	; 63
    1fca:	28 f3       	brcs	.-54     	; 0x1f96 <_fpadd_parts+0x1f4>
    1fcc:	0b c0       	rjmp	.+22     	; 0x1fe4 <_fpadd_parts+0x242>
    1fce:	91 83       	std	Z+1, r25	; 0x01
    1fd0:	33 82       	std	Z+3, r3	; 0x03
    1fd2:	22 82       	std	Z+2, r2	; 0x02
    1fd4:	ea 0c       	add	r14, r10
    1fd6:	fb 1c       	adc	r15, r11
    1fd8:	0c 1d       	adc	r16, r12
    1fda:	1d 1d       	adc	r17, r13
    1fdc:	e4 82       	std	Z+4, r14	; 0x04
    1fde:	f5 82       	std	Z+5, r15	; 0x05
    1fe0:	06 83       	std	Z+6, r16	; 0x06
    1fe2:	17 83       	std	Z+7, r17	; 0x07
    1fe4:	83 e0       	ldi	r24, 0x03	; 3
    1fe6:	80 83       	st	Z, r24
    1fe8:	24 81       	ldd	r18, Z+4	; 0x04
    1fea:	35 81       	ldd	r19, Z+5	; 0x05
    1fec:	46 81       	ldd	r20, Z+6	; 0x06
    1fee:	57 81       	ldd	r21, Z+7	; 0x07
    1ff0:	57 ff       	sbrs	r21, 7
    1ff2:	1a c0       	rjmp	.+52     	; 0x2028 <_fpadd_parts+0x286>
    1ff4:	c9 01       	movw	r24, r18
    1ff6:	aa 27       	eor	r26, r26
    1ff8:	97 fd       	sbrc	r25, 7
    1ffa:	a0 95       	com	r26
    1ffc:	ba 2f       	mov	r27, r26
    1ffe:	81 70       	andi	r24, 0x01	; 1
    2000:	90 70       	andi	r25, 0x00	; 0
    2002:	a0 70       	andi	r26, 0x00	; 0
    2004:	b0 70       	andi	r27, 0x00	; 0
    2006:	56 95       	lsr	r21
    2008:	47 95       	ror	r20
    200a:	37 95       	ror	r19
    200c:	27 95       	ror	r18
    200e:	82 2b       	or	r24, r18
    2010:	93 2b       	or	r25, r19
    2012:	a4 2b       	or	r26, r20
    2014:	b5 2b       	or	r27, r21
    2016:	84 83       	std	Z+4, r24	; 0x04
    2018:	95 83       	std	Z+5, r25	; 0x05
    201a:	a6 83       	std	Z+6, r26	; 0x06
    201c:	b7 83       	std	Z+7, r27	; 0x07
    201e:	82 81       	ldd	r24, Z+2	; 0x02
    2020:	93 81       	ldd	r25, Z+3	; 0x03
    2022:	01 96       	adiw	r24, 0x01	; 1
    2024:	93 83       	std	Z+3, r25	; 0x03
    2026:	82 83       	std	Z+2, r24	; 0x02
    2028:	df 01       	movw	r26, r30
    202a:	01 c0       	rjmp	.+2      	; 0x202e <_fpadd_parts+0x28c>
    202c:	d2 01       	movw	r26, r4
    202e:	cd 01       	movw	r24, r26
    2030:	cd b7       	in	r28, 0x3d	; 61
    2032:	de b7       	in	r29, 0x3e	; 62
    2034:	e2 e1       	ldi	r30, 0x12	; 18
    2036:	0c 94 b4 15 	jmp	0x2b68	; 0x2b68 <__epilogue_restores__>

0000203a <__subsf3>:
    203a:	a0 e2       	ldi	r26, 0x20	; 32
    203c:	b0 e0       	ldi	r27, 0x00	; 0
    203e:	e3 e2       	ldi	r30, 0x23	; 35
    2040:	f0 e1       	ldi	r31, 0x10	; 16
    2042:	0c 94 a4 15 	jmp	0x2b48	; 0x2b48 <__prologue_saves__+0x18>
    2046:	69 83       	std	Y+1, r22	; 0x01
    2048:	7a 83       	std	Y+2, r23	; 0x02
    204a:	8b 83       	std	Y+3, r24	; 0x03
    204c:	9c 83       	std	Y+4, r25	; 0x04
    204e:	2d 83       	std	Y+5, r18	; 0x05
    2050:	3e 83       	std	Y+6, r19	; 0x06
    2052:	4f 83       	std	Y+7, r20	; 0x07
    2054:	58 87       	std	Y+8, r21	; 0x08
    2056:	e9 e0       	ldi	r30, 0x09	; 9
    2058:	ee 2e       	mov	r14, r30
    205a:	f1 2c       	mov	r15, r1
    205c:	ec 0e       	add	r14, r28
    205e:	fd 1e       	adc	r15, r29
    2060:	ce 01       	movw	r24, r28
    2062:	01 96       	adiw	r24, 0x01	; 1
    2064:	b7 01       	movw	r22, r14
    2066:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    206a:	8e 01       	movw	r16, r28
    206c:	0f 5e       	subi	r16, 0xEF	; 239
    206e:	1f 4f       	sbci	r17, 0xFF	; 255
    2070:	ce 01       	movw	r24, r28
    2072:	05 96       	adiw	r24, 0x05	; 5
    2074:	b8 01       	movw	r22, r16
    2076:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    207a:	8a 89       	ldd	r24, Y+18	; 0x12
    207c:	91 e0       	ldi	r25, 0x01	; 1
    207e:	89 27       	eor	r24, r25
    2080:	8a 8b       	std	Y+18, r24	; 0x12
    2082:	c7 01       	movw	r24, r14
    2084:	b8 01       	movw	r22, r16
    2086:	ae 01       	movw	r20, r28
    2088:	47 5e       	subi	r20, 0xE7	; 231
    208a:	5f 4f       	sbci	r21, 0xFF	; 255
    208c:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <_fpadd_parts>
    2090:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    2094:	a0 96       	adiw	r28, 0x20	; 32
    2096:	e6 e0       	ldi	r30, 0x06	; 6
    2098:	0c 94 c0 15 	jmp	0x2b80	; 0x2b80 <__epilogue_restores__+0x18>

0000209c <__addsf3>:
    209c:	a0 e2       	ldi	r26, 0x20	; 32
    209e:	b0 e0       	ldi	r27, 0x00	; 0
    20a0:	e4 e5       	ldi	r30, 0x54	; 84
    20a2:	f0 e1       	ldi	r31, 0x10	; 16
    20a4:	0c 94 a4 15 	jmp	0x2b48	; 0x2b48 <__prologue_saves__+0x18>
    20a8:	69 83       	std	Y+1, r22	; 0x01
    20aa:	7a 83       	std	Y+2, r23	; 0x02
    20ac:	8b 83       	std	Y+3, r24	; 0x03
    20ae:	9c 83       	std	Y+4, r25	; 0x04
    20b0:	2d 83       	std	Y+5, r18	; 0x05
    20b2:	3e 83       	std	Y+6, r19	; 0x06
    20b4:	4f 83       	std	Y+7, r20	; 0x07
    20b6:	58 87       	std	Y+8, r21	; 0x08
    20b8:	f9 e0       	ldi	r31, 0x09	; 9
    20ba:	ef 2e       	mov	r14, r31
    20bc:	f1 2c       	mov	r15, r1
    20be:	ec 0e       	add	r14, r28
    20c0:	fd 1e       	adc	r15, r29
    20c2:	ce 01       	movw	r24, r28
    20c4:	01 96       	adiw	r24, 0x01	; 1
    20c6:	b7 01       	movw	r22, r14
    20c8:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    20cc:	8e 01       	movw	r16, r28
    20ce:	0f 5e       	subi	r16, 0xEF	; 239
    20d0:	1f 4f       	sbci	r17, 0xFF	; 255
    20d2:	ce 01       	movw	r24, r28
    20d4:	05 96       	adiw	r24, 0x05	; 5
    20d6:	b8 01       	movw	r22, r16
    20d8:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    20dc:	c7 01       	movw	r24, r14
    20de:	b8 01       	movw	r22, r16
    20e0:	ae 01       	movw	r20, r28
    20e2:	47 5e       	subi	r20, 0xE7	; 231
    20e4:	5f 4f       	sbci	r21, 0xFF	; 255
    20e6:	0e 94 d1 0e 	call	0x1da2	; 0x1da2 <_fpadd_parts>
    20ea:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    20ee:	a0 96       	adiw	r28, 0x20	; 32
    20f0:	e6 e0       	ldi	r30, 0x06	; 6
    20f2:	0c 94 c0 15 	jmp	0x2b80	; 0x2b80 <__epilogue_restores__+0x18>

000020f6 <__mulsf3>:
    20f6:	a0 e2       	ldi	r26, 0x20	; 32
    20f8:	b0 e0       	ldi	r27, 0x00	; 0
    20fa:	e1 e8       	ldi	r30, 0x81	; 129
    20fc:	f0 e1       	ldi	r31, 0x10	; 16
    20fe:	0c 94 98 15 	jmp	0x2b30	; 0x2b30 <__prologue_saves__>
    2102:	69 83       	std	Y+1, r22	; 0x01
    2104:	7a 83       	std	Y+2, r23	; 0x02
    2106:	8b 83       	std	Y+3, r24	; 0x03
    2108:	9c 83       	std	Y+4, r25	; 0x04
    210a:	2d 83       	std	Y+5, r18	; 0x05
    210c:	3e 83       	std	Y+6, r19	; 0x06
    210e:	4f 83       	std	Y+7, r20	; 0x07
    2110:	58 87       	std	Y+8, r21	; 0x08
    2112:	ce 01       	movw	r24, r28
    2114:	01 96       	adiw	r24, 0x01	; 1
    2116:	be 01       	movw	r22, r28
    2118:	67 5f       	subi	r22, 0xF7	; 247
    211a:	7f 4f       	sbci	r23, 0xFF	; 255
    211c:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    2120:	ce 01       	movw	r24, r28
    2122:	05 96       	adiw	r24, 0x05	; 5
    2124:	be 01       	movw	r22, r28
    2126:	6f 5e       	subi	r22, 0xEF	; 239
    2128:	7f 4f       	sbci	r23, 0xFF	; 255
    212a:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    212e:	99 85       	ldd	r25, Y+9	; 0x09
    2130:	92 30       	cpi	r25, 0x02	; 2
    2132:	88 f0       	brcs	.+34     	; 0x2156 <__mulsf3+0x60>
    2134:	89 89       	ldd	r24, Y+17	; 0x11
    2136:	82 30       	cpi	r24, 0x02	; 2
    2138:	c8 f0       	brcs	.+50     	; 0x216c <__mulsf3+0x76>
    213a:	94 30       	cpi	r25, 0x04	; 4
    213c:	19 f4       	brne	.+6      	; 0x2144 <__mulsf3+0x4e>
    213e:	82 30       	cpi	r24, 0x02	; 2
    2140:	51 f4       	brne	.+20     	; 0x2156 <__mulsf3+0x60>
    2142:	04 c0       	rjmp	.+8      	; 0x214c <__mulsf3+0x56>
    2144:	84 30       	cpi	r24, 0x04	; 4
    2146:	29 f4       	brne	.+10     	; 0x2152 <__mulsf3+0x5c>
    2148:	92 30       	cpi	r25, 0x02	; 2
    214a:	81 f4       	brne	.+32     	; 0x216c <__mulsf3+0x76>
    214c:	80 ed       	ldi	r24, 0xD0	; 208
    214e:	94 e0       	ldi	r25, 0x04	; 4
    2150:	c6 c0       	rjmp	.+396    	; 0x22de <__stack+0xdf>
    2152:	92 30       	cpi	r25, 0x02	; 2
    2154:	49 f4       	brne	.+18     	; 0x2168 <__mulsf3+0x72>
    2156:	20 e0       	ldi	r18, 0x00	; 0
    2158:	9a 85       	ldd	r25, Y+10	; 0x0a
    215a:	8a 89       	ldd	r24, Y+18	; 0x12
    215c:	98 13       	cpse	r25, r24
    215e:	21 e0       	ldi	r18, 0x01	; 1
    2160:	2a 87       	std	Y+10, r18	; 0x0a
    2162:	ce 01       	movw	r24, r28
    2164:	09 96       	adiw	r24, 0x09	; 9
    2166:	bb c0       	rjmp	.+374    	; 0x22de <__stack+0xdf>
    2168:	82 30       	cpi	r24, 0x02	; 2
    216a:	49 f4       	brne	.+18     	; 0x217e <__mulsf3+0x88>
    216c:	20 e0       	ldi	r18, 0x00	; 0
    216e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2170:	8a 89       	ldd	r24, Y+18	; 0x12
    2172:	98 13       	cpse	r25, r24
    2174:	21 e0       	ldi	r18, 0x01	; 1
    2176:	2a 8b       	std	Y+18, r18	; 0x12
    2178:	ce 01       	movw	r24, r28
    217a:	41 96       	adiw	r24, 0x11	; 17
    217c:	b0 c0       	rjmp	.+352    	; 0x22de <__stack+0xdf>
    217e:	2d 84       	ldd	r2, Y+13	; 0x0d
    2180:	3e 84       	ldd	r3, Y+14	; 0x0e
    2182:	4f 84       	ldd	r4, Y+15	; 0x0f
    2184:	58 88       	ldd	r5, Y+16	; 0x10
    2186:	6d 88       	ldd	r6, Y+21	; 0x15
    2188:	7e 88       	ldd	r7, Y+22	; 0x16
    218a:	8f 88       	ldd	r8, Y+23	; 0x17
    218c:	98 8c       	ldd	r9, Y+24	; 0x18
    218e:	ee 24       	eor	r14, r14
    2190:	ff 24       	eor	r15, r15
    2192:	87 01       	movw	r16, r14
    2194:	aa 24       	eor	r10, r10
    2196:	bb 24       	eor	r11, r11
    2198:	65 01       	movw	r12, r10
    219a:	40 e0       	ldi	r20, 0x00	; 0
    219c:	50 e0       	ldi	r21, 0x00	; 0
    219e:	60 e0       	ldi	r22, 0x00	; 0
    21a0:	70 e0       	ldi	r23, 0x00	; 0
    21a2:	e0 e0       	ldi	r30, 0x00	; 0
    21a4:	f0 e0       	ldi	r31, 0x00	; 0
    21a6:	c1 01       	movw	r24, r2
    21a8:	81 70       	andi	r24, 0x01	; 1
    21aa:	90 70       	andi	r25, 0x00	; 0
    21ac:	89 2b       	or	r24, r25
    21ae:	e9 f0       	breq	.+58     	; 0x21ea <__mulsf3+0xf4>
    21b0:	e6 0c       	add	r14, r6
    21b2:	f7 1c       	adc	r15, r7
    21b4:	08 1d       	adc	r16, r8
    21b6:	19 1d       	adc	r17, r9
    21b8:	9a 01       	movw	r18, r20
    21ba:	ab 01       	movw	r20, r22
    21bc:	2a 0d       	add	r18, r10
    21be:	3b 1d       	adc	r19, r11
    21c0:	4c 1d       	adc	r20, r12
    21c2:	5d 1d       	adc	r21, r13
    21c4:	80 e0       	ldi	r24, 0x00	; 0
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	a0 e0       	ldi	r26, 0x00	; 0
    21ca:	b0 e0       	ldi	r27, 0x00	; 0
    21cc:	e6 14       	cp	r14, r6
    21ce:	f7 04       	cpc	r15, r7
    21d0:	08 05       	cpc	r16, r8
    21d2:	19 05       	cpc	r17, r9
    21d4:	20 f4       	brcc	.+8      	; 0x21de <__mulsf3+0xe8>
    21d6:	81 e0       	ldi	r24, 0x01	; 1
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	a0 e0       	ldi	r26, 0x00	; 0
    21dc:	b0 e0       	ldi	r27, 0x00	; 0
    21de:	ba 01       	movw	r22, r20
    21e0:	a9 01       	movw	r20, r18
    21e2:	48 0f       	add	r20, r24
    21e4:	59 1f       	adc	r21, r25
    21e6:	6a 1f       	adc	r22, r26
    21e8:	7b 1f       	adc	r23, r27
    21ea:	aa 0c       	add	r10, r10
    21ec:	bb 1c       	adc	r11, r11
    21ee:	cc 1c       	adc	r12, r12
    21f0:	dd 1c       	adc	r13, r13
    21f2:	97 fe       	sbrs	r9, 7
    21f4:	08 c0       	rjmp	.+16     	; 0x2206 <__stack+0x7>
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	a0 e0       	ldi	r26, 0x00	; 0
    21fc:	b0 e0       	ldi	r27, 0x00	; 0
    21fe:	a8 2a       	or	r10, r24
    2200:	b9 2a       	or	r11, r25
    2202:	ca 2a       	or	r12, r26
    2204:	db 2a       	or	r13, r27
    2206:	31 96       	adiw	r30, 0x01	; 1
    2208:	e0 32       	cpi	r30, 0x20	; 32
    220a:	f1 05       	cpc	r31, r1
    220c:	49 f0       	breq	.+18     	; 0x2220 <__stack+0x21>
    220e:	66 0c       	add	r6, r6
    2210:	77 1c       	adc	r7, r7
    2212:	88 1c       	adc	r8, r8
    2214:	99 1c       	adc	r9, r9
    2216:	56 94       	lsr	r5
    2218:	47 94       	ror	r4
    221a:	37 94       	ror	r3
    221c:	27 94       	ror	r2
    221e:	c3 cf       	rjmp	.-122    	; 0x21a6 <__mulsf3+0xb0>
    2220:	fa 85       	ldd	r31, Y+10	; 0x0a
    2222:	ea 89       	ldd	r30, Y+18	; 0x12
    2224:	2b 89       	ldd	r18, Y+19	; 0x13
    2226:	3c 89       	ldd	r19, Y+20	; 0x14
    2228:	8b 85       	ldd	r24, Y+11	; 0x0b
    222a:	9c 85       	ldd	r25, Y+12	; 0x0c
    222c:	28 0f       	add	r18, r24
    222e:	39 1f       	adc	r19, r25
    2230:	2e 5f       	subi	r18, 0xFE	; 254
    2232:	3f 4f       	sbci	r19, 0xFF	; 255
    2234:	17 c0       	rjmp	.+46     	; 0x2264 <__stack+0x65>
    2236:	ca 01       	movw	r24, r20
    2238:	81 70       	andi	r24, 0x01	; 1
    223a:	90 70       	andi	r25, 0x00	; 0
    223c:	89 2b       	or	r24, r25
    223e:	61 f0       	breq	.+24     	; 0x2258 <__stack+0x59>
    2240:	16 95       	lsr	r17
    2242:	07 95       	ror	r16
    2244:	f7 94       	ror	r15
    2246:	e7 94       	ror	r14
    2248:	80 e0       	ldi	r24, 0x00	; 0
    224a:	90 e0       	ldi	r25, 0x00	; 0
    224c:	a0 e0       	ldi	r26, 0x00	; 0
    224e:	b0 e8       	ldi	r27, 0x80	; 128
    2250:	e8 2a       	or	r14, r24
    2252:	f9 2a       	or	r15, r25
    2254:	0a 2b       	or	r16, r26
    2256:	1b 2b       	or	r17, r27
    2258:	76 95       	lsr	r23
    225a:	67 95       	ror	r22
    225c:	57 95       	ror	r21
    225e:	47 95       	ror	r20
    2260:	2f 5f       	subi	r18, 0xFF	; 255
    2262:	3f 4f       	sbci	r19, 0xFF	; 255
    2264:	77 fd       	sbrc	r23, 7
    2266:	e7 cf       	rjmp	.-50     	; 0x2236 <__stack+0x37>
    2268:	0c c0       	rjmp	.+24     	; 0x2282 <__stack+0x83>
    226a:	44 0f       	add	r20, r20
    226c:	55 1f       	adc	r21, r21
    226e:	66 1f       	adc	r22, r22
    2270:	77 1f       	adc	r23, r23
    2272:	17 fd       	sbrc	r17, 7
    2274:	41 60       	ori	r20, 0x01	; 1
    2276:	ee 0c       	add	r14, r14
    2278:	ff 1c       	adc	r15, r15
    227a:	00 1f       	adc	r16, r16
    227c:	11 1f       	adc	r17, r17
    227e:	21 50       	subi	r18, 0x01	; 1
    2280:	30 40       	sbci	r19, 0x00	; 0
    2282:	40 30       	cpi	r20, 0x00	; 0
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	59 07       	cpc	r21, r25
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	69 07       	cpc	r22, r25
    228c:	90 e4       	ldi	r25, 0x40	; 64
    228e:	79 07       	cpc	r23, r25
    2290:	60 f3       	brcs	.-40     	; 0x226a <__stack+0x6b>
    2292:	2b 8f       	std	Y+27, r18	; 0x1b
    2294:	3c 8f       	std	Y+28, r19	; 0x1c
    2296:	db 01       	movw	r26, r22
    2298:	ca 01       	movw	r24, r20
    229a:	8f 77       	andi	r24, 0x7F	; 127
    229c:	90 70       	andi	r25, 0x00	; 0
    229e:	a0 70       	andi	r26, 0x00	; 0
    22a0:	b0 70       	andi	r27, 0x00	; 0
    22a2:	80 34       	cpi	r24, 0x40	; 64
    22a4:	91 05       	cpc	r25, r1
    22a6:	a1 05       	cpc	r26, r1
    22a8:	b1 05       	cpc	r27, r1
    22aa:	61 f4       	brne	.+24     	; 0x22c4 <__stack+0xc5>
    22ac:	47 fd       	sbrc	r20, 7
    22ae:	0a c0       	rjmp	.+20     	; 0x22c4 <__stack+0xc5>
    22b0:	e1 14       	cp	r14, r1
    22b2:	f1 04       	cpc	r15, r1
    22b4:	01 05       	cpc	r16, r1
    22b6:	11 05       	cpc	r17, r1
    22b8:	29 f0       	breq	.+10     	; 0x22c4 <__stack+0xc5>
    22ba:	40 5c       	subi	r20, 0xC0	; 192
    22bc:	5f 4f       	sbci	r21, 0xFF	; 255
    22be:	6f 4f       	sbci	r22, 0xFF	; 255
    22c0:	7f 4f       	sbci	r23, 0xFF	; 255
    22c2:	40 78       	andi	r20, 0x80	; 128
    22c4:	1a 8e       	std	Y+26, r1	; 0x1a
    22c6:	fe 17       	cp	r31, r30
    22c8:	11 f0       	breq	.+4      	; 0x22ce <__stack+0xcf>
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	8a 8f       	std	Y+26, r24	; 0x1a
    22ce:	4d 8f       	std	Y+29, r20	; 0x1d
    22d0:	5e 8f       	std	Y+30, r21	; 0x1e
    22d2:	6f 8f       	std	Y+31, r22	; 0x1f
    22d4:	78 a3       	std	Y+32, r23	; 0x20
    22d6:	83 e0       	ldi	r24, 0x03	; 3
    22d8:	89 8f       	std	Y+25, r24	; 0x19
    22da:	ce 01       	movw	r24, r28
    22dc:	49 96       	adiw	r24, 0x19	; 25
    22de:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    22e2:	a0 96       	adiw	r28, 0x20	; 32
    22e4:	e2 e1       	ldi	r30, 0x12	; 18
    22e6:	0c 94 b4 15 	jmp	0x2b68	; 0x2b68 <__epilogue_restores__>

000022ea <__divsf3>:
    22ea:	a8 e1       	ldi	r26, 0x18	; 24
    22ec:	b0 e0       	ldi	r27, 0x00	; 0
    22ee:	eb e7       	ldi	r30, 0x7B	; 123
    22f0:	f1 e1       	ldi	r31, 0x11	; 17
    22f2:	0c 94 a0 15 	jmp	0x2b40	; 0x2b40 <__prologue_saves__+0x10>
    22f6:	69 83       	std	Y+1, r22	; 0x01
    22f8:	7a 83       	std	Y+2, r23	; 0x02
    22fa:	8b 83       	std	Y+3, r24	; 0x03
    22fc:	9c 83       	std	Y+4, r25	; 0x04
    22fe:	2d 83       	std	Y+5, r18	; 0x05
    2300:	3e 83       	std	Y+6, r19	; 0x06
    2302:	4f 83       	std	Y+7, r20	; 0x07
    2304:	58 87       	std	Y+8, r21	; 0x08
    2306:	b9 e0       	ldi	r27, 0x09	; 9
    2308:	eb 2e       	mov	r14, r27
    230a:	f1 2c       	mov	r15, r1
    230c:	ec 0e       	add	r14, r28
    230e:	fd 1e       	adc	r15, r29
    2310:	ce 01       	movw	r24, r28
    2312:	01 96       	adiw	r24, 0x01	; 1
    2314:	b7 01       	movw	r22, r14
    2316:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    231a:	8e 01       	movw	r16, r28
    231c:	0f 5e       	subi	r16, 0xEF	; 239
    231e:	1f 4f       	sbci	r17, 0xFF	; 255
    2320:	ce 01       	movw	r24, r28
    2322:	05 96       	adiw	r24, 0x05	; 5
    2324:	b8 01       	movw	r22, r16
    2326:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    232a:	29 85       	ldd	r18, Y+9	; 0x09
    232c:	22 30       	cpi	r18, 0x02	; 2
    232e:	08 f4       	brcc	.+2      	; 0x2332 <__divsf3+0x48>
    2330:	7e c0       	rjmp	.+252    	; 0x242e <__divsf3+0x144>
    2332:	39 89       	ldd	r19, Y+17	; 0x11
    2334:	32 30       	cpi	r19, 0x02	; 2
    2336:	10 f4       	brcc	.+4      	; 0x233c <__divsf3+0x52>
    2338:	b8 01       	movw	r22, r16
    233a:	7c c0       	rjmp	.+248    	; 0x2434 <__divsf3+0x14a>
    233c:	8a 85       	ldd	r24, Y+10	; 0x0a
    233e:	9a 89       	ldd	r25, Y+18	; 0x12
    2340:	89 27       	eor	r24, r25
    2342:	8a 87       	std	Y+10, r24	; 0x0a
    2344:	24 30       	cpi	r18, 0x04	; 4
    2346:	11 f0       	breq	.+4      	; 0x234c <__divsf3+0x62>
    2348:	22 30       	cpi	r18, 0x02	; 2
    234a:	31 f4       	brne	.+12     	; 0x2358 <__divsf3+0x6e>
    234c:	23 17       	cp	r18, r19
    234e:	09 f0       	breq	.+2      	; 0x2352 <__divsf3+0x68>
    2350:	6e c0       	rjmp	.+220    	; 0x242e <__divsf3+0x144>
    2352:	60 ed       	ldi	r22, 0xD0	; 208
    2354:	74 e0       	ldi	r23, 0x04	; 4
    2356:	6e c0       	rjmp	.+220    	; 0x2434 <__divsf3+0x14a>
    2358:	34 30       	cpi	r19, 0x04	; 4
    235a:	39 f4       	brne	.+14     	; 0x236a <__divsf3+0x80>
    235c:	1d 86       	std	Y+13, r1	; 0x0d
    235e:	1e 86       	std	Y+14, r1	; 0x0e
    2360:	1f 86       	std	Y+15, r1	; 0x0f
    2362:	18 8a       	std	Y+16, r1	; 0x10
    2364:	1c 86       	std	Y+12, r1	; 0x0c
    2366:	1b 86       	std	Y+11, r1	; 0x0b
    2368:	04 c0       	rjmp	.+8      	; 0x2372 <__divsf3+0x88>
    236a:	32 30       	cpi	r19, 0x02	; 2
    236c:	21 f4       	brne	.+8      	; 0x2376 <__divsf3+0x8c>
    236e:	84 e0       	ldi	r24, 0x04	; 4
    2370:	89 87       	std	Y+9, r24	; 0x09
    2372:	b7 01       	movw	r22, r14
    2374:	5f c0       	rjmp	.+190    	; 0x2434 <__divsf3+0x14a>
    2376:	2b 85       	ldd	r18, Y+11	; 0x0b
    2378:	3c 85       	ldd	r19, Y+12	; 0x0c
    237a:	8b 89       	ldd	r24, Y+19	; 0x13
    237c:	9c 89       	ldd	r25, Y+20	; 0x14
    237e:	28 1b       	sub	r18, r24
    2380:	39 0b       	sbc	r19, r25
    2382:	3c 87       	std	Y+12, r19	; 0x0c
    2384:	2b 87       	std	Y+11, r18	; 0x0b
    2386:	ed 84       	ldd	r14, Y+13	; 0x0d
    2388:	fe 84       	ldd	r15, Y+14	; 0x0e
    238a:	0f 85       	ldd	r16, Y+15	; 0x0f
    238c:	18 89       	ldd	r17, Y+16	; 0x10
    238e:	ad 88       	ldd	r10, Y+21	; 0x15
    2390:	be 88       	ldd	r11, Y+22	; 0x16
    2392:	cf 88       	ldd	r12, Y+23	; 0x17
    2394:	d8 8c       	ldd	r13, Y+24	; 0x18
    2396:	ea 14       	cp	r14, r10
    2398:	fb 04       	cpc	r15, r11
    239a:	0c 05       	cpc	r16, r12
    239c:	1d 05       	cpc	r17, r13
    239e:	40 f4       	brcc	.+16     	; 0x23b0 <__divsf3+0xc6>
    23a0:	ee 0c       	add	r14, r14
    23a2:	ff 1c       	adc	r15, r15
    23a4:	00 1f       	adc	r16, r16
    23a6:	11 1f       	adc	r17, r17
    23a8:	21 50       	subi	r18, 0x01	; 1
    23aa:	30 40       	sbci	r19, 0x00	; 0
    23ac:	3c 87       	std	Y+12, r19	; 0x0c
    23ae:	2b 87       	std	Y+11, r18	; 0x0b
    23b0:	20 e0       	ldi	r18, 0x00	; 0
    23b2:	30 e0       	ldi	r19, 0x00	; 0
    23b4:	40 e0       	ldi	r20, 0x00	; 0
    23b6:	50 e0       	ldi	r21, 0x00	; 0
    23b8:	80 e0       	ldi	r24, 0x00	; 0
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	a0 e0       	ldi	r26, 0x00	; 0
    23be:	b0 e4       	ldi	r27, 0x40	; 64
    23c0:	60 e0       	ldi	r22, 0x00	; 0
    23c2:	70 e0       	ldi	r23, 0x00	; 0
    23c4:	ea 14       	cp	r14, r10
    23c6:	fb 04       	cpc	r15, r11
    23c8:	0c 05       	cpc	r16, r12
    23ca:	1d 05       	cpc	r17, r13
    23cc:	40 f0       	brcs	.+16     	; 0x23de <__divsf3+0xf4>
    23ce:	28 2b       	or	r18, r24
    23d0:	39 2b       	or	r19, r25
    23d2:	4a 2b       	or	r20, r26
    23d4:	5b 2b       	or	r21, r27
    23d6:	ea 18       	sub	r14, r10
    23d8:	fb 08       	sbc	r15, r11
    23da:	0c 09       	sbc	r16, r12
    23dc:	1d 09       	sbc	r17, r13
    23de:	b6 95       	lsr	r27
    23e0:	a7 95       	ror	r26
    23e2:	97 95       	ror	r25
    23e4:	87 95       	ror	r24
    23e6:	ee 0c       	add	r14, r14
    23e8:	ff 1c       	adc	r15, r15
    23ea:	00 1f       	adc	r16, r16
    23ec:	11 1f       	adc	r17, r17
    23ee:	6f 5f       	subi	r22, 0xFF	; 255
    23f0:	7f 4f       	sbci	r23, 0xFF	; 255
    23f2:	6f 31       	cpi	r22, 0x1F	; 31
    23f4:	71 05       	cpc	r23, r1
    23f6:	31 f7       	brne	.-52     	; 0x23c4 <__divsf3+0xda>
    23f8:	da 01       	movw	r26, r20
    23fa:	c9 01       	movw	r24, r18
    23fc:	8f 77       	andi	r24, 0x7F	; 127
    23fe:	90 70       	andi	r25, 0x00	; 0
    2400:	a0 70       	andi	r26, 0x00	; 0
    2402:	b0 70       	andi	r27, 0x00	; 0
    2404:	80 34       	cpi	r24, 0x40	; 64
    2406:	91 05       	cpc	r25, r1
    2408:	a1 05       	cpc	r26, r1
    240a:	b1 05       	cpc	r27, r1
    240c:	61 f4       	brne	.+24     	; 0x2426 <__divsf3+0x13c>
    240e:	27 fd       	sbrc	r18, 7
    2410:	0a c0       	rjmp	.+20     	; 0x2426 <__divsf3+0x13c>
    2412:	e1 14       	cp	r14, r1
    2414:	f1 04       	cpc	r15, r1
    2416:	01 05       	cpc	r16, r1
    2418:	11 05       	cpc	r17, r1
    241a:	29 f0       	breq	.+10     	; 0x2426 <__divsf3+0x13c>
    241c:	20 5c       	subi	r18, 0xC0	; 192
    241e:	3f 4f       	sbci	r19, 0xFF	; 255
    2420:	4f 4f       	sbci	r20, 0xFF	; 255
    2422:	5f 4f       	sbci	r21, 0xFF	; 255
    2424:	20 78       	andi	r18, 0x80	; 128
    2426:	2d 87       	std	Y+13, r18	; 0x0d
    2428:	3e 87       	std	Y+14, r19	; 0x0e
    242a:	4f 87       	std	Y+15, r20	; 0x0f
    242c:	58 8b       	std	Y+16, r21	; 0x10
    242e:	be 01       	movw	r22, r28
    2430:	67 5f       	subi	r22, 0xF7	; 247
    2432:	7f 4f       	sbci	r23, 0xFF	; 255
    2434:	cb 01       	movw	r24, r22
    2436:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    243a:	68 96       	adiw	r28, 0x18	; 24
    243c:	ea e0       	ldi	r30, 0x0A	; 10
    243e:	0c 94 bc 15 	jmp	0x2b78	; 0x2b78 <__epilogue_restores__+0x10>

00002442 <__gesf2>:
    2442:	a8 e1       	ldi	r26, 0x18	; 24
    2444:	b0 e0       	ldi	r27, 0x00	; 0
    2446:	e7 e2       	ldi	r30, 0x27	; 39
    2448:	f2 e1       	ldi	r31, 0x12	; 18
    244a:	0c 94 a4 15 	jmp	0x2b48	; 0x2b48 <__prologue_saves__+0x18>
    244e:	69 83       	std	Y+1, r22	; 0x01
    2450:	7a 83       	std	Y+2, r23	; 0x02
    2452:	8b 83       	std	Y+3, r24	; 0x03
    2454:	9c 83       	std	Y+4, r25	; 0x04
    2456:	2d 83       	std	Y+5, r18	; 0x05
    2458:	3e 83       	std	Y+6, r19	; 0x06
    245a:	4f 83       	std	Y+7, r20	; 0x07
    245c:	58 87       	std	Y+8, r21	; 0x08
    245e:	89 e0       	ldi	r24, 0x09	; 9
    2460:	e8 2e       	mov	r14, r24
    2462:	f1 2c       	mov	r15, r1
    2464:	ec 0e       	add	r14, r28
    2466:	fd 1e       	adc	r15, r29
    2468:	ce 01       	movw	r24, r28
    246a:	01 96       	adiw	r24, 0x01	; 1
    246c:	b7 01       	movw	r22, r14
    246e:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    2472:	8e 01       	movw	r16, r28
    2474:	0f 5e       	subi	r16, 0xEF	; 239
    2476:	1f 4f       	sbci	r17, 0xFF	; 255
    2478:	ce 01       	movw	r24, r28
    247a:	05 96       	adiw	r24, 0x05	; 5
    247c:	b8 01       	movw	r22, r16
    247e:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    2482:	89 85       	ldd	r24, Y+9	; 0x09
    2484:	82 30       	cpi	r24, 0x02	; 2
    2486:	40 f0       	brcs	.+16     	; 0x2498 <__gesf2+0x56>
    2488:	89 89       	ldd	r24, Y+17	; 0x11
    248a:	82 30       	cpi	r24, 0x02	; 2
    248c:	28 f0       	brcs	.+10     	; 0x2498 <__gesf2+0x56>
    248e:	c7 01       	movw	r24, r14
    2490:	b8 01       	movw	r22, r16
    2492:	0e 94 18 15 	call	0x2a30	; 0x2a30 <__fpcmp_parts_f>
    2496:	01 c0       	rjmp	.+2      	; 0x249a <__gesf2+0x58>
    2498:	8f ef       	ldi	r24, 0xFF	; 255
    249a:	68 96       	adiw	r28, 0x18	; 24
    249c:	e6 e0       	ldi	r30, 0x06	; 6
    249e:	0c 94 c0 15 	jmp	0x2b80	; 0x2b80 <__epilogue_restores__+0x18>

000024a2 <__floatsisf>:
    24a2:	a8 e0       	ldi	r26, 0x08	; 8
    24a4:	b0 e0       	ldi	r27, 0x00	; 0
    24a6:	e7 e5       	ldi	r30, 0x57	; 87
    24a8:	f2 e1       	ldi	r31, 0x12	; 18
    24aa:	0c 94 a1 15 	jmp	0x2b42	; 0x2b42 <__prologue_saves__+0x12>
    24ae:	9b 01       	movw	r18, r22
    24b0:	ac 01       	movw	r20, r24
    24b2:	83 e0       	ldi	r24, 0x03	; 3
    24b4:	89 83       	std	Y+1, r24	; 0x01
    24b6:	da 01       	movw	r26, r20
    24b8:	c9 01       	movw	r24, r18
    24ba:	88 27       	eor	r24, r24
    24bc:	b7 fd       	sbrc	r27, 7
    24be:	83 95       	inc	r24
    24c0:	99 27       	eor	r25, r25
    24c2:	aa 27       	eor	r26, r26
    24c4:	bb 27       	eor	r27, r27
    24c6:	b8 2e       	mov	r11, r24
    24c8:	21 15       	cp	r18, r1
    24ca:	31 05       	cpc	r19, r1
    24cc:	41 05       	cpc	r20, r1
    24ce:	51 05       	cpc	r21, r1
    24d0:	19 f4       	brne	.+6      	; 0x24d8 <__floatsisf+0x36>
    24d2:	82 e0       	ldi	r24, 0x02	; 2
    24d4:	89 83       	std	Y+1, r24	; 0x01
    24d6:	3a c0       	rjmp	.+116    	; 0x254c <__floatsisf+0xaa>
    24d8:	88 23       	and	r24, r24
    24da:	a9 f0       	breq	.+42     	; 0x2506 <__floatsisf+0x64>
    24dc:	20 30       	cpi	r18, 0x00	; 0
    24de:	80 e0       	ldi	r24, 0x00	; 0
    24e0:	38 07       	cpc	r19, r24
    24e2:	80 e0       	ldi	r24, 0x00	; 0
    24e4:	48 07       	cpc	r20, r24
    24e6:	80 e8       	ldi	r24, 0x80	; 128
    24e8:	58 07       	cpc	r21, r24
    24ea:	29 f4       	brne	.+10     	; 0x24f6 <__floatsisf+0x54>
    24ec:	60 e0       	ldi	r22, 0x00	; 0
    24ee:	70 e0       	ldi	r23, 0x00	; 0
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	9f ec       	ldi	r25, 0xCF	; 207
    24f4:	30 c0       	rjmp	.+96     	; 0x2556 <__floatsisf+0xb4>
    24f6:	ee 24       	eor	r14, r14
    24f8:	ff 24       	eor	r15, r15
    24fa:	87 01       	movw	r16, r14
    24fc:	e2 1a       	sub	r14, r18
    24fe:	f3 0a       	sbc	r15, r19
    2500:	04 0b       	sbc	r16, r20
    2502:	15 0b       	sbc	r17, r21
    2504:	02 c0       	rjmp	.+4      	; 0x250a <__floatsisf+0x68>
    2506:	79 01       	movw	r14, r18
    2508:	8a 01       	movw	r16, r20
    250a:	8e e1       	ldi	r24, 0x1E	; 30
    250c:	c8 2e       	mov	r12, r24
    250e:	d1 2c       	mov	r13, r1
    2510:	dc 82       	std	Y+4, r13	; 0x04
    2512:	cb 82       	std	Y+3, r12	; 0x03
    2514:	ed 82       	std	Y+5, r14	; 0x05
    2516:	fe 82       	std	Y+6, r15	; 0x06
    2518:	0f 83       	std	Y+7, r16	; 0x07
    251a:	18 87       	std	Y+8, r17	; 0x08
    251c:	c8 01       	movw	r24, r16
    251e:	b7 01       	movw	r22, r14
    2520:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <__clzsi2>
    2524:	01 97       	sbiw	r24, 0x01	; 1
    2526:	18 16       	cp	r1, r24
    2528:	19 06       	cpc	r1, r25
    252a:	84 f4       	brge	.+32     	; 0x254c <__floatsisf+0xaa>
    252c:	08 2e       	mov	r0, r24
    252e:	04 c0       	rjmp	.+8      	; 0x2538 <__floatsisf+0x96>
    2530:	ee 0c       	add	r14, r14
    2532:	ff 1c       	adc	r15, r15
    2534:	00 1f       	adc	r16, r16
    2536:	11 1f       	adc	r17, r17
    2538:	0a 94       	dec	r0
    253a:	d2 f7       	brpl	.-12     	; 0x2530 <__floatsisf+0x8e>
    253c:	ed 82       	std	Y+5, r14	; 0x05
    253e:	fe 82       	std	Y+6, r15	; 0x06
    2540:	0f 83       	std	Y+7, r16	; 0x07
    2542:	18 87       	std	Y+8, r17	; 0x08
    2544:	c8 1a       	sub	r12, r24
    2546:	d9 0a       	sbc	r13, r25
    2548:	dc 82       	std	Y+4, r13	; 0x04
    254a:	cb 82       	std	Y+3, r12	; 0x03
    254c:	ba 82       	std	Y+2, r11	; 0x02
    254e:	ce 01       	movw	r24, r28
    2550:	01 96       	adiw	r24, 0x01	; 1
    2552:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    2556:	28 96       	adiw	r28, 0x08	; 8
    2558:	e9 e0       	ldi	r30, 0x09	; 9
    255a:	0c 94 bd 15 	jmp	0x2b7a	; 0x2b7a <__epilogue_restores__+0x12>

0000255e <__fixsfsi>:
    255e:	ac e0       	ldi	r26, 0x0C	; 12
    2560:	b0 e0       	ldi	r27, 0x00	; 0
    2562:	e5 eb       	ldi	r30, 0xB5	; 181
    2564:	f2 e1       	ldi	r31, 0x12	; 18
    2566:	0c 94 a8 15 	jmp	0x2b50	; 0x2b50 <__prologue_saves__+0x20>
    256a:	69 83       	std	Y+1, r22	; 0x01
    256c:	7a 83       	std	Y+2, r23	; 0x02
    256e:	8b 83       	std	Y+3, r24	; 0x03
    2570:	9c 83       	std	Y+4, r25	; 0x04
    2572:	ce 01       	movw	r24, r28
    2574:	01 96       	adiw	r24, 0x01	; 1
    2576:	be 01       	movw	r22, r28
    2578:	6b 5f       	subi	r22, 0xFB	; 251
    257a:	7f 4f       	sbci	r23, 0xFF	; 255
    257c:	0e 94 a0 14 	call	0x2940	; 0x2940 <__unpack_f>
    2580:	8d 81       	ldd	r24, Y+5	; 0x05
    2582:	82 30       	cpi	r24, 0x02	; 2
    2584:	61 f1       	breq	.+88     	; 0x25de <__fixsfsi+0x80>
    2586:	82 30       	cpi	r24, 0x02	; 2
    2588:	50 f1       	brcs	.+84     	; 0x25de <__fixsfsi+0x80>
    258a:	84 30       	cpi	r24, 0x04	; 4
    258c:	21 f4       	brne	.+8      	; 0x2596 <__fixsfsi+0x38>
    258e:	8e 81       	ldd	r24, Y+6	; 0x06
    2590:	88 23       	and	r24, r24
    2592:	51 f1       	breq	.+84     	; 0x25e8 <__fixsfsi+0x8a>
    2594:	2e c0       	rjmp	.+92     	; 0x25f2 <__fixsfsi+0x94>
    2596:	2f 81       	ldd	r18, Y+7	; 0x07
    2598:	38 85       	ldd	r19, Y+8	; 0x08
    259a:	37 fd       	sbrc	r19, 7
    259c:	20 c0       	rjmp	.+64     	; 0x25de <__fixsfsi+0x80>
    259e:	6e 81       	ldd	r22, Y+6	; 0x06
    25a0:	2f 31       	cpi	r18, 0x1F	; 31
    25a2:	31 05       	cpc	r19, r1
    25a4:	1c f0       	brlt	.+6      	; 0x25ac <__fixsfsi+0x4e>
    25a6:	66 23       	and	r22, r22
    25a8:	f9 f0       	breq	.+62     	; 0x25e8 <__fixsfsi+0x8a>
    25aa:	23 c0       	rjmp	.+70     	; 0x25f2 <__fixsfsi+0x94>
    25ac:	8e e1       	ldi	r24, 0x1E	; 30
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	82 1b       	sub	r24, r18
    25b2:	93 0b       	sbc	r25, r19
    25b4:	29 85       	ldd	r18, Y+9	; 0x09
    25b6:	3a 85       	ldd	r19, Y+10	; 0x0a
    25b8:	4b 85       	ldd	r20, Y+11	; 0x0b
    25ba:	5c 85       	ldd	r21, Y+12	; 0x0c
    25bc:	04 c0       	rjmp	.+8      	; 0x25c6 <__fixsfsi+0x68>
    25be:	56 95       	lsr	r21
    25c0:	47 95       	ror	r20
    25c2:	37 95       	ror	r19
    25c4:	27 95       	ror	r18
    25c6:	8a 95       	dec	r24
    25c8:	d2 f7       	brpl	.-12     	; 0x25be <__fixsfsi+0x60>
    25ca:	66 23       	and	r22, r22
    25cc:	b1 f0       	breq	.+44     	; 0x25fa <__fixsfsi+0x9c>
    25ce:	50 95       	com	r21
    25d0:	40 95       	com	r20
    25d2:	30 95       	com	r19
    25d4:	21 95       	neg	r18
    25d6:	3f 4f       	sbci	r19, 0xFF	; 255
    25d8:	4f 4f       	sbci	r20, 0xFF	; 255
    25da:	5f 4f       	sbci	r21, 0xFF	; 255
    25dc:	0e c0       	rjmp	.+28     	; 0x25fa <__fixsfsi+0x9c>
    25de:	20 e0       	ldi	r18, 0x00	; 0
    25e0:	30 e0       	ldi	r19, 0x00	; 0
    25e2:	40 e0       	ldi	r20, 0x00	; 0
    25e4:	50 e0       	ldi	r21, 0x00	; 0
    25e6:	09 c0       	rjmp	.+18     	; 0x25fa <__fixsfsi+0x9c>
    25e8:	2f ef       	ldi	r18, 0xFF	; 255
    25ea:	3f ef       	ldi	r19, 0xFF	; 255
    25ec:	4f ef       	ldi	r20, 0xFF	; 255
    25ee:	5f e7       	ldi	r21, 0x7F	; 127
    25f0:	04 c0       	rjmp	.+8      	; 0x25fa <__fixsfsi+0x9c>
    25f2:	20 e0       	ldi	r18, 0x00	; 0
    25f4:	30 e0       	ldi	r19, 0x00	; 0
    25f6:	40 e0       	ldi	r20, 0x00	; 0
    25f8:	50 e8       	ldi	r21, 0x80	; 128
    25fa:	b9 01       	movw	r22, r18
    25fc:	ca 01       	movw	r24, r20
    25fe:	2c 96       	adiw	r28, 0x0c	; 12
    2600:	e2 e0       	ldi	r30, 0x02	; 2
    2602:	0c 94 c4 15 	jmp	0x2b88	; 0x2b88 <__epilogue_restores__+0x20>

00002606 <__floatunsisf>:
    2606:	a8 e0       	ldi	r26, 0x08	; 8
    2608:	b0 e0       	ldi	r27, 0x00	; 0
    260a:	e9 e0       	ldi	r30, 0x09	; 9
    260c:	f3 e1       	ldi	r31, 0x13	; 19
    260e:	0c 94 a0 15 	jmp	0x2b40	; 0x2b40 <__prologue_saves__+0x10>
    2612:	7b 01       	movw	r14, r22
    2614:	8c 01       	movw	r16, r24
    2616:	61 15       	cp	r22, r1
    2618:	71 05       	cpc	r23, r1
    261a:	81 05       	cpc	r24, r1
    261c:	91 05       	cpc	r25, r1
    261e:	19 f4       	brne	.+6      	; 0x2626 <__floatunsisf+0x20>
    2620:	82 e0       	ldi	r24, 0x02	; 2
    2622:	89 83       	std	Y+1, r24	; 0x01
    2624:	60 c0       	rjmp	.+192    	; 0x26e6 <__floatunsisf+0xe0>
    2626:	83 e0       	ldi	r24, 0x03	; 3
    2628:	89 83       	std	Y+1, r24	; 0x01
    262a:	8e e1       	ldi	r24, 0x1E	; 30
    262c:	c8 2e       	mov	r12, r24
    262e:	d1 2c       	mov	r13, r1
    2630:	dc 82       	std	Y+4, r13	; 0x04
    2632:	cb 82       	std	Y+3, r12	; 0x03
    2634:	ed 82       	std	Y+5, r14	; 0x05
    2636:	fe 82       	std	Y+6, r15	; 0x06
    2638:	0f 83       	std	Y+7, r16	; 0x07
    263a:	18 87       	std	Y+8, r17	; 0x08
    263c:	c8 01       	movw	r24, r16
    263e:	b7 01       	movw	r22, r14
    2640:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <__clzsi2>
    2644:	fc 01       	movw	r30, r24
    2646:	31 97       	sbiw	r30, 0x01	; 1
    2648:	f7 ff       	sbrs	r31, 7
    264a:	3b c0       	rjmp	.+118    	; 0x26c2 <__floatunsisf+0xbc>
    264c:	22 27       	eor	r18, r18
    264e:	33 27       	eor	r19, r19
    2650:	2e 1b       	sub	r18, r30
    2652:	3f 0b       	sbc	r19, r31
    2654:	57 01       	movw	r10, r14
    2656:	68 01       	movw	r12, r16
    2658:	02 2e       	mov	r0, r18
    265a:	04 c0       	rjmp	.+8      	; 0x2664 <__floatunsisf+0x5e>
    265c:	d6 94       	lsr	r13
    265e:	c7 94       	ror	r12
    2660:	b7 94       	ror	r11
    2662:	a7 94       	ror	r10
    2664:	0a 94       	dec	r0
    2666:	d2 f7       	brpl	.-12     	; 0x265c <__floatunsisf+0x56>
    2668:	40 e0       	ldi	r20, 0x00	; 0
    266a:	50 e0       	ldi	r21, 0x00	; 0
    266c:	60 e0       	ldi	r22, 0x00	; 0
    266e:	70 e0       	ldi	r23, 0x00	; 0
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	a0 e0       	ldi	r26, 0x00	; 0
    2676:	b0 e0       	ldi	r27, 0x00	; 0
    2678:	04 c0       	rjmp	.+8      	; 0x2682 <__floatunsisf+0x7c>
    267a:	88 0f       	add	r24, r24
    267c:	99 1f       	adc	r25, r25
    267e:	aa 1f       	adc	r26, r26
    2680:	bb 1f       	adc	r27, r27
    2682:	2a 95       	dec	r18
    2684:	d2 f7       	brpl	.-12     	; 0x267a <__floatunsisf+0x74>
    2686:	01 97       	sbiw	r24, 0x01	; 1
    2688:	a1 09       	sbc	r26, r1
    268a:	b1 09       	sbc	r27, r1
    268c:	8e 21       	and	r24, r14
    268e:	9f 21       	and	r25, r15
    2690:	a0 23       	and	r26, r16
    2692:	b1 23       	and	r27, r17
    2694:	00 97       	sbiw	r24, 0x00	; 0
    2696:	a1 05       	cpc	r26, r1
    2698:	b1 05       	cpc	r27, r1
    269a:	21 f0       	breq	.+8      	; 0x26a4 <__floatunsisf+0x9e>
    269c:	41 e0       	ldi	r20, 0x01	; 1
    269e:	50 e0       	ldi	r21, 0x00	; 0
    26a0:	60 e0       	ldi	r22, 0x00	; 0
    26a2:	70 e0       	ldi	r23, 0x00	; 0
    26a4:	4a 29       	or	r20, r10
    26a6:	5b 29       	or	r21, r11
    26a8:	6c 29       	or	r22, r12
    26aa:	7d 29       	or	r23, r13
    26ac:	4d 83       	std	Y+5, r20	; 0x05
    26ae:	5e 83       	std	Y+6, r21	; 0x06
    26b0:	6f 83       	std	Y+7, r22	; 0x07
    26b2:	78 87       	std	Y+8, r23	; 0x08
    26b4:	8e e1       	ldi	r24, 0x1E	; 30
    26b6:	90 e0       	ldi	r25, 0x00	; 0
    26b8:	8e 1b       	sub	r24, r30
    26ba:	9f 0b       	sbc	r25, r31
    26bc:	9c 83       	std	Y+4, r25	; 0x04
    26be:	8b 83       	std	Y+3, r24	; 0x03
    26c0:	12 c0       	rjmp	.+36     	; 0x26e6 <__floatunsisf+0xe0>
    26c2:	30 97       	sbiw	r30, 0x00	; 0
    26c4:	81 f0       	breq	.+32     	; 0x26e6 <__floatunsisf+0xe0>
    26c6:	0e 2e       	mov	r0, r30
    26c8:	04 c0       	rjmp	.+8      	; 0x26d2 <__floatunsisf+0xcc>
    26ca:	ee 0c       	add	r14, r14
    26cc:	ff 1c       	adc	r15, r15
    26ce:	00 1f       	adc	r16, r16
    26d0:	11 1f       	adc	r17, r17
    26d2:	0a 94       	dec	r0
    26d4:	d2 f7       	brpl	.-12     	; 0x26ca <__floatunsisf+0xc4>
    26d6:	ed 82       	std	Y+5, r14	; 0x05
    26d8:	fe 82       	std	Y+6, r15	; 0x06
    26da:	0f 83       	std	Y+7, r16	; 0x07
    26dc:	18 87       	std	Y+8, r17	; 0x08
    26de:	ce 1a       	sub	r12, r30
    26e0:	df 0a       	sbc	r13, r31
    26e2:	dc 82       	std	Y+4, r13	; 0x04
    26e4:	cb 82       	std	Y+3, r12	; 0x03
    26e6:	1a 82       	std	Y+2, r1	; 0x02
    26e8:	ce 01       	movw	r24, r28
    26ea:	01 96       	adiw	r24, 0x01	; 1
    26ec:	0e 94 cb 13 	call	0x2796	; 0x2796 <__pack_f>
    26f0:	28 96       	adiw	r28, 0x08	; 8
    26f2:	ea e0       	ldi	r30, 0x0A	; 10
    26f4:	0c 94 bc 15 	jmp	0x2b78	; 0x2b78 <__epilogue_restores__+0x10>

000026f8 <__clzsi2>:
    26f8:	ef 92       	push	r14
    26fa:	ff 92       	push	r15
    26fc:	0f 93       	push	r16
    26fe:	1f 93       	push	r17
    2700:	7b 01       	movw	r14, r22
    2702:	8c 01       	movw	r16, r24
    2704:	80 e0       	ldi	r24, 0x00	; 0
    2706:	e8 16       	cp	r14, r24
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	f8 06       	cpc	r15, r24
    270c:	81 e0       	ldi	r24, 0x01	; 1
    270e:	08 07       	cpc	r16, r24
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	18 07       	cpc	r17, r24
    2714:	88 f4       	brcc	.+34     	; 0x2738 <__clzsi2+0x40>
    2716:	8f ef       	ldi	r24, 0xFF	; 255
    2718:	e8 16       	cp	r14, r24
    271a:	f1 04       	cpc	r15, r1
    271c:	01 05       	cpc	r16, r1
    271e:	11 05       	cpc	r17, r1
    2720:	31 f0       	breq	.+12     	; 0x272e <__clzsi2+0x36>
    2722:	28 f0       	brcs	.+10     	; 0x272e <__clzsi2+0x36>
    2724:	88 e0       	ldi	r24, 0x08	; 8
    2726:	90 e0       	ldi	r25, 0x00	; 0
    2728:	a0 e0       	ldi	r26, 0x00	; 0
    272a:	b0 e0       	ldi	r27, 0x00	; 0
    272c:	17 c0       	rjmp	.+46     	; 0x275c <__clzsi2+0x64>
    272e:	80 e0       	ldi	r24, 0x00	; 0
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	a0 e0       	ldi	r26, 0x00	; 0
    2734:	b0 e0       	ldi	r27, 0x00	; 0
    2736:	12 c0       	rjmp	.+36     	; 0x275c <__clzsi2+0x64>
    2738:	80 e0       	ldi	r24, 0x00	; 0
    273a:	e8 16       	cp	r14, r24
    273c:	80 e0       	ldi	r24, 0x00	; 0
    273e:	f8 06       	cpc	r15, r24
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	08 07       	cpc	r16, r24
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	18 07       	cpc	r17, r24
    2748:	28 f0       	brcs	.+10     	; 0x2754 <__clzsi2+0x5c>
    274a:	88 e1       	ldi	r24, 0x18	; 24
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	a0 e0       	ldi	r26, 0x00	; 0
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	04 c0       	rjmp	.+8      	; 0x275c <__clzsi2+0x64>
    2754:	80 e1       	ldi	r24, 0x10	; 16
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	a0 e0       	ldi	r26, 0x00	; 0
    275a:	b0 e0       	ldi	r27, 0x00	; 0
    275c:	20 e2       	ldi	r18, 0x20	; 32
    275e:	30 e0       	ldi	r19, 0x00	; 0
    2760:	40 e0       	ldi	r20, 0x00	; 0
    2762:	50 e0       	ldi	r21, 0x00	; 0
    2764:	28 1b       	sub	r18, r24
    2766:	39 0b       	sbc	r19, r25
    2768:	4a 0b       	sbc	r20, r26
    276a:	5b 0b       	sbc	r21, r27
    276c:	04 c0       	rjmp	.+8      	; 0x2776 <__clzsi2+0x7e>
    276e:	16 95       	lsr	r17
    2770:	07 95       	ror	r16
    2772:	f7 94       	ror	r15
    2774:	e7 94       	ror	r14
    2776:	8a 95       	dec	r24
    2778:	d2 f7       	brpl	.-12     	; 0x276e <__clzsi2+0x76>
    277a:	f7 01       	movw	r30, r14
    277c:	e8 52       	subi	r30, 0x28	; 40
    277e:	fb 4f       	sbci	r31, 0xFB	; 251
    2780:	80 81       	ld	r24, Z
    2782:	28 1b       	sub	r18, r24
    2784:	31 09       	sbc	r19, r1
    2786:	41 09       	sbc	r20, r1
    2788:	51 09       	sbc	r21, r1
    278a:	c9 01       	movw	r24, r18
    278c:	1f 91       	pop	r17
    278e:	0f 91       	pop	r16
    2790:	ff 90       	pop	r15
    2792:	ef 90       	pop	r14
    2794:	08 95       	ret

00002796 <__pack_f>:
    2796:	df 92       	push	r13
    2798:	ef 92       	push	r14
    279a:	ff 92       	push	r15
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	fc 01       	movw	r30, r24
    27a2:	e4 80       	ldd	r14, Z+4	; 0x04
    27a4:	f5 80       	ldd	r15, Z+5	; 0x05
    27a6:	06 81       	ldd	r16, Z+6	; 0x06
    27a8:	17 81       	ldd	r17, Z+7	; 0x07
    27aa:	d1 80       	ldd	r13, Z+1	; 0x01
    27ac:	80 81       	ld	r24, Z
    27ae:	82 30       	cpi	r24, 0x02	; 2
    27b0:	48 f4       	brcc	.+18     	; 0x27c4 <__pack_f+0x2e>
    27b2:	80 e0       	ldi	r24, 0x00	; 0
    27b4:	90 e0       	ldi	r25, 0x00	; 0
    27b6:	a0 e1       	ldi	r26, 0x10	; 16
    27b8:	b0 e0       	ldi	r27, 0x00	; 0
    27ba:	e8 2a       	or	r14, r24
    27bc:	f9 2a       	or	r15, r25
    27be:	0a 2b       	or	r16, r26
    27c0:	1b 2b       	or	r17, r27
    27c2:	a5 c0       	rjmp	.+330    	; 0x290e <__pack_f+0x178>
    27c4:	84 30       	cpi	r24, 0x04	; 4
    27c6:	09 f4       	brne	.+2      	; 0x27ca <__pack_f+0x34>
    27c8:	9f c0       	rjmp	.+318    	; 0x2908 <__pack_f+0x172>
    27ca:	82 30       	cpi	r24, 0x02	; 2
    27cc:	21 f4       	brne	.+8      	; 0x27d6 <__pack_f+0x40>
    27ce:	ee 24       	eor	r14, r14
    27d0:	ff 24       	eor	r15, r15
    27d2:	87 01       	movw	r16, r14
    27d4:	05 c0       	rjmp	.+10     	; 0x27e0 <__pack_f+0x4a>
    27d6:	e1 14       	cp	r14, r1
    27d8:	f1 04       	cpc	r15, r1
    27da:	01 05       	cpc	r16, r1
    27dc:	11 05       	cpc	r17, r1
    27de:	19 f4       	brne	.+6      	; 0x27e6 <__pack_f+0x50>
    27e0:	e0 e0       	ldi	r30, 0x00	; 0
    27e2:	f0 e0       	ldi	r31, 0x00	; 0
    27e4:	96 c0       	rjmp	.+300    	; 0x2912 <__pack_f+0x17c>
    27e6:	62 81       	ldd	r22, Z+2	; 0x02
    27e8:	73 81       	ldd	r23, Z+3	; 0x03
    27ea:	9f ef       	ldi	r25, 0xFF	; 255
    27ec:	62 38       	cpi	r22, 0x82	; 130
    27ee:	79 07       	cpc	r23, r25
    27f0:	0c f0       	brlt	.+2      	; 0x27f4 <__pack_f+0x5e>
    27f2:	5b c0       	rjmp	.+182    	; 0x28aa <__pack_f+0x114>
    27f4:	22 e8       	ldi	r18, 0x82	; 130
    27f6:	3f ef       	ldi	r19, 0xFF	; 255
    27f8:	26 1b       	sub	r18, r22
    27fa:	37 0b       	sbc	r19, r23
    27fc:	2a 31       	cpi	r18, 0x1A	; 26
    27fe:	31 05       	cpc	r19, r1
    2800:	2c f0       	brlt	.+10     	; 0x280c <__pack_f+0x76>
    2802:	20 e0       	ldi	r18, 0x00	; 0
    2804:	30 e0       	ldi	r19, 0x00	; 0
    2806:	40 e0       	ldi	r20, 0x00	; 0
    2808:	50 e0       	ldi	r21, 0x00	; 0
    280a:	2a c0       	rjmp	.+84     	; 0x2860 <__pack_f+0xca>
    280c:	b8 01       	movw	r22, r16
    280e:	a7 01       	movw	r20, r14
    2810:	02 2e       	mov	r0, r18
    2812:	04 c0       	rjmp	.+8      	; 0x281c <__pack_f+0x86>
    2814:	76 95       	lsr	r23
    2816:	67 95       	ror	r22
    2818:	57 95       	ror	r21
    281a:	47 95       	ror	r20
    281c:	0a 94       	dec	r0
    281e:	d2 f7       	brpl	.-12     	; 0x2814 <__pack_f+0x7e>
    2820:	81 e0       	ldi	r24, 0x01	; 1
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	a0 e0       	ldi	r26, 0x00	; 0
    2826:	b0 e0       	ldi	r27, 0x00	; 0
    2828:	04 c0       	rjmp	.+8      	; 0x2832 <__pack_f+0x9c>
    282a:	88 0f       	add	r24, r24
    282c:	99 1f       	adc	r25, r25
    282e:	aa 1f       	adc	r26, r26
    2830:	bb 1f       	adc	r27, r27
    2832:	2a 95       	dec	r18
    2834:	d2 f7       	brpl	.-12     	; 0x282a <__pack_f+0x94>
    2836:	01 97       	sbiw	r24, 0x01	; 1
    2838:	a1 09       	sbc	r26, r1
    283a:	b1 09       	sbc	r27, r1
    283c:	8e 21       	and	r24, r14
    283e:	9f 21       	and	r25, r15
    2840:	a0 23       	and	r26, r16
    2842:	b1 23       	and	r27, r17
    2844:	00 97       	sbiw	r24, 0x00	; 0
    2846:	a1 05       	cpc	r26, r1
    2848:	b1 05       	cpc	r27, r1
    284a:	21 f0       	breq	.+8      	; 0x2854 <__pack_f+0xbe>
    284c:	81 e0       	ldi	r24, 0x01	; 1
    284e:	90 e0       	ldi	r25, 0x00	; 0
    2850:	a0 e0       	ldi	r26, 0x00	; 0
    2852:	b0 e0       	ldi	r27, 0x00	; 0
    2854:	9a 01       	movw	r18, r20
    2856:	ab 01       	movw	r20, r22
    2858:	28 2b       	or	r18, r24
    285a:	39 2b       	or	r19, r25
    285c:	4a 2b       	or	r20, r26
    285e:	5b 2b       	or	r21, r27
    2860:	da 01       	movw	r26, r20
    2862:	c9 01       	movw	r24, r18
    2864:	8f 77       	andi	r24, 0x7F	; 127
    2866:	90 70       	andi	r25, 0x00	; 0
    2868:	a0 70       	andi	r26, 0x00	; 0
    286a:	b0 70       	andi	r27, 0x00	; 0
    286c:	80 34       	cpi	r24, 0x40	; 64
    286e:	91 05       	cpc	r25, r1
    2870:	a1 05       	cpc	r26, r1
    2872:	b1 05       	cpc	r27, r1
    2874:	39 f4       	brne	.+14     	; 0x2884 <__pack_f+0xee>
    2876:	27 ff       	sbrs	r18, 7
    2878:	09 c0       	rjmp	.+18     	; 0x288c <__pack_f+0xf6>
    287a:	20 5c       	subi	r18, 0xC0	; 192
    287c:	3f 4f       	sbci	r19, 0xFF	; 255
    287e:	4f 4f       	sbci	r20, 0xFF	; 255
    2880:	5f 4f       	sbci	r21, 0xFF	; 255
    2882:	04 c0       	rjmp	.+8      	; 0x288c <__pack_f+0xf6>
    2884:	21 5c       	subi	r18, 0xC1	; 193
    2886:	3f 4f       	sbci	r19, 0xFF	; 255
    2888:	4f 4f       	sbci	r20, 0xFF	; 255
    288a:	5f 4f       	sbci	r21, 0xFF	; 255
    288c:	e0 e0       	ldi	r30, 0x00	; 0
    288e:	f0 e0       	ldi	r31, 0x00	; 0
    2890:	20 30       	cpi	r18, 0x00	; 0
    2892:	a0 e0       	ldi	r26, 0x00	; 0
    2894:	3a 07       	cpc	r19, r26
    2896:	a0 e0       	ldi	r26, 0x00	; 0
    2898:	4a 07       	cpc	r20, r26
    289a:	a0 e4       	ldi	r26, 0x40	; 64
    289c:	5a 07       	cpc	r21, r26
    289e:	10 f0       	brcs	.+4      	; 0x28a4 <__pack_f+0x10e>
    28a0:	e1 e0       	ldi	r30, 0x01	; 1
    28a2:	f0 e0       	ldi	r31, 0x00	; 0
    28a4:	79 01       	movw	r14, r18
    28a6:	8a 01       	movw	r16, r20
    28a8:	27 c0       	rjmp	.+78     	; 0x28f8 <__pack_f+0x162>
    28aa:	60 38       	cpi	r22, 0x80	; 128
    28ac:	71 05       	cpc	r23, r1
    28ae:	64 f5       	brge	.+88     	; 0x2908 <__pack_f+0x172>
    28b0:	fb 01       	movw	r30, r22
    28b2:	e1 58       	subi	r30, 0x81	; 129
    28b4:	ff 4f       	sbci	r31, 0xFF	; 255
    28b6:	d8 01       	movw	r26, r16
    28b8:	c7 01       	movw	r24, r14
    28ba:	8f 77       	andi	r24, 0x7F	; 127
    28bc:	90 70       	andi	r25, 0x00	; 0
    28be:	a0 70       	andi	r26, 0x00	; 0
    28c0:	b0 70       	andi	r27, 0x00	; 0
    28c2:	80 34       	cpi	r24, 0x40	; 64
    28c4:	91 05       	cpc	r25, r1
    28c6:	a1 05       	cpc	r26, r1
    28c8:	b1 05       	cpc	r27, r1
    28ca:	39 f4       	brne	.+14     	; 0x28da <__pack_f+0x144>
    28cc:	e7 fe       	sbrs	r14, 7
    28ce:	0d c0       	rjmp	.+26     	; 0x28ea <__pack_f+0x154>
    28d0:	80 e4       	ldi	r24, 0x40	; 64
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	a0 e0       	ldi	r26, 0x00	; 0
    28d6:	b0 e0       	ldi	r27, 0x00	; 0
    28d8:	04 c0       	rjmp	.+8      	; 0x28e2 <__pack_f+0x14c>
    28da:	8f e3       	ldi	r24, 0x3F	; 63
    28dc:	90 e0       	ldi	r25, 0x00	; 0
    28de:	a0 e0       	ldi	r26, 0x00	; 0
    28e0:	b0 e0       	ldi	r27, 0x00	; 0
    28e2:	e8 0e       	add	r14, r24
    28e4:	f9 1e       	adc	r15, r25
    28e6:	0a 1f       	adc	r16, r26
    28e8:	1b 1f       	adc	r17, r27
    28ea:	17 ff       	sbrs	r17, 7
    28ec:	05 c0       	rjmp	.+10     	; 0x28f8 <__pack_f+0x162>
    28ee:	16 95       	lsr	r17
    28f0:	07 95       	ror	r16
    28f2:	f7 94       	ror	r15
    28f4:	e7 94       	ror	r14
    28f6:	31 96       	adiw	r30, 0x01	; 1
    28f8:	87 e0       	ldi	r24, 0x07	; 7
    28fa:	16 95       	lsr	r17
    28fc:	07 95       	ror	r16
    28fe:	f7 94       	ror	r15
    2900:	e7 94       	ror	r14
    2902:	8a 95       	dec	r24
    2904:	d1 f7       	brne	.-12     	; 0x28fa <__pack_f+0x164>
    2906:	05 c0       	rjmp	.+10     	; 0x2912 <__pack_f+0x17c>
    2908:	ee 24       	eor	r14, r14
    290a:	ff 24       	eor	r15, r15
    290c:	87 01       	movw	r16, r14
    290e:	ef ef       	ldi	r30, 0xFF	; 255
    2910:	f0 e0       	ldi	r31, 0x00	; 0
    2912:	6e 2f       	mov	r22, r30
    2914:	67 95       	ror	r22
    2916:	66 27       	eor	r22, r22
    2918:	67 95       	ror	r22
    291a:	90 2f       	mov	r25, r16
    291c:	9f 77       	andi	r25, 0x7F	; 127
    291e:	d7 94       	ror	r13
    2920:	dd 24       	eor	r13, r13
    2922:	d7 94       	ror	r13
    2924:	8e 2f       	mov	r24, r30
    2926:	86 95       	lsr	r24
    2928:	49 2f       	mov	r20, r25
    292a:	46 2b       	or	r20, r22
    292c:	58 2f       	mov	r21, r24
    292e:	5d 29       	or	r21, r13
    2930:	b7 01       	movw	r22, r14
    2932:	ca 01       	movw	r24, r20
    2934:	1f 91       	pop	r17
    2936:	0f 91       	pop	r16
    2938:	ff 90       	pop	r15
    293a:	ef 90       	pop	r14
    293c:	df 90       	pop	r13
    293e:	08 95       	ret

00002940 <__unpack_f>:
    2940:	fc 01       	movw	r30, r24
    2942:	db 01       	movw	r26, r22
    2944:	40 81       	ld	r20, Z
    2946:	51 81       	ldd	r21, Z+1	; 0x01
    2948:	22 81       	ldd	r18, Z+2	; 0x02
    294a:	62 2f       	mov	r22, r18
    294c:	6f 77       	andi	r22, 0x7F	; 127
    294e:	70 e0       	ldi	r23, 0x00	; 0
    2950:	22 1f       	adc	r18, r18
    2952:	22 27       	eor	r18, r18
    2954:	22 1f       	adc	r18, r18
    2956:	93 81       	ldd	r25, Z+3	; 0x03
    2958:	89 2f       	mov	r24, r25
    295a:	88 0f       	add	r24, r24
    295c:	82 2b       	or	r24, r18
    295e:	28 2f       	mov	r18, r24
    2960:	30 e0       	ldi	r19, 0x00	; 0
    2962:	99 1f       	adc	r25, r25
    2964:	99 27       	eor	r25, r25
    2966:	99 1f       	adc	r25, r25
    2968:	11 96       	adiw	r26, 0x01	; 1
    296a:	9c 93       	st	X, r25
    296c:	11 97       	sbiw	r26, 0x01	; 1
    296e:	21 15       	cp	r18, r1
    2970:	31 05       	cpc	r19, r1
    2972:	a9 f5       	brne	.+106    	; 0x29de <__unpack_f+0x9e>
    2974:	41 15       	cp	r20, r1
    2976:	51 05       	cpc	r21, r1
    2978:	61 05       	cpc	r22, r1
    297a:	71 05       	cpc	r23, r1
    297c:	11 f4       	brne	.+4      	; 0x2982 <__unpack_f+0x42>
    297e:	82 e0       	ldi	r24, 0x02	; 2
    2980:	37 c0       	rjmp	.+110    	; 0x29f0 <__unpack_f+0xb0>
    2982:	82 e8       	ldi	r24, 0x82	; 130
    2984:	9f ef       	ldi	r25, 0xFF	; 255
    2986:	13 96       	adiw	r26, 0x03	; 3
    2988:	9c 93       	st	X, r25
    298a:	8e 93       	st	-X, r24
    298c:	12 97       	sbiw	r26, 0x02	; 2
    298e:	9a 01       	movw	r18, r20
    2990:	ab 01       	movw	r20, r22
    2992:	67 e0       	ldi	r22, 0x07	; 7
    2994:	22 0f       	add	r18, r18
    2996:	33 1f       	adc	r19, r19
    2998:	44 1f       	adc	r20, r20
    299a:	55 1f       	adc	r21, r21
    299c:	6a 95       	dec	r22
    299e:	d1 f7       	brne	.-12     	; 0x2994 <__unpack_f+0x54>
    29a0:	83 e0       	ldi	r24, 0x03	; 3
    29a2:	8c 93       	st	X, r24
    29a4:	0d c0       	rjmp	.+26     	; 0x29c0 <__unpack_f+0x80>
    29a6:	22 0f       	add	r18, r18
    29a8:	33 1f       	adc	r19, r19
    29aa:	44 1f       	adc	r20, r20
    29ac:	55 1f       	adc	r21, r21
    29ae:	12 96       	adiw	r26, 0x02	; 2
    29b0:	8d 91       	ld	r24, X+
    29b2:	9c 91       	ld	r25, X
    29b4:	13 97       	sbiw	r26, 0x03	; 3
    29b6:	01 97       	sbiw	r24, 0x01	; 1
    29b8:	13 96       	adiw	r26, 0x03	; 3
    29ba:	9c 93       	st	X, r25
    29bc:	8e 93       	st	-X, r24
    29be:	12 97       	sbiw	r26, 0x02	; 2
    29c0:	20 30       	cpi	r18, 0x00	; 0
    29c2:	80 e0       	ldi	r24, 0x00	; 0
    29c4:	38 07       	cpc	r19, r24
    29c6:	80 e0       	ldi	r24, 0x00	; 0
    29c8:	48 07       	cpc	r20, r24
    29ca:	80 e4       	ldi	r24, 0x40	; 64
    29cc:	58 07       	cpc	r21, r24
    29ce:	58 f3       	brcs	.-42     	; 0x29a6 <__unpack_f+0x66>
    29d0:	14 96       	adiw	r26, 0x04	; 4
    29d2:	2d 93       	st	X+, r18
    29d4:	3d 93       	st	X+, r19
    29d6:	4d 93       	st	X+, r20
    29d8:	5c 93       	st	X, r21
    29da:	17 97       	sbiw	r26, 0x07	; 7
    29dc:	08 95       	ret
    29de:	2f 3f       	cpi	r18, 0xFF	; 255
    29e0:	31 05       	cpc	r19, r1
    29e2:	79 f4       	brne	.+30     	; 0x2a02 <__unpack_f+0xc2>
    29e4:	41 15       	cp	r20, r1
    29e6:	51 05       	cpc	r21, r1
    29e8:	61 05       	cpc	r22, r1
    29ea:	71 05       	cpc	r23, r1
    29ec:	19 f4       	brne	.+6      	; 0x29f4 <__unpack_f+0xb4>
    29ee:	84 e0       	ldi	r24, 0x04	; 4
    29f0:	8c 93       	st	X, r24
    29f2:	08 95       	ret
    29f4:	64 ff       	sbrs	r22, 4
    29f6:	03 c0       	rjmp	.+6      	; 0x29fe <__unpack_f+0xbe>
    29f8:	81 e0       	ldi	r24, 0x01	; 1
    29fa:	8c 93       	st	X, r24
    29fc:	12 c0       	rjmp	.+36     	; 0x2a22 <__unpack_f+0xe2>
    29fe:	1c 92       	st	X, r1
    2a00:	10 c0       	rjmp	.+32     	; 0x2a22 <__unpack_f+0xe2>
    2a02:	2f 57       	subi	r18, 0x7F	; 127
    2a04:	30 40       	sbci	r19, 0x00	; 0
    2a06:	13 96       	adiw	r26, 0x03	; 3
    2a08:	3c 93       	st	X, r19
    2a0a:	2e 93       	st	-X, r18
    2a0c:	12 97       	sbiw	r26, 0x02	; 2
    2a0e:	83 e0       	ldi	r24, 0x03	; 3
    2a10:	8c 93       	st	X, r24
    2a12:	87 e0       	ldi	r24, 0x07	; 7
    2a14:	44 0f       	add	r20, r20
    2a16:	55 1f       	adc	r21, r21
    2a18:	66 1f       	adc	r22, r22
    2a1a:	77 1f       	adc	r23, r23
    2a1c:	8a 95       	dec	r24
    2a1e:	d1 f7       	brne	.-12     	; 0x2a14 <__unpack_f+0xd4>
    2a20:	70 64       	ori	r23, 0x40	; 64
    2a22:	14 96       	adiw	r26, 0x04	; 4
    2a24:	4d 93       	st	X+, r20
    2a26:	5d 93       	st	X+, r21
    2a28:	6d 93       	st	X+, r22
    2a2a:	7c 93       	st	X, r23
    2a2c:	17 97       	sbiw	r26, 0x07	; 7
    2a2e:	08 95       	ret

00002a30 <__fpcmp_parts_f>:
    2a30:	1f 93       	push	r17
    2a32:	dc 01       	movw	r26, r24
    2a34:	fb 01       	movw	r30, r22
    2a36:	9c 91       	ld	r25, X
    2a38:	92 30       	cpi	r25, 0x02	; 2
    2a3a:	08 f4       	brcc	.+2      	; 0x2a3e <__fpcmp_parts_f+0xe>
    2a3c:	47 c0       	rjmp	.+142    	; 0x2acc <__fpcmp_parts_f+0x9c>
    2a3e:	80 81       	ld	r24, Z
    2a40:	82 30       	cpi	r24, 0x02	; 2
    2a42:	08 f4       	brcc	.+2      	; 0x2a46 <__fpcmp_parts_f+0x16>
    2a44:	43 c0       	rjmp	.+134    	; 0x2acc <__fpcmp_parts_f+0x9c>
    2a46:	94 30       	cpi	r25, 0x04	; 4
    2a48:	51 f4       	brne	.+20     	; 0x2a5e <__fpcmp_parts_f+0x2e>
    2a4a:	11 96       	adiw	r26, 0x01	; 1
    2a4c:	1c 91       	ld	r17, X
    2a4e:	84 30       	cpi	r24, 0x04	; 4
    2a50:	99 f5       	brne	.+102    	; 0x2ab8 <__fpcmp_parts_f+0x88>
    2a52:	81 81       	ldd	r24, Z+1	; 0x01
    2a54:	68 2f       	mov	r22, r24
    2a56:	70 e0       	ldi	r23, 0x00	; 0
    2a58:	61 1b       	sub	r22, r17
    2a5a:	71 09       	sbc	r23, r1
    2a5c:	3f c0       	rjmp	.+126    	; 0x2adc <__fpcmp_parts_f+0xac>
    2a5e:	84 30       	cpi	r24, 0x04	; 4
    2a60:	21 f0       	breq	.+8      	; 0x2a6a <__fpcmp_parts_f+0x3a>
    2a62:	92 30       	cpi	r25, 0x02	; 2
    2a64:	31 f4       	brne	.+12     	; 0x2a72 <__fpcmp_parts_f+0x42>
    2a66:	82 30       	cpi	r24, 0x02	; 2
    2a68:	b9 f1       	breq	.+110    	; 0x2ad8 <__fpcmp_parts_f+0xa8>
    2a6a:	81 81       	ldd	r24, Z+1	; 0x01
    2a6c:	88 23       	and	r24, r24
    2a6e:	89 f1       	breq	.+98     	; 0x2ad2 <__fpcmp_parts_f+0xa2>
    2a70:	2d c0       	rjmp	.+90     	; 0x2acc <__fpcmp_parts_f+0x9c>
    2a72:	11 96       	adiw	r26, 0x01	; 1
    2a74:	1c 91       	ld	r17, X
    2a76:	11 97       	sbiw	r26, 0x01	; 1
    2a78:	82 30       	cpi	r24, 0x02	; 2
    2a7a:	f1 f0       	breq	.+60     	; 0x2ab8 <__fpcmp_parts_f+0x88>
    2a7c:	81 81       	ldd	r24, Z+1	; 0x01
    2a7e:	18 17       	cp	r17, r24
    2a80:	d9 f4       	brne	.+54     	; 0x2ab8 <__fpcmp_parts_f+0x88>
    2a82:	12 96       	adiw	r26, 0x02	; 2
    2a84:	2d 91       	ld	r18, X+
    2a86:	3c 91       	ld	r19, X
    2a88:	13 97       	sbiw	r26, 0x03	; 3
    2a8a:	82 81       	ldd	r24, Z+2	; 0x02
    2a8c:	93 81       	ldd	r25, Z+3	; 0x03
    2a8e:	82 17       	cp	r24, r18
    2a90:	93 07       	cpc	r25, r19
    2a92:	94 f0       	brlt	.+36     	; 0x2ab8 <__fpcmp_parts_f+0x88>
    2a94:	28 17       	cp	r18, r24
    2a96:	39 07       	cpc	r19, r25
    2a98:	bc f0       	brlt	.+46     	; 0x2ac8 <__fpcmp_parts_f+0x98>
    2a9a:	14 96       	adiw	r26, 0x04	; 4
    2a9c:	8d 91       	ld	r24, X+
    2a9e:	9d 91       	ld	r25, X+
    2aa0:	0d 90       	ld	r0, X+
    2aa2:	bc 91       	ld	r27, X
    2aa4:	a0 2d       	mov	r26, r0
    2aa6:	24 81       	ldd	r18, Z+4	; 0x04
    2aa8:	35 81       	ldd	r19, Z+5	; 0x05
    2aaa:	46 81       	ldd	r20, Z+6	; 0x06
    2aac:	57 81       	ldd	r21, Z+7	; 0x07
    2aae:	28 17       	cp	r18, r24
    2ab0:	39 07       	cpc	r19, r25
    2ab2:	4a 07       	cpc	r20, r26
    2ab4:	5b 07       	cpc	r21, r27
    2ab6:	18 f4       	brcc	.+6      	; 0x2abe <__fpcmp_parts_f+0x8e>
    2ab8:	11 23       	and	r17, r17
    2aba:	41 f0       	breq	.+16     	; 0x2acc <__fpcmp_parts_f+0x9c>
    2abc:	0a c0       	rjmp	.+20     	; 0x2ad2 <__fpcmp_parts_f+0xa2>
    2abe:	82 17       	cp	r24, r18
    2ac0:	93 07       	cpc	r25, r19
    2ac2:	a4 07       	cpc	r26, r20
    2ac4:	b5 07       	cpc	r27, r21
    2ac6:	40 f4       	brcc	.+16     	; 0x2ad8 <__fpcmp_parts_f+0xa8>
    2ac8:	11 23       	and	r17, r17
    2aca:	19 f0       	breq	.+6      	; 0x2ad2 <__fpcmp_parts_f+0xa2>
    2acc:	61 e0       	ldi	r22, 0x01	; 1
    2ace:	70 e0       	ldi	r23, 0x00	; 0
    2ad0:	05 c0       	rjmp	.+10     	; 0x2adc <__fpcmp_parts_f+0xac>
    2ad2:	6f ef       	ldi	r22, 0xFF	; 255
    2ad4:	7f ef       	ldi	r23, 0xFF	; 255
    2ad6:	02 c0       	rjmp	.+4      	; 0x2adc <__fpcmp_parts_f+0xac>
    2ad8:	60 e0       	ldi	r22, 0x00	; 0
    2ada:	70 e0       	ldi	r23, 0x00	; 0
    2adc:	cb 01       	movw	r24, r22
    2ade:	1f 91       	pop	r17
    2ae0:	08 95       	ret

00002ae2 <__udivmodhi4>:
    2ae2:	aa 1b       	sub	r26, r26
    2ae4:	bb 1b       	sub	r27, r27
    2ae6:	51 e1       	ldi	r21, 0x11	; 17
    2ae8:	07 c0       	rjmp	.+14     	; 0x2af8 <__udivmodhi4_ep>

00002aea <__udivmodhi4_loop>:
    2aea:	aa 1f       	adc	r26, r26
    2aec:	bb 1f       	adc	r27, r27
    2aee:	a6 17       	cp	r26, r22
    2af0:	b7 07       	cpc	r27, r23
    2af2:	10 f0       	brcs	.+4      	; 0x2af8 <__udivmodhi4_ep>
    2af4:	a6 1b       	sub	r26, r22
    2af6:	b7 0b       	sbc	r27, r23

00002af8 <__udivmodhi4_ep>:
    2af8:	88 1f       	adc	r24, r24
    2afa:	99 1f       	adc	r25, r25
    2afc:	5a 95       	dec	r21
    2afe:	a9 f7       	brne	.-22     	; 0x2aea <__udivmodhi4_loop>
    2b00:	80 95       	com	r24
    2b02:	90 95       	com	r25
    2b04:	bc 01       	movw	r22, r24
    2b06:	cd 01       	movw	r24, r26
    2b08:	08 95       	ret

00002b0a <__divmodhi4>:
    2b0a:	97 fb       	bst	r25, 7
    2b0c:	09 2e       	mov	r0, r25
    2b0e:	07 26       	eor	r0, r23
    2b10:	0a d0       	rcall	.+20     	; 0x2b26 <__divmodhi4_neg1>
    2b12:	77 fd       	sbrc	r23, 7
    2b14:	04 d0       	rcall	.+8      	; 0x2b1e <__divmodhi4_neg2>
    2b16:	e5 df       	rcall	.-54     	; 0x2ae2 <__udivmodhi4>
    2b18:	06 d0       	rcall	.+12     	; 0x2b26 <__divmodhi4_neg1>
    2b1a:	00 20       	and	r0, r0
    2b1c:	1a f4       	brpl	.+6      	; 0x2b24 <__divmodhi4_exit>

00002b1e <__divmodhi4_neg2>:
    2b1e:	70 95       	com	r23
    2b20:	61 95       	neg	r22
    2b22:	7f 4f       	sbci	r23, 0xFF	; 255

00002b24 <__divmodhi4_exit>:
    2b24:	08 95       	ret

00002b26 <__divmodhi4_neg1>:
    2b26:	f6 f7       	brtc	.-4      	; 0x2b24 <__divmodhi4_exit>
    2b28:	90 95       	com	r25
    2b2a:	81 95       	neg	r24
    2b2c:	9f 4f       	sbci	r25, 0xFF	; 255
    2b2e:	08 95       	ret

00002b30 <__prologue_saves__>:
    2b30:	2f 92       	push	r2
    2b32:	3f 92       	push	r3
    2b34:	4f 92       	push	r4
    2b36:	5f 92       	push	r5
    2b38:	6f 92       	push	r6
    2b3a:	7f 92       	push	r7
    2b3c:	8f 92       	push	r8
    2b3e:	9f 92       	push	r9
    2b40:	af 92       	push	r10
    2b42:	bf 92       	push	r11
    2b44:	cf 92       	push	r12
    2b46:	df 92       	push	r13
    2b48:	ef 92       	push	r14
    2b4a:	ff 92       	push	r15
    2b4c:	0f 93       	push	r16
    2b4e:	1f 93       	push	r17
    2b50:	cf 93       	push	r28
    2b52:	df 93       	push	r29
    2b54:	cd b7       	in	r28, 0x3d	; 61
    2b56:	de b7       	in	r29, 0x3e	; 62
    2b58:	ca 1b       	sub	r28, r26
    2b5a:	db 0b       	sbc	r29, r27
    2b5c:	0f b6       	in	r0, 0x3f	; 63
    2b5e:	f8 94       	cli
    2b60:	de bf       	out	0x3e, r29	; 62
    2b62:	0f be       	out	0x3f, r0	; 63
    2b64:	cd bf       	out	0x3d, r28	; 61
    2b66:	19 94       	eijmp

00002b68 <__epilogue_restores__>:
    2b68:	2a 88       	ldd	r2, Y+18	; 0x12
    2b6a:	39 88       	ldd	r3, Y+17	; 0x11
    2b6c:	48 88       	ldd	r4, Y+16	; 0x10
    2b6e:	5f 84       	ldd	r5, Y+15	; 0x0f
    2b70:	6e 84       	ldd	r6, Y+14	; 0x0e
    2b72:	7d 84       	ldd	r7, Y+13	; 0x0d
    2b74:	8c 84       	ldd	r8, Y+12	; 0x0c
    2b76:	9b 84       	ldd	r9, Y+11	; 0x0b
    2b78:	aa 84       	ldd	r10, Y+10	; 0x0a
    2b7a:	b9 84       	ldd	r11, Y+9	; 0x09
    2b7c:	c8 84       	ldd	r12, Y+8	; 0x08
    2b7e:	df 80       	ldd	r13, Y+7	; 0x07
    2b80:	ee 80       	ldd	r14, Y+6	; 0x06
    2b82:	fd 80       	ldd	r15, Y+5	; 0x05
    2b84:	0c 81       	ldd	r16, Y+4	; 0x04
    2b86:	1b 81       	ldd	r17, Y+3	; 0x03
    2b88:	aa 81       	ldd	r26, Y+2	; 0x02
    2b8a:	b9 81       	ldd	r27, Y+1	; 0x01
    2b8c:	ce 0f       	add	r28, r30
    2b8e:	d1 1d       	adc	r29, r1
    2b90:	0f b6       	in	r0, 0x3f	; 63
    2b92:	f8 94       	cli
    2b94:	de bf       	out	0x3e, r29	; 62
    2b96:	0f be       	out	0x3f, r0	; 63
    2b98:	cd bf       	out	0x3d, r28	; 61
    2b9a:	ed 01       	movw	r28, r26
    2b9c:	08 95       	ret

00002b9e <pow>:
    2b9e:	fa 01       	movw	r30, r20
    2ba0:	ee 0f       	add	r30, r30
    2ba2:	ff 1f       	adc	r31, r31
    2ba4:	30 96       	adiw	r30, 0x00	; 0
    2ba6:	21 05       	cpc	r18, r1
    2ba8:	31 05       	cpc	r19, r1
    2baa:	99 f1       	breq	.+102    	; 0x2c12 <pow+0x74>
    2bac:	61 15       	cp	r22, r1
    2bae:	71 05       	cpc	r23, r1
    2bb0:	61 f4       	brne	.+24     	; 0x2bca <pow+0x2c>
    2bb2:	80 38       	cpi	r24, 0x80	; 128
    2bb4:	bf e3       	ldi	r27, 0x3F	; 63
    2bb6:	9b 07       	cpc	r25, r27
    2bb8:	49 f1       	breq	.+82     	; 0x2c0c <pow+0x6e>
    2bba:	68 94       	set
    2bbc:	90 38       	cpi	r25, 0x80	; 128
    2bbe:	81 05       	cpc	r24, r1
    2bc0:	61 f0       	breq	.+24     	; 0x2bda <pow+0x3c>
    2bc2:	80 38       	cpi	r24, 0x80	; 128
    2bc4:	bf ef       	ldi	r27, 0xFF	; 255
    2bc6:	9b 07       	cpc	r25, r27
    2bc8:	41 f0       	breq	.+16     	; 0x2bda <pow+0x3c>
    2bca:	99 23       	and	r25, r25
    2bcc:	42 f5       	brpl	.+80     	; 0x2c1e <pow+0x80>
    2bce:	ff 3f       	cpi	r31, 0xFF	; 255
    2bd0:	e1 05       	cpc	r30, r1
    2bd2:	31 05       	cpc	r19, r1
    2bd4:	21 05       	cpc	r18, r1
    2bd6:	11 f1       	breq	.+68     	; 0x2c1c <pow+0x7e>
    2bd8:	e8 94       	clt
    2bda:	08 94       	sec
    2bdc:	e7 95       	ror	r30
    2bde:	d9 01       	movw	r26, r18
    2be0:	aa 23       	and	r26, r26
    2be2:	29 f4       	brne	.+10     	; 0x2bee <pow+0x50>
    2be4:	ab 2f       	mov	r26, r27
    2be6:	be 2f       	mov	r27, r30
    2be8:	f8 5f       	subi	r31, 0xF8	; 248
    2bea:	d0 f3       	brcs	.-12     	; 0x2be0 <pow+0x42>
    2bec:	10 c0       	rjmp	.+32     	; 0x2c0e <pow+0x70>
    2bee:	ff 5f       	subi	r31, 0xFF	; 255
    2bf0:	70 f4       	brcc	.+28     	; 0x2c0e <pow+0x70>
    2bf2:	a6 95       	lsr	r26
    2bf4:	e0 f7       	brcc	.-8      	; 0x2bee <pow+0x50>
    2bf6:	f7 39       	cpi	r31, 0x97	; 151
    2bf8:	50 f0       	brcs	.+20     	; 0x2c0e <pow+0x70>
    2bfa:	19 f0       	breq	.+6      	; 0x2c02 <pow+0x64>
    2bfc:	ff 3a       	cpi	r31, 0xAF	; 175
    2bfe:	38 f4       	brcc	.+14     	; 0x2c0e <pow+0x70>
    2c00:	9f 77       	andi	r25, 0x7F	; 127
    2c02:	9f 93       	push	r25
    2c04:	0c d0       	rcall	.+24     	; 0x2c1e <pow+0x80>
    2c06:	0f 90       	pop	r0
    2c08:	07 fc       	sbrc	r0, 7
    2c0a:	90 58       	subi	r25, 0x80	; 128
    2c0c:	08 95       	ret
    2c0e:	3e f0       	brts	.+14     	; 0x2c1e <pow+0x80>
    2c10:	49 c0       	rjmp	.+146    	; 0x2ca4 <__fp_nan>
    2c12:	60 e0       	ldi	r22, 0x00	; 0
    2c14:	70 e0       	ldi	r23, 0x00	; 0
    2c16:	80 e8       	ldi	r24, 0x80	; 128
    2c18:	9f e3       	ldi	r25, 0x3F	; 63
    2c1a:	08 95       	ret
    2c1c:	4f e7       	ldi	r20, 0x7F	; 127
    2c1e:	9f 77       	andi	r25, 0x7F	; 127
    2c20:	5f 93       	push	r21
    2c22:	4f 93       	push	r20
    2c24:	3f 93       	push	r19
    2c26:	2f 93       	push	r18
    2c28:	d0 d0       	rcall	.+416    	; 0x2dca <log>
    2c2a:	2f 91       	pop	r18
    2c2c:	3f 91       	pop	r19
    2c2e:	4f 91       	pop	r20
    2c30:	5f 91       	pop	r21
    2c32:	61 da       	rcall	.-2878   	; 0x20f6 <__mulsf3>
    2c34:	05 c0       	rjmp	.+10     	; 0x2c40 <exp>
    2c36:	19 f4       	brne	.+6      	; 0x2c3e <pow+0xa0>
    2c38:	0e f0       	brts	.+2      	; 0x2c3c <pow+0x9e>
    2c3a:	2e c0       	rjmp	.+92     	; 0x2c98 <__fp_inf>
    2c3c:	7d c0       	rjmp	.+250    	; 0x2d38 <__fp_zero>
    2c3e:	32 c0       	rjmp	.+100    	; 0x2ca4 <__fp_nan>

00002c40 <exp>:
    2c40:	61 d0       	rcall	.+194    	; 0x2d04 <__fp_splitA>
    2c42:	c8 f3       	brcs	.-14     	; 0x2c36 <pow+0x98>
    2c44:	96 38       	cpi	r25, 0x86	; 134
    2c46:	c0 f7       	brcc	.-16     	; 0x2c38 <pow+0x9a>
    2c48:	07 f8       	bld	r0, 7
    2c4a:	0f 92       	push	r0
    2c4c:	e8 94       	clt
    2c4e:	2b e3       	ldi	r18, 0x3B	; 59
    2c50:	3a ea       	ldi	r19, 0xAA	; 170
    2c52:	48 eb       	ldi	r20, 0xB8	; 184
    2c54:	5f e7       	ldi	r21, 0x7F	; 127
    2c56:	38 d1       	rcall	.+624    	; 0x2ec8 <__mulsf3_pse>
    2c58:	0f 92       	push	r0
    2c5a:	0f 92       	push	r0
    2c5c:	0f 92       	push	r0
    2c5e:	4d b7       	in	r20, 0x3d	; 61
    2c60:	5e b7       	in	r21, 0x3e	; 62
    2c62:	0f 92       	push	r0
    2c64:	f2 d0       	rcall	.+484    	; 0x2e4a <modf>
    2c66:	e4 ee       	ldi	r30, 0xE4	; 228
    2c68:	f0 e0       	ldi	r31, 0x00	; 0
    2c6a:	1f d0       	rcall	.+62     	; 0x2caa <__fp_powser>
    2c6c:	4f 91       	pop	r20
    2c6e:	5f 91       	pop	r21
    2c70:	ef 91       	pop	r30
    2c72:	ff 91       	pop	r31
    2c74:	e5 95       	asr	r30
    2c76:	ee 1f       	adc	r30, r30
    2c78:	ff 1f       	adc	r31, r31
    2c7a:	49 f0       	breq	.+18     	; 0x2c8e <exp+0x4e>
    2c7c:	fe 57       	subi	r31, 0x7E	; 126
    2c7e:	e0 68       	ori	r30, 0x80	; 128
    2c80:	44 27       	eor	r20, r20
    2c82:	ee 0f       	add	r30, r30
    2c84:	44 1f       	adc	r20, r20
    2c86:	fa 95       	dec	r31
    2c88:	e1 f7       	brne	.-8      	; 0x2c82 <exp+0x42>
    2c8a:	41 95       	neg	r20
    2c8c:	55 0b       	sbc	r21, r21
    2c8e:	64 d0       	rcall	.+200    	; 0x2d58 <ldexp>
    2c90:	0f 90       	pop	r0
    2c92:	07 fe       	sbrs	r0, 7
    2c94:	58 c0       	rjmp	.+176    	; 0x2d46 <inverse>
    2c96:	08 95       	ret

00002c98 <__fp_inf>:
    2c98:	97 f9       	bld	r25, 7
    2c9a:	9f 67       	ori	r25, 0x7F	; 127
    2c9c:	80 e8       	ldi	r24, 0x80	; 128
    2c9e:	70 e0       	ldi	r23, 0x00	; 0
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	08 95       	ret

00002ca4 <__fp_nan>:
    2ca4:	9f ef       	ldi	r25, 0xFF	; 255
    2ca6:	80 ec       	ldi	r24, 0xC0	; 192
    2ca8:	08 95       	ret

00002caa <__fp_powser>:
    2caa:	df 93       	push	r29
    2cac:	cf 93       	push	r28
    2cae:	1f 93       	push	r17
    2cb0:	0f 93       	push	r16
    2cb2:	ff 92       	push	r15
    2cb4:	ef 92       	push	r14
    2cb6:	df 92       	push	r13
    2cb8:	7b 01       	movw	r14, r22
    2cba:	8c 01       	movw	r16, r24
    2cbc:	68 94       	set
    2cbe:	05 c0       	rjmp	.+10     	; 0x2cca <__fp_powser+0x20>
    2cc0:	da 2e       	mov	r13, r26
    2cc2:	ef 01       	movw	r28, r30
    2cc4:	ff d0       	rcall	.+510    	; 0x2ec4 <__mulsf3x>
    2cc6:	fe 01       	movw	r30, r28
    2cc8:	e8 94       	clt
    2cca:	a5 91       	lpm	r26, Z+
    2ccc:	25 91       	lpm	r18, Z+
    2cce:	35 91       	lpm	r19, Z+
    2cd0:	45 91       	lpm	r20, Z+
    2cd2:	55 91       	lpm	r21, Z+
    2cd4:	ae f3       	brts	.-22     	; 0x2cc0 <__fp_powser+0x16>
    2cd6:	ef 01       	movw	r28, r30
    2cd8:	59 d1       	rcall	.+690    	; 0x2f8c <__addsf3x>
    2cda:	fe 01       	movw	r30, r28
    2cdc:	97 01       	movw	r18, r14
    2cde:	a8 01       	movw	r20, r16
    2ce0:	da 94       	dec	r13
    2ce2:	79 f7       	brne	.-34     	; 0x2cc2 <__fp_powser+0x18>
    2ce4:	df 90       	pop	r13
    2ce6:	ef 90       	pop	r14
    2ce8:	ff 90       	pop	r15
    2cea:	0f 91       	pop	r16
    2cec:	1f 91       	pop	r17
    2cee:	cf 91       	pop	r28
    2cf0:	df 91       	pop	r29
    2cf2:	08 95       	ret

00002cf4 <__fp_split3>:
    2cf4:	57 fd       	sbrc	r21, 7
    2cf6:	90 58       	subi	r25, 0x80	; 128
    2cf8:	44 0f       	add	r20, r20
    2cfa:	55 1f       	adc	r21, r21
    2cfc:	59 f0       	breq	.+22     	; 0x2d14 <__fp_splitA+0x10>
    2cfe:	5f 3f       	cpi	r21, 0xFF	; 255
    2d00:	71 f0       	breq	.+28     	; 0x2d1e <__fp_splitA+0x1a>
    2d02:	47 95       	ror	r20

00002d04 <__fp_splitA>:
    2d04:	88 0f       	add	r24, r24
    2d06:	97 fb       	bst	r25, 7
    2d08:	99 1f       	adc	r25, r25
    2d0a:	61 f0       	breq	.+24     	; 0x2d24 <__fp_splitA+0x20>
    2d0c:	9f 3f       	cpi	r25, 0xFF	; 255
    2d0e:	79 f0       	breq	.+30     	; 0x2d2e <__fp_splitA+0x2a>
    2d10:	87 95       	ror	r24
    2d12:	08 95       	ret
    2d14:	12 16       	cp	r1, r18
    2d16:	13 06       	cpc	r1, r19
    2d18:	14 06       	cpc	r1, r20
    2d1a:	55 1f       	adc	r21, r21
    2d1c:	f2 cf       	rjmp	.-28     	; 0x2d02 <__fp_split3+0xe>
    2d1e:	46 95       	lsr	r20
    2d20:	f1 df       	rcall	.-30     	; 0x2d04 <__fp_splitA>
    2d22:	08 c0       	rjmp	.+16     	; 0x2d34 <__fp_splitA+0x30>
    2d24:	16 16       	cp	r1, r22
    2d26:	17 06       	cpc	r1, r23
    2d28:	18 06       	cpc	r1, r24
    2d2a:	99 1f       	adc	r25, r25
    2d2c:	f1 cf       	rjmp	.-30     	; 0x2d10 <__fp_splitA+0xc>
    2d2e:	86 95       	lsr	r24
    2d30:	71 05       	cpc	r23, r1
    2d32:	61 05       	cpc	r22, r1
    2d34:	08 94       	sec
    2d36:	08 95       	ret

00002d38 <__fp_zero>:
    2d38:	e8 94       	clt

00002d3a <__fp_szero>:
    2d3a:	bb 27       	eor	r27, r27
    2d3c:	66 27       	eor	r22, r22
    2d3e:	77 27       	eor	r23, r23
    2d40:	cb 01       	movw	r24, r22
    2d42:	97 f9       	bld	r25, 7
    2d44:	08 95       	ret

00002d46 <inverse>:
    2d46:	9b 01       	movw	r18, r22
    2d48:	ac 01       	movw	r20, r24
    2d4a:	60 e0       	ldi	r22, 0x00	; 0
    2d4c:	70 e0       	ldi	r23, 0x00	; 0
    2d4e:	80 e8       	ldi	r24, 0x80	; 128
    2d50:	9f e3       	ldi	r25, 0x3F	; 63
    2d52:	cb ca       	rjmp	.-2666   	; 0x22ea <__divsf3>
    2d54:	a1 cf       	rjmp	.-190    	; 0x2c98 <__fp_inf>
    2d56:	6d c1       	rjmp	.+730    	; 0x3032 <__fp_mpack>

00002d58 <ldexp>:
    2d58:	d5 df       	rcall	.-86     	; 0x2d04 <__fp_splitA>
    2d5a:	e8 f3       	brcs	.-6      	; 0x2d56 <inverse+0x10>
    2d5c:	99 23       	and	r25, r25
    2d5e:	d9 f3       	breq	.-10     	; 0x2d56 <inverse+0x10>
    2d60:	94 0f       	add	r25, r20
    2d62:	51 1d       	adc	r21, r1
    2d64:	bb f3       	brvs	.-18     	; 0x2d54 <inverse+0xe>
    2d66:	91 50       	subi	r25, 0x01	; 1
    2d68:	50 40       	sbci	r21, 0x00	; 0
    2d6a:	94 f0       	brlt	.+36     	; 0x2d90 <ldexp+0x38>
    2d6c:	59 f0       	breq	.+22     	; 0x2d84 <ldexp+0x2c>
    2d6e:	88 23       	and	r24, r24
    2d70:	32 f0       	brmi	.+12     	; 0x2d7e <ldexp+0x26>
    2d72:	66 0f       	add	r22, r22
    2d74:	77 1f       	adc	r23, r23
    2d76:	88 1f       	adc	r24, r24
    2d78:	91 50       	subi	r25, 0x01	; 1
    2d7a:	50 40       	sbci	r21, 0x00	; 0
    2d7c:	c1 f7       	brne	.-16     	; 0x2d6e <ldexp+0x16>
    2d7e:	9e 3f       	cpi	r25, 0xFE	; 254
    2d80:	51 05       	cpc	r21, r1
    2d82:	44 f7       	brge	.-48     	; 0x2d54 <inverse+0xe>
    2d84:	88 0f       	add	r24, r24
    2d86:	91 1d       	adc	r25, r1
    2d88:	96 95       	lsr	r25
    2d8a:	87 95       	ror	r24
    2d8c:	97 f9       	bld	r25, 7
    2d8e:	08 95       	ret
    2d90:	5f 3f       	cpi	r21, 0xFF	; 255
    2d92:	ac f0       	brlt	.+42     	; 0x2dbe <ldexp+0x66>
    2d94:	98 3e       	cpi	r25, 0xE8	; 232
    2d96:	9c f0       	brlt	.+38     	; 0x2dbe <ldexp+0x66>
    2d98:	bb 27       	eor	r27, r27
    2d9a:	86 95       	lsr	r24
    2d9c:	77 95       	ror	r23
    2d9e:	67 95       	ror	r22
    2da0:	b7 95       	ror	r27
    2da2:	08 f4       	brcc	.+2      	; 0x2da6 <ldexp+0x4e>
    2da4:	b1 60       	ori	r27, 0x01	; 1
    2da6:	93 95       	inc	r25
    2da8:	c1 f7       	brne	.-16     	; 0x2d9a <ldexp+0x42>
    2daa:	bb 0f       	add	r27, r27
    2dac:	58 f7       	brcc	.-42     	; 0x2d84 <ldexp+0x2c>
    2dae:	11 f4       	brne	.+4      	; 0x2db4 <ldexp+0x5c>
    2db0:	60 ff       	sbrs	r22, 0
    2db2:	e8 cf       	rjmp	.-48     	; 0x2d84 <ldexp+0x2c>
    2db4:	6f 5f       	subi	r22, 0xFF	; 255
    2db6:	7f 4f       	sbci	r23, 0xFF	; 255
    2db8:	8f 4f       	sbci	r24, 0xFF	; 255
    2dba:	9f 4f       	sbci	r25, 0xFF	; 255
    2dbc:	e3 cf       	rjmp	.-58     	; 0x2d84 <ldexp+0x2c>
    2dbe:	bd cf       	rjmp	.-134    	; 0x2d3a <__fp_szero>
    2dc0:	0e f0       	brts	.+2      	; 0x2dc4 <ldexp+0x6c>
    2dc2:	37 c1       	rjmp	.+622    	; 0x3032 <__fp_mpack>
    2dc4:	6f cf       	rjmp	.-290    	; 0x2ca4 <__fp_nan>
    2dc6:	68 94       	set
    2dc8:	67 cf       	rjmp	.-306    	; 0x2c98 <__fp_inf>

00002dca <log>:
    2dca:	9c df       	rcall	.-200    	; 0x2d04 <__fp_splitA>
    2dcc:	c8 f3       	brcs	.-14     	; 0x2dc0 <ldexp+0x68>
    2dce:	99 23       	and	r25, r25
    2dd0:	d1 f3       	breq	.-12     	; 0x2dc6 <ldexp+0x6e>
    2dd2:	c6 f3       	brts	.-16     	; 0x2dc4 <ldexp+0x6c>
    2dd4:	df 93       	push	r29
    2dd6:	cf 93       	push	r28
    2dd8:	1f 93       	push	r17
    2dda:	0f 93       	push	r16
    2ddc:	ff 92       	push	r15
    2dde:	c9 2f       	mov	r28, r25
    2de0:	dd 27       	eor	r29, r29
    2de2:	88 23       	and	r24, r24
    2de4:	2a f0       	brmi	.+10     	; 0x2df0 <log+0x26>
    2de6:	21 97       	sbiw	r28, 0x01	; 1
    2de8:	66 0f       	add	r22, r22
    2dea:	77 1f       	adc	r23, r23
    2dec:	88 1f       	adc	r24, r24
    2dee:	da f7       	brpl	.-10     	; 0x2de6 <log+0x1c>
    2df0:	20 e0       	ldi	r18, 0x00	; 0
    2df2:	30 e0       	ldi	r19, 0x00	; 0
    2df4:	40 e8       	ldi	r20, 0x80	; 128
    2df6:	5f eb       	ldi	r21, 0xBF	; 191
    2df8:	9f e3       	ldi	r25, 0x3F	; 63
    2dfa:	88 39       	cpi	r24, 0x98	; 152
    2dfc:	20 f0       	brcs	.+8      	; 0x2e06 <log+0x3c>
    2dfe:	80 3e       	cpi	r24, 0xE0	; 224
    2e00:	30 f0       	brcs	.+12     	; 0x2e0e <log+0x44>
    2e02:	21 96       	adiw	r28, 0x01	; 1
    2e04:	8f 77       	andi	r24, 0x7F	; 127
    2e06:	4a d9       	rcall	.-3436   	; 0x209c <__addsf3>
    2e08:	ec e0       	ldi	r30, 0x0C	; 12
    2e0a:	f1 e0       	ldi	r31, 0x01	; 1
    2e0c:	03 c0       	rjmp	.+6      	; 0x2e14 <log+0x4a>
    2e0e:	46 d9       	rcall	.-3444   	; 0x209c <__addsf3>
    2e10:	e9 e3       	ldi	r30, 0x39	; 57
    2e12:	f1 e0       	ldi	r31, 0x01	; 1
    2e14:	4a df       	rcall	.-364    	; 0x2caa <__fp_powser>
    2e16:	8b 01       	movw	r16, r22
    2e18:	be 01       	movw	r22, r28
    2e1a:	ec 01       	movw	r28, r24
    2e1c:	fb 2e       	mov	r15, r27
    2e1e:	6f 57       	subi	r22, 0x7F	; 127
    2e20:	71 09       	sbc	r23, r1
    2e22:	75 95       	asr	r23
    2e24:	77 1f       	adc	r23, r23
    2e26:	88 0b       	sbc	r24, r24
    2e28:	99 0b       	sbc	r25, r25
    2e2a:	3b db       	rcall	.-2442   	; 0x24a2 <__floatsisf>
    2e2c:	28 e1       	ldi	r18, 0x18	; 24
    2e2e:	32 e7       	ldi	r19, 0x72	; 114
    2e30:	41 e3       	ldi	r20, 0x31	; 49
    2e32:	5f e3       	ldi	r21, 0x3F	; 63
    2e34:	47 d0       	rcall	.+142    	; 0x2ec4 <__mulsf3x>
    2e36:	af 2d       	mov	r26, r15
    2e38:	98 01       	movw	r18, r16
    2e3a:	ae 01       	movw	r20, r28
    2e3c:	ff 90       	pop	r15
    2e3e:	0f 91       	pop	r16
    2e40:	1f 91       	pop	r17
    2e42:	cf 91       	pop	r28
    2e44:	df 91       	pop	r29
    2e46:	a2 d0       	rcall	.+324    	; 0x2f8c <__addsf3x>
    2e48:	10 c1       	rjmp	.+544    	; 0x306a <__fp_round>

00002e4a <modf>:
    2e4a:	fa 01       	movw	r30, r20
    2e4c:	dc 01       	movw	r26, r24
    2e4e:	aa 0f       	add	r26, r26
    2e50:	bb 1f       	adc	r27, r27
    2e52:	9b 01       	movw	r18, r22
    2e54:	ac 01       	movw	r20, r24
    2e56:	bf 57       	subi	r27, 0x7F	; 127
    2e58:	28 f4       	brcc	.+10     	; 0x2e64 <modf+0x1a>
    2e5a:	22 27       	eor	r18, r18
    2e5c:	33 27       	eor	r19, r19
    2e5e:	44 27       	eor	r20, r20
    2e60:	50 78       	andi	r21, 0x80	; 128
    2e62:	1f c0       	rjmp	.+62     	; 0x2ea2 <modf+0x58>
    2e64:	b7 51       	subi	r27, 0x17	; 23
    2e66:	88 f4       	brcc	.+34     	; 0x2e8a <modf+0x40>
    2e68:	ab 2f       	mov	r26, r27
    2e6a:	00 24       	eor	r0, r0
    2e6c:	46 95       	lsr	r20
    2e6e:	37 95       	ror	r19
    2e70:	27 95       	ror	r18
    2e72:	01 1c       	adc	r0, r1
    2e74:	a3 95       	inc	r26
    2e76:	d2 f3       	brmi	.-12     	; 0x2e6c <modf+0x22>
    2e78:	00 20       	and	r0, r0
    2e7a:	69 f0       	breq	.+26     	; 0x2e96 <modf+0x4c>
    2e7c:	22 0f       	add	r18, r18
    2e7e:	33 1f       	adc	r19, r19
    2e80:	44 1f       	adc	r20, r20
    2e82:	b3 95       	inc	r27
    2e84:	da f3       	brmi	.-10     	; 0x2e7c <modf+0x32>
    2e86:	0d d0       	rcall	.+26     	; 0x2ea2 <modf+0x58>
    2e88:	d8 c8       	rjmp	.-3664   	; 0x203a <__subsf3>
    2e8a:	61 30       	cpi	r22, 0x01	; 1
    2e8c:	71 05       	cpc	r23, r1
    2e8e:	a0 e8       	ldi	r26, 0x80	; 128
    2e90:	8a 07       	cpc	r24, r26
    2e92:	b9 46       	sbci	r27, 0x69	; 105
    2e94:	30 f4       	brcc	.+12     	; 0x2ea2 <modf+0x58>
    2e96:	9b 01       	movw	r18, r22
    2e98:	ac 01       	movw	r20, r24
    2e9a:	66 27       	eor	r22, r22
    2e9c:	77 27       	eor	r23, r23
    2e9e:	88 27       	eor	r24, r24
    2ea0:	90 78       	andi	r25, 0x80	; 128
    2ea2:	30 96       	adiw	r30, 0x00	; 0
    2ea4:	21 f0       	breq	.+8      	; 0x2eae <modf+0x64>
    2ea6:	20 83       	st	Z, r18
    2ea8:	31 83       	std	Z+1, r19	; 0x01
    2eaa:	42 83       	std	Z+2, r20	; 0x02
    2eac:	53 83       	std	Z+3, r21	; 0x03
    2eae:	08 95       	ret
    2eb0:	ce d0       	rcall	.+412    	; 0x304e <__fp_pscA>
    2eb2:	28 f0       	brcs	.+10     	; 0x2ebe <modf+0x74>
    2eb4:	d3 d0       	rcall	.+422    	; 0x305c <__fp_pscB>
    2eb6:	18 f0       	brcs	.+6      	; 0x2ebe <modf+0x74>
    2eb8:	95 23       	and	r25, r21
    2eba:	09 f0       	breq	.+2      	; 0x2ebe <modf+0x74>
    2ebc:	ed ce       	rjmp	.-550    	; 0x2c98 <__fp_inf>
    2ebe:	f2 ce       	rjmp	.-540    	; 0x2ca4 <__fp_nan>
    2ec0:	11 24       	eor	r1, r1
    2ec2:	3b cf       	rjmp	.-394    	; 0x2d3a <__fp_szero>

00002ec4 <__mulsf3x>:
    2ec4:	17 df       	rcall	.-466    	; 0x2cf4 <__fp_split3>
    2ec6:	a0 f3       	brcs	.-24     	; 0x2eb0 <modf+0x66>

00002ec8 <__mulsf3_pse>:
    2ec8:	95 9f       	mul	r25, r21
    2eca:	d1 f3       	breq	.-12     	; 0x2ec0 <modf+0x76>
    2ecc:	95 0f       	add	r25, r21
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	55 1f       	adc	r21, r21
    2ed2:	62 9f       	mul	r22, r18
    2ed4:	f0 01       	movw	r30, r0
    2ed6:	72 9f       	mul	r23, r18
    2ed8:	bb 27       	eor	r27, r27
    2eda:	f0 0d       	add	r31, r0
    2edc:	b1 1d       	adc	r27, r1
    2ede:	63 9f       	mul	r22, r19
    2ee0:	aa 27       	eor	r26, r26
    2ee2:	f0 0d       	add	r31, r0
    2ee4:	b1 1d       	adc	r27, r1
    2ee6:	aa 1f       	adc	r26, r26
    2ee8:	64 9f       	mul	r22, r20
    2eea:	66 27       	eor	r22, r22
    2eec:	b0 0d       	add	r27, r0
    2eee:	a1 1d       	adc	r26, r1
    2ef0:	66 1f       	adc	r22, r22
    2ef2:	82 9f       	mul	r24, r18
    2ef4:	22 27       	eor	r18, r18
    2ef6:	b0 0d       	add	r27, r0
    2ef8:	a1 1d       	adc	r26, r1
    2efa:	62 1f       	adc	r22, r18
    2efc:	73 9f       	mul	r23, r19
    2efe:	b0 0d       	add	r27, r0
    2f00:	a1 1d       	adc	r26, r1
    2f02:	62 1f       	adc	r22, r18
    2f04:	83 9f       	mul	r24, r19
    2f06:	a0 0d       	add	r26, r0
    2f08:	61 1d       	adc	r22, r1
    2f0a:	22 1f       	adc	r18, r18
    2f0c:	74 9f       	mul	r23, r20
    2f0e:	33 27       	eor	r19, r19
    2f10:	a0 0d       	add	r26, r0
    2f12:	61 1d       	adc	r22, r1
    2f14:	23 1f       	adc	r18, r19
    2f16:	84 9f       	mul	r24, r20
    2f18:	60 0d       	add	r22, r0
    2f1a:	21 1d       	adc	r18, r1
    2f1c:	82 2f       	mov	r24, r18
    2f1e:	76 2f       	mov	r23, r22
    2f20:	6a 2f       	mov	r22, r26
    2f22:	11 24       	eor	r1, r1
    2f24:	9f 57       	subi	r25, 0x7F	; 127
    2f26:	50 40       	sbci	r21, 0x00	; 0
    2f28:	8a f0       	brmi	.+34     	; 0x2f4c <__mulsf3_pse+0x84>
    2f2a:	e1 f0       	breq	.+56     	; 0x2f64 <__mulsf3_pse+0x9c>
    2f2c:	88 23       	and	r24, r24
    2f2e:	4a f0       	brmi	.+18     	; 0x2f42 <__mulsf3_pse+0x7a>
    2f30:	ee 0f       	add	r30, r30
    2f32:	ff 1f       	adc	r31, r31
    2f34:	bb 1f       	adc	r27, r27
    2f36:	66 1f       	adc	r22, r22
    2f38:	77 1f       	adc	r23, r23
    2f3a:	88 1f       	adc	r24, r24
    2f3c:	91 50       	subi	r25, 0x01	; 1
    2f3e:	50 40       	sbci	r21, 0x00	; 0
    2f40:	a9 f7       	brne	.-22     	; 0x2f2c <__mulsf3_pse+0x64>
    2f42:	9e 3f       	cpi	r25, 0xFE	; 254
    2f44:	51 05       	cpc	r21, r1
    2f46:	70 f0       	brcs	.+28     	; 0x2f64 <__mulsf3_pse+0x9c>
    2f48:	a7 ce       	rjmp	.-690    	; 0x2c98 <__fp_inf>
    2f4a:	f7 ce       	rjmp	.-530    	; 0x2d3a <__fp_szero>
    2f4c:	5f 3f       	cpi	r21, 0xFF	; 255
    2f4e:	ec f3       	brlt	.-6      	; 0x2f4a <__mulsf3_pse+0x82>
    2f50:	98 3e       	cpi	r25, 0xE8	; 232
    2f52:	dc f3       	brlt	.-10     	; 0x2f4a <__mulsf3_pse+0x82>
    2f54:	86 95       	lsr	r24
    2f56:	77 95       	ror	r23
    2f58:	67 95       	ror	r22
    2f5a:	b7 95       	ror	r27
    2f5c:	f7 95       	ror	r31
    2f5e:	e7 95       	ror	r30
    2f60:	9f 5f       	subi	r25, 0xFF	; 255
    2f62:	c1 f7       	brne	.-16     	; 0x2f54 <__mulsf3_pse+0x8c>
    2f64:	fe 2b       	or	r31, r30
    2f66:	88 0f       	add	r24, r24
    2f68:	91 1d       	adc	r25, r1
    2f6a:	96 95       	lsr	r25
    2f6c:	87 95       	ror	r24
    2f6e:	97 f9       	bld	r25, 7
    2f70:	08 95       	ret
    2f72:	6d d0       	rcall	.+218    	; 0x304e <__fp_pscA>
    2f74:	30 f0       	brcs	.+12     	; 0x2f82 <__mulsf3_pse+0xba>
    2f76:	72 d0       	rcall	.+228    	; 0x305c <__fp_pscB>
    2f78:	20 f0       	brcs	.+8      	; 0x2f82 <__mulsf3_pse+0xba>
    2f7a:	31 f4       	brne	.+12     	; 0x2f88 <__mulsf3_pse+0xc0>
    2f7c:	9f 3f       	cpi	r25, 0xFF	; 255
    2f7e:	11 f4       	brne	.+4      	; 0x2f84 <__mulsf3_pse+0xbc>
    2f80:	1e f4       	brtc	.+6      	; 0x2f88 <__mulsf3_pse+0xc0>
    2f82:	90 ce       	rjmp	.-736    	; 0x2ca4 <__fp_nan>
    2f84:	0e f4       	brtc	.+2      	; 0x2f88 <__mulsf3_pse+0xc0>
    2f86:	e0 95       	com	r30
    2f88:	e7 fb       	bst	r30, 7
    2f8a:	86 ce       	rjmp	.-756    	; 0x2c98 <__fp_inf>

00002f8c <__addsf3x>:
    2f8c:	e9 2f       	mov	r30, r25
    2f8e:	b2 de       	rcall	.-668    	; 0x2cf4 <__fp_split3>
    2f90:	80 f3       	brcs	.-32     	; 0x2f72 <__mulsf3_pse+0xaa>
    2f92:	ba 17       	cp	r27, r26
    2f94:	62 07       	cpc	r22, r18
    2f96:	73 07       	cpc	r23, r19
    2f98:	84 07       	cpc	r24, r20
    2f9a:	95 07       	cpc	r25, r21
    2f9c:	18 f0       	brcs	.+6      	; 0x2fa4 <__addsf3x+0x18>
    2f9e:	71 f4       	brne	.+28     	; 0x2fbc <__addsf3x+0x30>
    2fa0:	9e f5       	brtc	.+102    	; 0x3008 <__addsf3x+0x7c>
    2fa2:	ca ce       	rjmp	.-620    	; 0x2d38 <__fp_zero>
    2fa4:	0e f4       	brtc	.+2      	; 0x2fa8 <__addsf3x+0x1c>
    2fa6:	e0 95       	com	r30
    2fa8:	0b 2e       	mov	r0, r27
    2faa:	ba 2f       	mov	r27, r26
    2fac:	a0 2d       	mov	r26, r0
    2fae:	0b 01       	movw	r0, r22
    2fb0:	b9 01       	movw	r22, r18
    2fb2:	90 01       	movw	r18, r0
    2fb4:	0c 01       	movw	r0, r24
    2fb6:	ca 01       	movw	r24, r20
    2fb8:	a0 01       	movw	r20, r0
    2fba:	11 24       	eor	r1, r1
    2fbc:	ff 27       	eor	r31, r31
    2fbe:	59 1b       	sub	r21, r25
    2fc0:	99 f0       	breq	.+38     	; 0x2fe8 <__addsf3x+0x5c>
    2fc2:	59 3f       	cpi	r21, 0xF9	; 249
    2fc4:	50 f4       	brcc	.+20     	; 0x2fda <__addsf3x+0x4e>
    2fc6:	50 3e       	cpi	r21, 0xE0	; 224
    2fc8:	68 f1       	brcs	.+90     	; 0x3024 <__addsf3x+0x98>
    2fca:	1a 16       	cp	r1, r26
    2fcc:	f0 40       	sbci	r31, 0x00	; 0
    2fce:	a2 2f       	mov	r26, r18
    2fd0:	23 2f       	mov	r18, r19
    2fd2:	34 2f       	mov	r19, r20
    2fd4:	44 27       	eor	r20, r20
    2fd6:	58 5f       	subi	r21, 0xF8	; 248
    2fd8:	f3 cf       	rjmp	.-26     	; 0x2fc0 <__addsf3x+0x34>
    2fda:	46 95       	lsr	r20
    2fdc:	37 95       	ror	r19
    2fde:	27 95       	ror	r18
    2fe0:	a7 95       	ror	r26
    2fe2:	f0 40       	sbci	r31, 0x00	; 0
    2fe4:	53 95       	inc	r21
    2fe6:	c9 f7       	brne	.-14     	; 0x2fda <__addsf3x+0x4e>
    2fe8:	7e f4       	brtc	.+30     	; 0x3008 <__addsf3x+0x7c>
    2fea:	1f 16       	cp	r1, r31
    2fec:	ba 0b       	sbc	r27, r26
    2fee:	62 0b       	sbc	r22, r18
    2ff0:	73 0b       	sbc	r23, r19
    2ff2:	84 0b       	sbc	r24, r20
    2ff4:	ba f0       	brmi	.+46     	; 0x3024 <__addsf3x+0x98>
    2ff6:	91 50       	subi	r25, 0x01	; 1
    2ff8:	a1 f0       	breq	.+40     	; 0x3022 <__addsf3x+0x96>
    2ffa:	ff 0f       	add	r31, r31
    2ffc:	bb 1f       	adc	r27, r27
    2ffe:	66 1f       	adc	r22, r22
    3000:	77 1f       	adc	r23, r23
    3002:	88 1f       	adc	r24, r24
    3004:	c2 f7       	brpl	.-16     	; 0x2ff6 <__addsf3x+0x6a>
    3006:	0e c0       	rjmp	.+28     	; 0x3024 <__addsf3x+0x98>
    3008:	ba 0f       	add	r27, r26
    300a:	62 1f       	adc	r22, r18
    300c:	73 1f       	adc	r23, r19
    300e:	84 1f       	adc	r24, r20
    3010:	48 f4       	brcc	.+18     	; 0x3024 <__addsf3x+0x98>
    3012:	87 95       	ror	r24
    3014:	77 95       	ror	r23
    3016:	67 95       	ror	r22
    3018:	b7 95       	ror	r27
    301a:	f7 95       	ror	r31
    301c:	9e 3f       	cpi	r25, 0xFE	; 254
    301e:	08 f0       	brcs	.+2      	; 0x3022 <__addsf3x+0x96>
    3020:	b3 cf       	rjmp	.-154    	; 0x2f88 <__mulsf3_pse+0xc0>
    3022:	93 95       	inc	r25
    3024:	88 0f       	add	r24, r24
    3026:	08 f0       	brcs	.+2      	; 0x302a <__addsf3x+0x9e>
    3028:	99 27       	eor	r25, r25
    302a:	ee 0f       	add	r30, r30
    302c:	97 95       	ror	r25
    302e:	87 95       	ror	r24
    3030:	08 95       	ret

00003032 <__fp_mpack>:
    3032:	9f 3f       	cpi	r25, 0xFF	; 255
    3034:	31 f0       	breq	.+12     	; 0x3042 <__fp_mpack_finite+0xc>

00003036 <__fp_mpack_finite>:
    3036:	91 50       	subi	r25, 0x01	; 1
    3038:	20 f4       	brcc	.+8      	; 0x3042 <__fp_mpack_finite+0xc>
    303a:	87 95       	ror	r24
    303c:	77 95       	ror	r23
    303e:	67 95       	ror	r22
    3040:	b7 95       	ror	r27
    3042:	88 0f       	add	r24, r24
    3044:	91 1d       	adc	r25, r1
    3046:	96 95       	lsr	r25
    3048:	87 95       	ror	r24
    304a:	97 f9       	bld	r25, 7
    304c:	08 95       	ret

0000304e <__fp_pscA>:
    304e:	00 24       	eor	r0, r0
    3050:	0a 94       	dec	r0
    3052:	16 16       	cp	r1, r22
    3054:	17 06       	cpc	r1, r23
    3056:	18 06       	cpc	r1, r24
    3058:	09 06       	cpc	r0, r25
    305a:	08 95       	ret

0000305c <__fp_pscB>:
    305c:	00 24       	eor	r0, r0
    305e:	0a 94       	dec	r0
    3060:	12 16       	cp	r1, r18
    3062:	13 06       	cpc	r1, r19
    3064:	14 06       	cpc	r1, r20
    3066:	05 06       	cpc	r0, r21
    3068:	08 95       	ret

0000306a <__fp_round>:
    306a:	09 2e       	mov	r0, r25
    306c:	03 94       	inc	r0
    306e:	00 0c       	add	r0, r0
    3070:	11 f4       	brne	.+4      	; 0x3076 <__fp_round+0xc>
    3072:	88 23       	and	r24, r24
    3074:	52 f0       	brmi	.+20     	; 0x308a <__fp_round+0x20>
    3076:	bb 0f       	add	r27, r27
    3078:	40 f4       	brcc	.+16     	; 0x308a <__fp_round+0x20>
    307a:	bf 2b       	or	r27, r31
    307c:	11 f4       	brne	.+4      	; 0x3082 <__fp_round+0x18>
    307e:	60 ff       	sbrs	r22, 0
    3080:	04 c0       	rjmp	.+8      	; 0x308a <__fp_round+0x20>
    3082:	6f 5f       	subi	r22, 0xFF	; 255
    3084:	7f 4f       	sbci	r23, 0xFF	; 255
    3086:	8f 4f       	sbci	r24, 0xFF	; 255
    3088:	9f 4f       	sbci	r25, 0xFF	; 255
    308a:	08 95       	ret

0000308c <_exit>:
    308c:	f8 94       	cli

0000308e <__stop_program>:
    308e:	ff cf       	rjmp	.-2      	; 0x308e <__stop_program>
